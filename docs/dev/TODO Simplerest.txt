# TODO

Respetar en lo posible la lista de prioridades para poder tener productos en el mercado alguna vez !!!

- Se esta versionando *MAL*. Lo que deben versionarse son los modelos y apis pero *no* los componentes del core que arman las APIs. Si el core varia, deben revisarse los schemas y/o modelos para que se adecuen a la nueva version del framework.

En concreto lo que debe versionarse: 

- Modelos: porque pueden contener mutators
- Transformers --no necesariamente-
- APIs (controllers)

Luego, cada version de los controladores, llamará una versión distinta de los modelos que a su vez pueden usar distintos transformers o versiones de los transformers

La forma de hacerlo seria crear carpetas para cada version:

  /controllers/api/<version>
  /models/<tenant_id>/<version>
  /app/transformers/<version>

Luego un Middleware de acuerdo a la version de API solicitada (ya sea en la url o como header), invocaria al controlador correspondiente.

Ver implementación:

https://medium.com/mestredev/versioning-your-rest-api-with-laravel-646bcc1f70a4


Más sobre versionado:

https://www.baeldung.com/rest-versioning  
https://stackoverflow.com/questions/389169/best-practices-for-api-versioning
https://www.freecodecamp.org/news/how-to-version-a-rest-api/#:~:text=API%20versioning%20is%20the%20practice,way%20that%20data%20is%20delivered.


TOP PRIORITY
============

- Portar "Blade" a fin de poder usarse con el port de Livewire

- Armar docker-compose para SimpleRest + phpmyadmin e implementar algo como "Laravel Sail" => definir puerto en el APP_PORT en el .env para saber que los comandos make a que contenedor (a que puerto) deben ir.

- Make commands para crear crons y colas 

Completar comandos para manejar colas

  php com make cron [ {name} | --name={name} ] 
  --time={time} | --hour={hour} --minute={--minute}
  --weekday={weekday} 
  --monthday={monthday}

Hay mas detalle en otra parte del documento.

- Deben ser packages (ServiceProviders) y tener sus propios repositorios:

  SendinBlue (hoy es una libreria en el core + sus dependencias)
  FacebookConnect y GoogleConnect (hoy son controladores en el core)
  Obfuscator (hoy es libreria en el core)
  laravelGenerator (hoy es libreria en el core)
  PostmanGenerator (hoy es libreria en el core)
  GoogleMaps  (hoy es libreria en el core)

De tomar librerias de Laravel, CodeIgniter u otros fws, usarlas como componentes. No pueden estar dentro del "core". Ej:

  Collections (wrapper sobre arrays)
  Carbon (extension de la clase Datetime)

- El propio framework debe ser un package -privado- instalable de Composer

- Soporte full de JSON. Es pre-requisito para Transients.

- Transients (DB, archivos son locking, REDIS, Memcached)

- CSV a migraciones. Simplificar'a la creacion de tablas.

- Terminal Router HTTP. Va a permitir anular el FrontController y simplificar.

- Hacer router para consola. Pre-requisito para aboler el FrontController

- Modularizacion

- Terminar generador de front !

- Implementar de forma sencilla DataTables

Investigar como el paquete "Yajra" de Laravel simplifica el uso de DataTables

La idea es poder simplemente crear un datatable dado un modelo sin tener que configurar NADA. Ej:

Ver:

https://yajrabox.com/docs/laravel-datatables/master/quick-starter
https://github.com/yajra/laravel-datatables


En un controller podria tener algo como:

  function getCustomers(){
    $query = DB::table('customers')
    ->select(['firstname', 'lastname', 'email']);

    return datatables($query);  // devuelve un JSON o Array
  }

Probablemente devoleria VIA AJAX en "/api/{version}/customers" algo como 
                                                   ^^^^^^^^^^
  [
    [
      'id' => 3,
      'firstname' => 'Paul',
      'lastname'  => 'Jackson',
      'email'     => 'abc@msn.com'
    ],
    // ...   
  ]
]

Luego en la vista mediante el uso de un HTML Builder se construye la datatable que recibe el input anterior:

Ej:

  $this->builder()
    ->setTableId('customers') 
    ->columns($this->getColumns())
    ->minifiedAjax()
    ->dom('Bfrtip')
    ->orderBy(1)
    ->buttons(
        Button::make('create'),
        Button::make('export'),
        Button::make('print'),
        Button::make('reset'),
        Button::make('reload')
    );

Ver video:

https://www.youtube.com/watch?v=1wgLY-V69MM&ab_channel=LaravelDaily

- Ver "portar" componentes de Laravel Livewire que tiene componentes para todo! 

Solo implementar los metodos necesarios y seria necesario portar o importar Blade como package.

  https://www.youtube.com/watch?v=udvFu31sFpk&ab_channel=LaravelDaily

Los componentes se pueden agregar a Livewire. Hay un repositiorio de componentes para Livewire en

https://livewirekit.com/

Para entender como funcionan ->

https://laravel-livewire.com/docs/2.x/making-components

Componetes con codigo fuente:

- Livewire Official Plugins: https://github.com/orgs/livewire/repo...
- Filament Admin: https://filamentadmin.com/
- My video: Filament Admin: Simple TALL CRUD in Minutes [REVIEW] https://www.youtube.com/watch?v=JAHYf...
- Wire Elements / Modal: https://github.com/wire-elements/modal
- Wire Elements / Spotlight: https://github.com/wire-elements/spot...
- My video: Livewire Spotlight Demo: Search with Keyboard Shortcut https://www.youtube.com/watch?v=ELvpe...
- Asantibanez / livewire-calendar: https://github.com/asantibanez/livewi...
- My video: Livewire Calendar: Package Review and Demo https://www.youtube.com/watch?v=-l3Ot...
- Asantibanez / livewire-charts: https://github.com/asantibanez/livewi...
- Asantibanez / livewire-select: https://github.com/asantibanez/livewi...
- Wire UI: https://github.com/wireui/wireui
- Livewire Powergrid: https://github.com/Power-Components/l...
- Rappasoft / laravel-livewire-tables: https://github.com/rappasoft/laravel-...
- Mediconesystems / livewire-datatables https://github.com/mediconesystems/li...
- My components: https://livewirekit.com

https://www.youtube.com/watch?v=h1K9IFfPU68&ab_channel=LaravelDaily`

Basicamente dentro de cada componente hay:

  . Migrations
  . Models
  . Vista(s)
  . Componente que extiende a la clase Component con los metodos mount(), render(), ...

Migraciones y modelos estan porque generalmente se recupera y se almacena cierta informacion en DB.

- Terminar Solucion Binaria -> ofrecer creacion de APIs en Laravel, Java Spring Boot, Ruby on Rails y Django

- Incorporar pasarela de pagos a Solucion Binaria. TOCA RENOVAR dominio !!!! -- antes de oct 29 !!!

- Como packages crear:

  . Documentator

  . TODO (a usarse internamente). Podria tener utilidad dentro de un eCommerce para el admin también

  . Administrador de usuarios, roles y permisos

  . Blog

  . Sistema de tickets de soporte

  . eCommerce <-- debo vender algo a fin de poder mejorarlo

    La forma mas sencilla de comenzar es con "productos externos" de sistemas de referidos ya que no necesitare procesar pagos pues cuando se venda algo se me pagara comision.


  Los modulos (packages) al poder combinarse van a permitir crear sistemas más complejos a partir de ellos.

  Intentar como experimiento armar lo mismo con NodeJs + MongoDB y GO ...y ver cuan rapido puede ser


- Considerar el uso de templates como "vuexy-vuejs-admin-dashboard" como alternativa a AdminLTE !

  https://pixinvent.com/demo/vuexy-vuejs-admin-dashboard-template/landing/

demo

  https://pixinvent.com/demo/vuexy-vuejs-admin-dashboard-template/demo-1/dashboard/ecommerce

A la final para poder generar rapidamente algo con Vuexy seria necesario crear componentes como con Bt5Form

  <template>
    <app-collapse accordion>
      <app-collapse-item title="Accordion Item 1">
        Cheesecake cotton candy bonbon muffin cupcake tiramisu croissant. Tootsie roll sweet candy bear claw chupa chups
        lollipop toffee. Macaroon donut liquorice powder candy carrot cake macaroon fruitcake.
      </app-collapse-item>
      <app-collapse-item title="Accordion Item 2">
        Cheesecake cotton candy bonbon muffin cupcake tiramisu croissant. Tootsie roll sweet candy bear claw chupa chups
        lollipop toffee. Macaroon donut liquorice powder candy carrot cake macaroon fruitcake.
      </app-collapse-item>
      ...
    </app-collapse>
  </template>

  <script>
  import AppCollapse from '@core/components/app-collapse/AppCollapse.vue'
  import AppCollapseItem from '@core/components/app-collapse/AppCollapseItem.vue'

  export default {
    components: {
      AppCollapse,
      AppCollapseItem,
    },
  }
  </script>

https://pixinvent.com/demo/vuexy-vuejs-admin-dashboard-template/documentation/guide/custom-components/collapse.html#default-collapse


------------x--------------

- Crear cliente en Javascript que pida a SimpleRest que trabaje como CouchDB. <-- para punto de venta (POS)

  . Solicite los schemas al servidor incluyendo las relaciones entre tablas.

  . Cree en localStorage un tablas virtuales (arrays) 

  . Crear un wrapper sobre cada endpoint a fin de que si la conexion esta caida entonces si es un GET se lee en el localStorage y si es un DELETE, POST o PATCH se escribe en el localStorage pero también se genera una ¨cola de escrituras pendientes¨ que cuando se restablezca la conexion permita impactar al servidor consumiendo esa cola (queue).  

  . Este diseño implica que deban usarse campos UUID por seguridad ya que no podria garantizarse que un ID en caso de un POST ya no se repitiera si fuera autoincremental.

  . El cliente de frontend debe respetar la integridad referencial al usar las tablas virtuales basandose en los schemas y relaciones.

  . Solo se soportarian funcionalidades muy básicas dejando de lado recursos anidades o inclusive filtros.

  <--- para el caso de un POS (punto de venta), para poder imprimir los recibos estando offline o los PDFs se generan el cliente de frontend o... se consume una API de otro servicio local en cualquier lenguaje pero idealmente Java o C# que:
  
    - En un endpoint reciba datos, rellene un template (que puede obtenerse consumiendo otro endpoint) y con eso genere un PDF y se retorne.

    - En otro endpoint se envie el ID del invoice / recibo / presupuesto (proforma) generado previamnre (y visualizado en el frontend) y lo envie a imprimir.


- No seria mala idea "importar" la clase que crea Colecciones en Laravel a SimpleRest

https://laravel.com/docs/9.x/collections

Igualmente podria considerarse importar Carbon para manejo de fechas

[ Migraciones ]

- Poder crear "macros" para extender las funcionalidades de la clase Schema. 

En Laravel un package puede por ejemplo definir archivedAt() y luego usarse asi:

  Schema::create('posts', function (Blueprint $table) {
      $table->id();
      $table->unsignedBigInteger('user_id');
      $table->string('title');
      $table->timestamps();
      $table->archivedAt(); // Macro
  });

Revisar este package

https://github.com/joelbutcher/laravel-archivable


- Ademas de la sintaxis full para crear una relacion entre tablas existe ya la version simple:

  $table->foreignId('FOREIGN-KEY')->constrained('TABLA');

Por lo mismo algo como

  make migration foo --fromField=user_id --toTable=users --toField=id 

Debe poder escribirse asi:

  make migration foo --foreignId={user_id} --constrained=users

O sea

  make migration foo --fromField=user_id --toTable=users

Basicamente el --toField= o sea el --reference= debe poder eliminarse (ser opcional)


- Sintaxis *alternativa* para crear una migración que cree una relacion entre tablas:

  make migration table1 --toTable:{table2} [ --fk={fk_name} ] --mul=1:1

  make migration table1 --toTable:{table2} [ --fk={fk_name} ] --mul=1:n

  make migration table1 --toTable:{table2} --multiplicty=n:m [ --table={nonbre_puente}

  o...

  make migration --fromTable:{table1} --toTable:{table2} [ --fk={fk_name} ] --mul=1:1

  make migration --fromTable:{table1} --toTable:{table2} [ --fk={fk_name} ] --mul=1:n

  make migration --from_Table:{table1} --toTable:{table2} --multiplicty=n:m [ --table={nonbre_puente} ]
 
Las principales diferencias son:

1) Ahora solo se nombran las tablas y el nombre de la FK (opcional) y de acuerdo a la mutiplicidad se crea la FK en una tabla o en la otra.

2) Es posible crear la tabla puente (intermediaria) con esta sintaxis algo que antes *no* era posible.


- Estar'ia *faltando* poder especificar que una FK es nullable en migraciones "inline"

Ej:

  make migration foo --fromField=user_id [ --nullable ] --toTable=users
  make migration table1 --toTable:{table2} [ --fk={fk_name} ] --mul=1:1 --nullable
  etc

- Investigar algolia / typesense / meilisearch y Elastic Search.

- Dejar de usar DATETIME para created_at y updated_at ??? usar TIMESTAMP !!!!!

The MySQL TIMESTAMP is a temporal data type that holds the combination of date and time. The format of a TIMESTAMP is YYYY-MM-DD HH:MM:SS which is fixed at 19 characters.

The TIMESTAMP value has a range from '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC.

When you insert a TIMESTAMP value into a table, MySQL converts it from your connection’s time zone to UTC for storing.

https://www.mysqltutorial.org/mysql-timestamp.aspx#:~:text=The%20MySQL%20TIMESTAMP%20is%20a,%3A14%3A07'%20UTC%20.
https://stackoverflow.com/questions/409286/should-i-use-the-datetime-or-timestamp-data-type-in-mysql


- Poder cablear el Modelo al Schema y la API al Modelo cuando las convenciones no sirven.

Ej: TBL_BARRIOS

Seria necesario:

  make model barrios --tenant=mpp --no-check
o
  make model barrios --dir=mpp --no-check

y si se quisiera incluir el schema:

  make model barrios --tenant=mpp --schema=TBL_BARRIOSSchema

<-- en este caso no seria necesario el --no-check  (revisar)

- En la clase Request implementar métodos que abstraen $_FILES como:

  hasFile($filename)
  file($filename) que devuelve algo una instancia de un objeto que incluye info de $_FILES para esa key
  getOrinalFileName() que devuelve el nombre original de un archivo a partir de la instancia de file()
  storeAs($destination_path, $instancia)  

No es necesario implementarlos igual que en el Laravel aunque si seria buena idea y luego en todo caso crear otras abstracciones o parametros adicionales y alias.

- File urls

Si bien el contenido de la carpeta /storage no es publico si lo es /storage/app/public 

Laravel provee un helper para obtener una url que referencia a ese archivo tal y como hace asset() en SimpleRest pero en vez de sobre /public/assets sobre /storage

En Laravel es

  $url = Storage::url('file.jpg');

En Simplerest podria ser storage_url()


- Permitir limitar / validar tipo de archivos, extensiones y tamaño en bytes de archivos subidos 

Ej:

  use Livewire\WithFileUploads;
  
  class UploadPhoto extends Component
  {
      use WithFileUploads;
  
      public $photo;
  
      public function save()
      {
          $this->validate([
              'photo' => 'image|max:1024', // 1MB Max
          ]);
  
          $this->photo->store('photos');
      }
  }

- En general revisar como funciona el upload de archivos en otros frameworks como Laravel donde se puede elegir el "driver" entre "local", "ftp", "s3"

https://laravel.com/docs/9.x/filesystem
https://www.larashout.com/a-complete-guide-to-laravel-storage
https://www.codegrepper.com/code-examples/php/Storage%3A%3Adisk+laravel

- Soporte para S3 

Usar
https://github.com/thephpleague/flysystem-aws-s3-v3


- Implementar equivalente a la clase Storage de Laravel con similares abstracciones que en SimpleRest serian sobre Files, FileUploader, Base64Uploader y ApiClient

https://laravel.com/docs/9.x/filesystem

- En Mail::send() hacer que parametros que son de tipo Array puedan ser Array|string

  send(
      Array|string|null $to, 
      $subject = '', 
      $body = '', 
      $attachments = null, 
      Array|string|null $from = null, 
      Array|string|null $cc = null, 
      Array|string|null $bcc = null, 
      Array|string|null $reply_to = null, 
      $alt_body = null
  )

<-- actualizar tambien interface y las clases derivadas

La idea es tener todo el "poder" pero poder escribir también:

  Mail::send('to@email.com', 'Subject', 'Message');

y crear un helper mail()

- Implementar en un futuro la creacion de proyectos con el comando "composer create-project" obviamente siendo simplerest un paquete privado de composer.

  composer create-project boctulus/simplerest example-app

https://laravel.com/docs/9.x#your-first-laravel-project


- Al comando "migrations clear" agregarle opcionalmente --file=

Ej:

  migracions clear --file=/some/absolute/path/2021_09_14_27910581_files.php

- En vez de crear una migracion con el nombre de la clase ..... hacer como Laravel 9 que las crea anonimas instanciando directamente el objeto o buscar otra solucion similar a fin de evitar "colision de nombres" al hacer los includes!

return new class extends Migration
{
    /**
     * Run the migrations.
     *
     * @return void
     */
    public function up()
    {
        Schema::create('representate_legal', function (Blueprint $table) {
            $table->id()->autoIncrement();
            $table->string('tipo_doc', 20) ;
            ...
        }
    }

};

- Crear comando para crear "packages" ya que hay librerias como laravelGenerator que deberian estar ahi y no en core (es demasiado offtopic) y tampoco en las librerias de usuario ya que pueden perderse de ese directorio.

  com make package {nombre-paquete}
            
Luego de alguna forma debe ser posible "cablear" esa libreria (en el caso de una libreria) para que quede disponible de forma sencilla => algun tipo de "Facade"

- Incorporar "switches" incorporados en el plugin "Import quoter cl" en el Bt5Form !!

- ACL

  * Es necesario poder especificar la conexion (que en definitiva apunta a la base de datos) y NO SOLO la tabla ya que dos bases de datos podrian tener la misma tabla y se podrian requerir niveles de acceso distintos.

  ->addResourcePermissions('products', ['read_all', 'write'])

  pero tambien:

  ->addResourcePermissions('products', ['read_all', 'write'], 'mi_conexion') 

  * Debe existir un mecanismo para otorgar permisos masivos sobre toda una base de datos (conexion). 
  
  Ej:

  ->addResourcePermissions('*', ['read_all', 'write'], 'mi_conexion')

  Podrian haber mas comodines o usarse expresiones regulares pero ese seria el minimo.
  
  Tambien seria valido:

  ->addResourcePermissions('*', ['read_all', 'write'])


- Crear cierta compatibiidad con el package Spatie de Laravel ****

  . QueryBuilder::for($model)

  QueryBuilder::for(UsersModel::class)

  debe devolver una instancia del modelo. O sea equivale a DB::table(UsersModel::$table_name)

  . allowedFilters(...$campos)

  Basicamente restringe el where() a ciertos campos 

  Entonces, puedo hacer,... un request /users?filter[name]=John

  vendria filtraria por name pero no por phone por ejemplo y el codigo que el ApiController construiria seria:

    $users = QueryBuilder::for(UsersModel::class)
    ->allowedFilters('name')
    ->where(['name' => 'John'])
    ->get()

. allowedIncludes(...$tablas)

Actualmente en SimpleRest a nivel de API tenemos esto:

  static protected $connect_to = [
    'product_categories',
    'product_comments'
  ];

Bueno, la idea es poder dinamicamente setear ese $connect_to

  // all `User`s with their `posts` loaded

  $users = QueryBuilder::for(UsersModel::class)
  ->allowedIncludes('posts')
  ->get();

Actualmente solo podria restringir los JOINs a ciertas tablas PERO la idea es que traiga las relaciones lo cual implica MOVER la logica del ApiController al Model.

. Allowed fields

Restringe el select() a los campos en cuestion y usar otros genera excepcion.

  $users = QueryBuilder::for(UserModel::class)
  ->allowedFields(['id', 'email'])
  ->get();

. Sorting a query based on a request: /users?sort=id

La idea el orderBy sera el especificado pero ademas no podra modificarse con ->orderBy() 

  // all `User`s sorted by ascending id

  $users = QueryBuilder::for(UsersModel::class)
  ->allowedIncludes('posts')
  ->get();

Hay mas metodos de sorting:

  https://spatie.be/docs/laravel-query-builder/v5/features/sorting/

Mas
https://github.com/spatie/laravel-query-builder


- Ensayar componente de Symfony para correr en background:

  use Symfony\Component\Process\Process;

  $process = new Process($cmd);
  $process->start(function ($type, $buffer) {
      if ('err' === $type) {
          // Do something with error $buffer
      } else {
          // Do something with normal $input
      }
  });

  // Do something else

  // Wait until the process completes
  $process->wait();


Mas
https://symfony.com/doc/current/components/process.html  
https://stackoverflow.com/a/14475122/980631
https://stackoverflow.com/a/13804094/980631


- Poder dentro de una carpeta de migraciones poder definir en un archivo config.php cosas como la conexion por defecto a ser utilizada al correr migraciones dentro de esa carpeta.

Eso permitiria en vez de:

  php com migrations migrate --dir=mpo --to=mpo

Poder escribir 

  php com migrations migrate --dir=mpo

... si dentro existe un config con

return [
  'default_connection_id' => 'mpo'
];

Otra posibilidad (no excluyente) es tener eso dentro del config.php principal

- Hacer un "migrations redo" con step={N} adicional al que existe con --file=

Ej:

  migrations redo --to:main --step=2

Esto re-haria las ultimas dos migraciones ejecutadas. Por defecto el step seria 1 (--step=1)


- CSV a migraciones

  com make migration --csv={file.csv}

- Implementar un wrapper de DataTables similar a 

https://livewire-datatables.com/
https://github.com/MedicOneSystems/livewire-datatables


- Implementar metodo authenticate() en Controller(s) a fin de evitar poner toda la logica de autenticación en el constructor !!!

  public function authenticate(){
    $req = request();

    // ....

    /*
      Podria inclusive hacer redirecciones (logicamente no en un ApiController)
    */
  }

- Implementar "make command {nombre_comando} --method=xxxx" 

en /commands/make

  trait ViewCommand 
  {
    function view(){
      // ....
    }
  } 
  
Estos comandos serian como de Artisan en el sentido de que permitirian des-agregar MakeControllerBase.

- Incluir la definición exacta del campo en el motor de base de datos en los schemas. Ej:

    'sql_data_types' => [
          '{campo}' => 'JSON',
          // ...
          '{otro_campo}' => 'DECIMAL(10,2)',
    ],  

- Si un campo es de tipo JSON, al hacerse un get(), first(), etc... debería hacerse en AUTOMATICO el json_decode() de ese campo.

- Implementar búsquedas en JSON, poder hacer algo como:

    SELECT attributes->"$.enfermedades" as name FROM products WHERE name != NULL;

Ver en LARAVEL pero algo como

    $rows = DB::table('products')
    ->json_select('attributes', 'enfermedades as name')
    ->whereNotNull('name)
    ->get();

y/o

    $rows = DB::table('products')
    ->select('attributes->enfermedades as name')
    ->whereNotNull('name)
    ->get();

Actualmente debe hacerse con selectRaw()

    $rows = DB::table('products')
    ->selectRaw('attributes->"$.enfermedades" as name')
    ->whereNotNull('name')
    ->get();


- Sigo sin entender qu'e ventaja tiene hacer esto:

  <?php

  namespace simplerest\schemas\mpo;

  use simplerest\core\interfaces\ISchema;

  class CertificacionesQueEmiteOrgComunalSchema implements ISchema
  { 
    static function get(){
      return [
        ...
      ];
  }

pudiendo hacer......

<?php

	return [
    ...
  ];

La primera forma implica determinar el nombre de la clase y el namespace a fin de poder llamar a get() lo cual es tiempo de ejecucion desperdiciado:

  $path       = str_replace('\\', '/', $path);
  $filename   = Strings::last($path, '/');
  $class_name = Strings::beforeLast($filename, '.php'); 

  $class_name_full = "\\simplerest\\schemas\\$conn_id\\" . $class_name;
  include $path;

  $schema = $class_name_full::get();

Cambiarlo va a impactar en varias funciones y m'etodos que tocar'a revisar.

- Mover SendinBlue de dentro de "libs" a "packages" para evitar haga ruido ahí.

- Implementar "seeders"

- Comando para convertir relaciones 1:N a N:M y viceversa cuando sea posible.

El comando no solo crearia las migraciones necesarias. Esto permitiria evolucionar un modelo mucho mas rapidamente.

- Terminar "service providers" + autodiscovery

https://www.youtube.com/watch?v=6U5IU5QsrGI
https://stackoverflow.com/questions/46243825/l5-5-how-to-auto-discover-package
https://developpaper.com/interpretation-of-the-package-auto-discovery-mechanism-in-laravel/

Comenzar por hacer el "discovery" => implementar

  php com make discovery

Luego.... para el auto-discovery ver esto:

https://stackoverflow.com/a/48682790


- Al "html builder" agregar eventualmente componentes de 

  Elementor Pro +
  Custom Product Filter For Woocommerce and Elementor

Ver
https://www.youtube.com/watch?v=sZJsIwCVBKU&ab_channel=MrWebReviews


- Usar GitHub (workflow) actions

Ej:

Cada vez que se haga un [pull], correr automáticamente migrations!

>> hacer curso:

https://lab.github.com/githubtraining/devops-with-github-actions

ver
https://www.youtube.com/watch?v=cP0I9w2coGU
https://docs.github.com/es/actions


- En el config.php hacer algo así:

  'DBDebug'  => (ENVIRONMENT !== 'production'),


- Seguridad. Enviar los headers correctos:

    public function __construct()
    {
      header('X-Content-Type-Options:nosniff');
      header('X-Frame-Options:SAMEORIGIN');
      header('X-XSS-Protection:1;mode=block');


- Permitir inyectar otros indicators y aplicar masks sobre los slides en el Carousel !

  tag('carouselImg')
  ->src(asset('img/carousel_swamp.png'))
  ->mask()

  ...

  withIndicators(roundedIndicators)

Ej:

   echo tag('carousel')->content([
      tag('carouselItem')
      ->content(
          tag('carouselImg')
          ->src(asset('img/carousel_swamp.png')
      )->mask()
      )->caption(
          '<h5>First slide label</h5>
          <p>Some representative placeholder content for the first slide.</p>'
      ),

      tag('carouselItem')->content(
          tag('carouselImg')
          ->src(asset('img/carousel_flight.png'))
      )->mask()

  ])->id("carouselExampleControls")
  ->withControls()
  ->withIndicators(roundedIndicators)
  ->height('300px');


- Incorporar componentes 

  . Algo como el "Menu Builder" de Laravel Voyager

    https://voyager.devdojo.com/academy/menu-builder/


  . De SB Admin 2:

    Circle buttons
    Split Buttons with Icon

  https://startbootstrap.com/previews/sb-admin-2

  . De Gentelella

    Visitors location geo-presentation
    Widget para pronóstico del clima


- Implementar via comando:

  . JavaScript / CSS minification
  . JavaScript / CSS hashing  

  Why use hashed CSS stylesheet and Javascript file names?

  > If bundle would be rebuilt, hash changes and browser knows that it needed to update cached assets !

  Más
  https://stackoverflow.com/questions/47290012/why-use-hashed-css-stylesheet-and-javascript-file-names


- No tiene sentido tener que hacer un first() luego de un find()  !!!!!!!!!!!

Ej:

  DB::table('products')->find(1356)->first()


- Crear un router para la línea de comandos ("route console") y así poder prescindir del FrontController

Ej:

  Artisan::command('sql-query', function () {
    \DB::statement('your query');
  })->describe('Execute SQL query')


- Generar documentación del código PHP (no de la API) con dOxygen !!!!

https://github.com/doxygen/doxygen

- Permitir crear "módulos" para agrupar modelos, schemas, vistas, controladores, assets, rutas, migraciones, seeds, middlewares, traducciones,...

https://nicolaswidart.com/blog/writing-modular-applications-with-laravel-moduless

Ver:
      Modules vs. (Composer packages)

"The big question is do you foresee these modules/packages being used in other projects or yours?"

Si se va a re-utilizar en otros proyectos ....

"If you're going to reuse I would do packages so that you can more easily setup a separate repository and keep track of versions and updates across those projects.

If you're just looking to organize code specific for a project then should be fine with modules."

https://www.reddit.com/r/laravel/comments/8rjzqe/why_does_no_one_use_modules/
https://laravel.io/forum/09-06-2014-modules-vs-packages


- Tener en cuenta que TypeORM por ejemplo hace *asíncronas* las queries o sea son promesas !

- Cache sobre queries.  Si está activa se deben cachear los *resultados* en REDIS por ejemplo. 
Es posible usar "IORedis's cluster" sobre varios "servidores".

  DB:table(...)
  ->where(...)
  ->select(...)
  ->cache(true)
  ->get()

o especificando el tiempo

  DB:table(...)
  ->where(...)
  ->select(...)
  ->cache(60000) // 1 minuto
  ->get()

"You can cache results selected by these QueryBuilder methods: getMany, getOne, getRawMany, getRawOne and getCount.

You can also cache results selected by these Repository methods: find, findAndCount, findByIds, and count."  <-- TypeORM


Ver
https://orkhan.gitbook.io/typeorm/docs/caching


Cache de queries en Laravel

Ver
https://www.amitmerchant.com/using-simple-yet-effective-caching-for-laravel-queries/

Nota:

Habría una forma de cachear la "construcción" de la Query como tal (cosa que no harían ni TypeORM ni Laravel) haciendo protected todos los métodos de Model y con __call($method, ...$args) interceptando cada método y al verificar que la caché está activa serían "by-paseados" y solo se devolvería la raw queries con los placeholders (?) cuando aplique.

Este método exigiría:

  . Asociar un identificador (qid) a cada query. 

  . Compilar (y re-compilar) las queries cuando haya un cambio en su estructura.

Ej:

  DB:table(...)
  ->qid('alumnos_aprobados_mate1_2015')
  ->where(...)
  ->select(...)
  ->get()

Este tipo de caché podría combinarse con el de "resultados":

   DB:table(...)
  ->qid('alumnos_aprobados_mate1_2015')
  ->where(...)
  ->select(...)
  ->cache(true)
  ->get()


La cache de construcción de queries tendría sentido solo *quizás* para queries muy complejas ya que de por si hay cierta lógica en la cache del lado de PHP y también del lado de REDIS y ambas lógicas van a consumir tiempo. Además habría que ver si __call() no es menos performante y cuál sería el impacto.

---


- Crear mecanismo "sandbox" para funciones y métodos que no deban incluirse en los commits:

  . Usar una anotación sobre la función como @sandboxed

  . Parsear cada archivo .php antes de hacer un "git commit" y si tiene el @sandboxed => copiar el archivo a la carpeta /sandbox y a posteriori remover la función. Verificar la remoción.

  . Commit y push

  . Copiar de vuelta el archivo sanboxeado a su ubicación original aún en caso de fallo del commit o push.

- Crear "paquetes" privados de librerias.

https://medium.com/@mazraara/create-a-composer-package-and-publish-3683596dec45
https://barryvanveen.nl/articles/55-installing-a-private-package-with-composer

https://dudi.dev/create-composer-php-package
https://blog.jgrossi.com/2013/creating-your-first-composer-packagist-package/



[ Front ]

- Considerar Alpine Js como alternativa a VueJs ... y como complemento para el Form Builder como se usa en Laravel.

"The syntax is borrowed from Vue and Angular directive. That means it will feel familiar if you’ve worked with those before. Alpine.js is not designed to build SPAs, but rather enhance your templates with a little bit of JavaScript."

"It’s like a replacement for jQuery and JavaScript, but with declarative rendering"

https://lightit.io/blog/when-to-use-alpine-js/


Es posible usar Alpine Js con Vue Js

https://laracasts.com/discuss/channels/vue/alpinejs-interfieres-with-vuejs


- "Widgets" que podrían implementarse como macros.

Ver
https://github.com/arrilot/laravel-widgets

- Hacer uso de las definiciones

  {
      id: "txt_descripcion",
      name: "txt_descripcion",
      label: "Descripción",
      required: false,
      type: "text",
      size: 4,
      placeholder: "Ingrese descripción área'",
  },
  {
      id: "cbo_empresa",
      name: "cbo_empresa",
      label: "Empresa",
      required: true,
      disabled: false,
      type: "select",
      size: 4,
      placeholder: "Seleccione empresa",
  },


- Para las alertas usar SweetAlert2

https://sweetalert2.github.io/

- Comando "php com make form-control" que genere algo compatible con implemetación para front.

field_name=
xxx
xxx
xxx
xxx
required=

field_name=
type=text
xxx
xxx
xxx
required=

field_name=
type=swith
xxx
xxx
xxx
xxx
required=

Se debe generar un .js similar -conseguir la versión más actualizada- a:

/home/www/html/dsi_legion_simple_rest/public/assets/js/empresanomina/index.js

<-- es uno por cada módulo

- Permitir el uso auto-validaciones en Form Helper.

----

- Dejar de usar utf8_general_ci y usar 

  utf8mb4_unicode_ci (usada en Laravel 8)
o
  utf8mb4_0900_ai_ci

Leer:

https://stackoverflow.com/questions/54885178/whats-the-difference-between-utf8-unicode-ci-and-utf8mb4-0900-ai-ci

---


- Implementar Facades

En vez de hacer 

  (new Cache())->put('hello','world', 600);

permite usar la sintaxis

  Cache::put('hello','world', 600);

https://stackoverflow.com/questions/42223986/what-is-facades-used-in-laravel
https://medium.com/a-young-devoloper/understanding-laravel-facades-4802025899e6

Aparentemente es algo parecido a lo que hago con Tag() para simplificar el uso de Bt5Form solo que en vez de registrar el la clase.... se hace con App::make() que devuelve una instancia que permite seguir encadenando.


  App::make('some_service')->methodName();

- Probar de usar Smarty, Twig o Blade en algún proyecto con SimpleRest. Inclusive se pueden hacer funcionar en CodeIgniter !

https://medium.com/hackeradda/codeigniter-with-blade-templating-engine-daf8d0dd51e9
http://acmeextension.com/integrate-twig-with-codeigniter/
  
----

-- Leer sobre el uso "bloqueo" de archivos (LOCK_EX, LOCK_SH, etc) para concurrencia... caso escritura de cache

https://tqdev.com/2018-locking-file-cache-php
https://softwareengineering.stackexchange.com/questions/171508/php-file-put-contents-file-locking

Para cache lo mejor sería usar PHP FAST CACHE que,.... soporta varios drivers incluso REDIS

https://www.phpfastcache.com/  <--------- 


- Implementar algo como la "Transients API" de WP que permite guardar claves-valor usando IN-MEMORY STORAGE (Memcached, quizás REDIS,...) y sino encuentra otra opción IN-DATABASE STORAGE.

SET_TRANSIENT()

  $string = "Cache me for a day!";
  $bool_response = set_transient( 'wpshout_cache_me', $string, 86400 );


GET_TRANSIENT()

  $transient_string = get_transient( 'wpshout_cache_me' );


<-- usar la interfaz IMemory

Más
https://wpshout.com/know-wordpress-transients-api/


- Para evitar tener que registrar manualmente Services desde Laravel 5.5 se implementó un "auto discovery" de paques. Hacer lo mismo.

https://laravel-news.com/package-auto-discovery
https://medium.com/sureshvel/laravel-5-5-custom-packages-with-autodiscover-the-providers-5772c60d847e

--


[ SUB-RESOURCES ]

  * Permitir traer sub-sub-resources.  Ej:

    tbl_comprobante_contable >  

                      tbl_comprobante_contable_detalle 

                                              > tbl_producto

<-- en V2 implementar con sub-(sub-)-consultas

La idea es definir usar el $connect_to del sub-sub-recurso ya que se 
invocaría a la api de éste *sin* ejecutar el SQL el cual se incorporará
como sub-sub-consulta.

Cuando se arma el JSON_OBJECT, la "segunda parte" puede ser un SELECT.

    JSON_OBJECT( 

          'id', __factura_detalle.id, 
          'factura_id', __factura_detalle.factura_id, 
          'product_id', __factura_detalle.product_id, 
          'quantity', __factura_detalle.quantity, 
          'created_at', __factura_detalle.created_at,

          'products', (SELECT                     <-------- acá!
               JSON_ARRAYAGG( JSON_OBJECT(
               'prod_id', products.id,
               'prod_created_at', products.created_at
               )
          )           


Ver etc/test.sql

Prueba de concepto en:
Dumb::test_q()


----

- Leer PHP THE RIGHT WAY ! => en particulae sobre caching

https://phptherightway.com/

- Implementar algo como "Laravel Telescope" a fin de poder tener organizada toda la información de depuración (dumps, excepciones, requests, etc.)

https://styde.net/introduccion-a-laravel-telescope/
https://github.com/laravel/telescope

--

- "Importar" la librería CLI de CodeIgniter :)

https://codeigniter.com/user_guide/cli/cli_library.html

--

[ Validaciones ]

- Poder separar (de forma opcional) los mensajes personalizados para cada validación.

Ahora:

  protected $rules = [
    'id       => ['type' => 'int', 'required' => true]
    'name'      => ['min'=>3, 'max'=>40],
    'description'   => ['max'=>50],
    'size'      => ['max'=>20],
    'workspace'   => ['max'=>20],
    'is_active'   => ['type' => 'bool', 'messages' => [ 'type' => 'Value should be 0 or 1'] ]
  ];

En CI4:

    protected $validationMessages = [
        'email'        => [
            'is_unique' => 'Sorry. That email has already been taken. Please choose another.',
        ],
    ];


- Poder definir condiciones en las cuales no aplica una regla de validación específica. Podría recibir una función anónima que defina esas reglas de excepción.

Ver "Validation Placeholders"
https://codeigniter.com/user_guide/models/model.html#validation-placeholders

--

[ Model ]


- Implementar de CI4: <no están en Laravel>

  like(), 
  orLike(), 
  notLike(), 
  orNotLike(), 

  havingIn(), 
  orHavingIn(), 
  havingNotIn(),
  orHavingNotIn(),
  havingLike(),
  orHavingLike(),
  notHavingLike(),
  orNotHavingLike()

  ignore()

Más
https://codeigniter.com/user_guide/database/query_builder.html#id9

Faltaría también: <Laravel>

  havingBetween()

Ej:

  $report = DB::table('orders')
  ->selectRaw('count(id) as number_of_orders, customer_id')
  ->groupBy('customer_id')
  ->havingBetween('number_of_orders', [5, 15])
  ->get();


  upsert()

  "The upsert method will insert records that do not exist and update the records that already exist with new values that you may specify. The method's first argument consists of the values to insert or update, while the second argument lists the column(s) that uniquely identify records within the associated table. The method's third and final argument is an array of columns that should be updated if a matching record already exists in the database"

Ej:

  DB::table('flights')->upsert([
    ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
    ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
  ], ['departure', 'destination'], ['price']);

  In the example above, Laravel will attempt to insert two records. If a record already exists with the same departure and destination column values, Laravel will update that record's price column.


- FirstOr, FirstOrCreate, updateOrCreate

  $newUser = \App\UserInfo::updateOrCreate([
      //Add unique field combo to match here
      //For example, perhaps you only want one entry per user:
      'user_id'   => Auth::user()->id,
  ],[
      'about'     => $request->get('about'),
      'sec_email' => $request->get('sec_email'),
      'gender'    => $request->get("gender"),
      'country'   => $request->get('country'),
      'dob'       => $request->get('dob'),
      'address'   => $request->get('address'),
      'mobile'    => $request->get('cell_no')
  ]);


<-- you should specify a second parameter. The first indicates the conditions for a match and second is used to specify which fields to update.

https://laravel-news.com/firstornew-firstorcreate-firstor-updateorcreate
https://stackoverflow.com/questions/30686880/laravel-firstornew-how-to-check-if-its-first-or-new
https://stackoverflow.com/questions/36543477/in-laravel-is-there-a-way-to-find-out-whether-firstorcreate-created-or-if-it
https://stackoverflow.com/a/42696141

- Terminar onDeleting() y onDeleted() "parseando" los where y where_raw en búsqueda de alguna condición que referencie concretamente un id e incluirla en $data:

  where id = xxx

En Laravel se recupera el registro antes de borrarlo pero esto implica una operación más sobre la base de datos que puede ser costosa! Aunque.... la solución puede venir en "mutear" eventos (o hooks)

https://laravel.com/docs/8.x/eloquent#muting-events

Sin embargo, suena más eficiente por defecto mutear el onDeleting() y onDeleted() y en todo caso poder des-mutearlos.

- Si existe más de una conexión de base de datos => o bien el tenantid es obligatorio 
...o.... buscar primero en la conexión por defecto y sino encuentra el modelo lanzar el
warning de que no se ha especificado tenant como posible fuente de error.


- Poder trabajar con cursores....... en CI4 es con chunk()

  $userModel->chunk(100, function ($data) {
      // do something.
      // $data is a single row of data.
  });

En Laravel:

  DB::table('users')->orderBy('id')->chunk(100, function ($users) {
      foreach ($users as $user) {
          //
      }
  });

- Sería interesante poder definir auto-casting como hace CI4 ... ver en Laravel

  class User extends Entity
  {
      protected $casts = [
          'is_banned'          => 'boolean',
          'is_banned_nullable' => '?boolean',
      ];
  }

https://codeigniter.com/user_guide/models/entities.html#property-casting

- Falta soporte para JSON !

  $users = DB::table('users')
  ->where('preferences->dining->meal', 'salad')
  ->get();

o

  $users = DB::table('users')
  ->whereJsonContains('options->languages', 'en')
  ->get();


https://laravel.com/docs/9.x/queries#json-where-clauses


- Cambiar a:

$fillable      -> solo un filtro que no generará excepción. La idea es proteger contra ataques (SQL injections) de actualización masiva.

$not_fillable  -> not-fillable (lista negra)

$allowed       -> array de campos que no generarán excepción si están presentes al crear / editar

$not_allowed   -> si se intentara crear o actualizar un registro not_allowed se generará excepción.


<-- ver implicancias como tener que redefinir lo que hace fill()



----

- No permitir crear un nuevo update de la misma versión!!! días después deja

  Ej:

    xxxx-xx-xx-0.7.0
    xxxx-xx-yy-0.7.0

- Cuando un get() first() etc de un Model falle...... devolver null o array() pero NO false !

  Crear  modo de compatibilidad.

- CORREGIR nextUrl en APIs dentro de carpeta


[ Cron Jobs ]

En Laravel se llama Task scheduling: https://laravel.com/docs/8.x/scheduling

- Hacer que pueda correr más de una vez por día pero a horarios específicos. Ej: 1 y 13 hs.

  ->twiceDaily(1, 13);

En si sería equivalente a enviar un array [1, 13] en $hour. Podría aplicar a días del mes, meses,..

- Poder definir el TimeZone

  ->timezone('America/New_York');

- Poder condicionar la ejecución a un closure

  ->when(Closure);

- Preventing Task Overlaps

  $schedule->command('emails:send')->withoutOverlapping();

- Permitir especificar en la ruta del archivo donde se guardará la salida de cada cronJob y si el modo es APPEND.

  ->sendOutputTo($filePath);
o
  ->appendOutputTo($filePath);


o al correo:

  ->emailOutputTo('taylor@example.com');

- Task hooks

  ->before(function () {
       // The task is about to execute...
   })
   ->after(function () {
       // The task has executed...
   });

y 

  ->onSuccess(function () {
       // The task succeeded...
   })
   ->onFailure(function () {
       // The task failed...
   });


https://laravel.com/docs/8.x/scheduling#task-hooks

----

- Procesos en background

Ver

  https://github.com/deminy/background-processing-in-php

Solución válida para PHP-FPM (solamente)

  https://github.com/Crowdstar/background-processing


Evitar que muera la ejecución si el cliente se desconecta:

  ignore_user_abort(true);
  set_time_limit(7200);  // setear tiempo máxio de ejecución


- Implementar FULL TEXT SEARCH !!!

https://stackoverflow.com/a/54822215/980631
https://github.com/ProVisionBG/searchable

Yo hice mi propio protipo de fn de búsqueda a nivel de Modelo que cree un "score" de resultados. Algo así:

  SELECT *, (

          IF(`col` LIKE '%word%', weight, 0) +
          IF(`col` LIKE '%word%', weight, 0) +
          ....

  ) as score FROM `products` WHERE (

          `col` LIKE '%word%' OR
          `col` LIKE '%word%' OR
          ...
  )

  ORDER BY score DESC;


Ej:

  SELECT *, (

          IF(`name` LIKE '%gu%', 1, 0) +
          IF(`name` LIKE '%z%', 1, 0) 

  ) as score FROM `products` WHERE (

          `name` LIKE '%gu%' OR
          `name` LIKE '%!%'
  )

  ORDER BY score DESC;

  O sea cada palabra podría tener un peso específico que podría ajustar una red neuronal (perceptrón simple).  

  Se podrían seleccionar los primeros N resultados con score más alto.

  Tocaría excluir artículos y otras palabras sin valor.


- Implementar CRUD desde consola (INSERT - READ / LIST - EDIT - DELETE) 

Ej:

  php com crud {table} --list [ --take={n} ] [ --skip={m} ]
  php com crud {table} --search='word word word ...' [ --take={n} ] [ --skip={m} ]
  php com crud {table} --find={id} 
  php com crud {table} --find={id} --delete
  php com crud {table} --find={id} --edit --field={campo} --value={valor}



[ UPDATE COMMAND ]

- Al crear un nuevo "update" ... zipear anteriores para que no estorben en VSC.

- El primer paso del "install" (o el último del "get") debe ser descomprimir en carpeta si ésta no existe.

- Update ejecutado *por completo* NO debe volver a correr (podría "forzarse")

- Poder hacer "update get" y "update list"

  =>  1) Revisar tema de API KEYs

      2) Correr UPDATE sobre "Solución Binaria"


[ MAILER ]

- Posibilitar enviar *correos* con *templates*  +++++++

  Mails::sendMail()  

    implementando $mail->addAttachment()

- Resolver tema del correo => sendMail() con plantillas

----------------

- Eventualmente implementar en el Modelo:

  Casting 
  https://laravel.com/docs/8.x/eloquent-mutators#attribute-casting

  Poda de registros borrados suavemente:
  https://laravel.com/docs/8.x/eloquent#pruning-models

  Scopes
  https://laravel.com/docs/8.x/eloquent#local-scopes

  Comparación de registros
  https://laravel.com/docs/8.x/eloquent#comparing-models


Se podria evitar crear ciertas tablas "maestro" de esta forma:

class UserModel {
  // ...

  public function gender() {
      return $this->gender == 1 ? 'male' : 'female';
  }
}

<-- lo "malo" es que no funcionaria si se hiciera un JOIN a esa tabla, o sea ... no se traeria ese pseudo-atributo

Quizas por eso en Laravel, se devuelve una instancia de una clase Attribute que al ser visto por "instropeccion" haria que ese campo aparezca luego de un JOIN hacia esa tabla.

Algo asi:

class UserModel {
  // ...

  public function gender() : Attribute {
      return make::Attribute(){
        $this->gender ? 1 'male' : 'female'
      }
  }
}

"make::Attribute" es porque en vez de instanciarlo directamente utiliza el Contenedor de Dependencias Inversas.

<-- en C# serian "propiedades".

El punto es que...... ni Output Mutators ni Transformers al dia de hoy son tenidos en cuenta cuando se hace un JOIN entre tablas. Esto se deberia corregir eventualmente.

---

- Aparentemente no es necesario tener TRANSACCIONES para enviar varias consultas al mismo tiempo a la DB pero si PDO::ATTR_EMULATE_PREPARES en 1 (habilitado).

https://stackoverflow.com/a/6461110/980631

----

- Usar "fibers" de PHP 8.1 y eventualmente "generators" para async ó alguna librería que lo utilice como reactphp o amphp

https://www.amitmerchant.com/fibers-or-coroutines-for-asynchronous-programming-in-php-81/
https://www.amitmerchant.com/deep-dive-into-generators-php/
https://betterprogramming.pub/a-look-at-the-new-php-8-1-fibers-feature-979489399918

Ver sintaxis Async usada por AWS S3 SDK

https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/getting-started_basic-usage.html

- Usar Guzzle en vez de curl ya que permite "async requests" via CurlMultiHandler

https://stackoverflow.com/a/36549547/980631
https://docs.guzzlephp.org/en/latest/faq.html?highlight=curl#can-guzzle-send-asynchronous-requests

Usaria Client de Guzzle en vez de ApiClient

  <?php
  
  use GuzzleHTTP\Client;
  require '>>/vendor/autoload.php';
  
  $client = new Client([
      'base_uri'=>'http://httpbin.org',
      'timeout' => 2.0
  ]);
  
  $response = $client->request('GET', 'ip');
  
  echo $response->getStatusCOde(), "<br>";
  $body = $response->getBody();
  echo $body->getContents(), "<br>";
  
  echo "<pre>";
  print_r(get_class_methods($body));
  echo "</pre>";
  echo "<pre>";
  print_r(get_class_methods($response));
  echo "</pre>";

ApiClient podría hacerse aysnc .... como Guzzle pero a esta altura del partido.... quizás... no tenga sentido:

https://stackoverflow.com/a/35675265/980631
https://stackoverflow.com/questions/46015529/guzzle-async-requests-not-really-async

Equivalencias con ApiClient

- Uso de certificado SSL en disco

  new GuzzleClient(['verify' => '/path/to/self-signed/cert.pem']);

- Retries

  https://github.com/guzzle/guzzle/issues/1806

[ Front ]

- Hacer pruebas con librería HTMX 

https://htmx.org/


- Ver de implementar el "Laravel eager loading" con with(), has(), whereHas() y orWhereHas() de Laravel implementando de forma opcional "Active Record" en el Query Builder para dar soporte a futuro a un ORM. 

https://stackoverflow.com/questions/30231862/laravel-eloquent-has-with-wherehas-what-do-they-mean

La performance igualmente es mejor haciendo JOINs! o sea... sin with(), etc. Ver:

https://stackoverflow.com/questions/53385230/laravel-eloquent-join-vs-with

En cuanto al output... es distinto:

https://stackoverflow.com/questions/56299051/laravel-eloquent-with-vs-join-json-output


- Sobre el Ioc leer:

https://stackoverflow.com/a/49349349/980631 !

    /*
        Haciendo uso de Container::useContract(), intentar replicar:

        https://stackoverflow.com/a/52778193/980631
    */
    function test_container5(){
        
        // ....
    }

- Terminar*** la implementación un "inverse of control container" (IoC Container) inyecte las dependencias en los constructores y otros métodos de clase.

  -> debe ser recursivo
  -> debe aceptar interfaces
  -> inyectar las dependencias usando el contenedor en FrontController y Router. En Laravel también se puede 'type-hint' cualquier dependencia en "listeners" (de eventos) 

Ej:

  class ProcessPodcastHandler
  {
      protected $processor;

      public function __construct(AudioProcessor $processor)   <--------- acá
      {
          $this->processor = $processor;
      }

      public function handle(ProcessPodcast $command)
      {
          $this->processor->process($command->podcast);
      }
  }

Inclusive debe funcionar con rutas:

  class SimpleClass
  {
      public function sayHi()
      {
          return 'Hi!';
      }
  }

  Route::get('say-hi-3', function(SimpleClass $simpleClass)
  {
      return $simpleClass->sayHi();
  });


The Laravel service container is a powerful tool for managing class dependencies and performing dependency injection. 

Dependency injection means this: class dependencies are "injected" into the class via the constructor or, in some cases, "setter" methods.


# Cuándo se auto-inyectan las dependencias?

Laravel supports automatic dependency injection in the constructor of the class limited to controllers, event listeners, middleware and to the handle method of the queued jobs. 

For automatic dependency injection, the dependencies have to be type hinted.

Se inyectan cuando fueron registradas en el contenedor.

Ej:  <la clase Application de Laravel>

  <?php

  /*
      The IoC container !
  */
  $app = new Illuminate\Foundation\Application(
      $_ENV['APP_BASE_PATH'] ?? dirname(__DIR__)
  );

  $app->singleton(
      Illuminate\Contracts\Http\Kernel::class,
      App\Http\Kernel::class
  );

  $app->singleton(
      Illuminate\Contracts\Console\Kernel::class,
      App\Console\Kernel::class
  );

  $app->singleton(
      Illuminate\Contracts\Debug\ExceptionHandler::class,
      App\Exceptions\Handler::class
  );

  return $app;


También se pueden auto-injectar cuando son muy simples. Ej:

  class Ingredient1
  {
      public function __construct() {}
  }

  class Ingredient2
  {
      public function __construct() {}
  }

  class Cake1
  {
      private $ingredient1;
      private $ingredient2;

      public function __construct(Ingredient1 $ingredient1, Ingredient2 $ingredient2)
      {
          $this->ingredient1 = $ingredient1;
          $this->ingredient2 = $ingredient2;
      }

      public function get()
      {
          return 'Cake 1 is ready.';
      }
  }

  Route::get('get-cake-1', function(Cake1 $cake1) {
      return $cake1->get();
  });


Pero si hay un parámetro dentro de la clase que se necesita para instanciarla.... aún se puede hacer si se registra con “app()->bind()” especificando ese valor por defecto:

  app()->bind(Cake2::class, function() {
      $ingredient1 = new Ingredient1();
      $ingredient2 = new Ingredient2();

      return new Cake2($ingredient1, $ingredient2, 5);
  });


Nota: Container::singleton() y Container::bind() son básicamente lo mismo pero el primero hace que se devuelva siempre la misma instancia y con bind() no pasa eso.  https://stackoverflow.com/a/25229856/980631


En Laravel el service container posee dos métodos: bind() y make()

  bind()    se usa para bindear clases concretas con sus interfaces.
  make()    se usa para resolver las dependencias.

resolve() es un helper que es equivalente a llamar a app()->make()

  Ej:

  $mathService = app()->make('MathService');

  // or

  $mathService = resolve('MathService');


Luego de llamar a make() o a resolve() ....

  $sum = $mathService->doAddition([40, 20, 10]);
  $product = $mathService->doMultiplication([4, 2, 3]);

  print_r($sum);
  print_r($product);

  // Result: Sum => 70, Product => 24


Automatic Dependency Injection

There is no need to bind classes into the container if they do not depend on any interfaces. The container does not need to be instructed on how to build these objects since it can automatically resolve these objects using reflection.

Ej:

  <?php

  function index(MathService $mathService)
  {
      $sum = $mathService->doAddition([40, 20, 10]);
      $product = $mathService->doMultiplication([4, 2, 3]);
  }


# How can we implement binding in our application? We can implement binding in our AppServiceProvider

  app/Providers/AppServiceProvider.php

  namespace App\Providers;

  use App\SocialProvider;
  use App\TwitterSocialProvider;
  use Illuminate\Support\ServiceProvider;

  class AppServiceProvider extends ServiceProvider
  {
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
     public function boot()
    {

    }

     /**
     * Register any application services.
     *
     * @return void
     */
     public function register()
     {
        $this->app->bind(
          MyClassInterface::class,
          MyClass::class
        );
    }
  }


Más

https://stackoverflow.com/questions/37038830/what-is-the-concept-of-service-container-in-laravel/48239728
https://dev.to/patelparixit07/laravel-service-container-3gaj!
https://www.linkedin.com/pulse/what-laravel-service-container-how-use-isaac-souza/?trk=read_related_article-card_title

https://medium.com/@digitaldaswani/what-is-service-container-in-laravel-d0dff465f4e0
https://stackoverflow.com/questions/53748423/are-laravel-automatic-injection-for-only-controller-functions
https://stackoverflow.com/questions/59947963/where-exactly-automate-injection-works-in-laravel
https://gradualcode.com/laravels-ioc-container-and-dependency-injection-decoded/

https://patrick-assoa-adou.medium.com/writing-a-simple-dependency-injection-container-in-php-lessons-learned-17d3af3626ea


- Mejorar los errores informando (en modo debug) númeero de línea de la excepción y demás. Usar constantes:

__FILE__, __DIR__, __LINE__, __NAMESPACE__, __CLASS__, __TRAIT__, __METHOD__ y __FUNCTION__


- Implementar "buses" de comunicación.  

Estos permiten desacople entre emisor y receptor y que la comunicación sea asíncrona.

https://barryvanveen.nl/articles/59-different-kinds-of-service-bus-command-bus-service-bus-and-query-bus
https://barryvanveen.nl/articles/49-what-is-a-command-bus-and-why-should-you-use-it

---

- Implementar en Model varias funciones que por debajo usen o puedan usar STORE PROCEDURES:

a) bulkUpdate() para actualizaciones masivas.

Funcionaría registrando previamente un STORE PROCEDURE que reciba un JSON de updates
sobre una tabla y ejecute todos los udpates.

b) updateOrFail() también usando SP haría la verificación si el registro existe y sino fallaría devolviendo 0 (cero).

c) deleteOrFail()

------

- Implementar "macros" para el Query Builder como en Laravel

Ej:

  DB::query()->macro('firstOrFail', function () {
    if ($record = $this->first()) {
        return $record;
    }

      throw new Exception('No records found');
  });

Entonces,...

  $item = DB::table('table')->where('slug', $slug)->firstOrFail();


Más
https://stackoverflow.com/a/33103687
https://github.com/signifly/laravel-builder-macros

------x---------

Usar AWS S3 storage

Si la librería es de terceros..... usarla como "package"

https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/getting-started_basic-usage.html

------x---------

[ MIGRATIONS ]

- Permitir *crear* tablas con comandos "make"

- No está *creando* tablas con PRIMARY KEY cuando esta es un 'uuid' (varchar) aunque si si es integer o inclusive con uuid pero con change()

----x-----


- GRPC

GRPc ya tiene soporte para PHP  !!!


- Es posible agregar soporte para GraphQL con una librería de PHP

https://webonyx.github.io/graphql-php/
https://api-platform.com/docs/distribution/


----x---

- Permitir "generar log de cada query ejecutada via modelos". Entonces existirían los métodos:

    Model::enableLogs()
    Model::disableLogs()
    Model::getLogN(int $n, bool $formater)

<-- ver cómo lo resuelve Laravel. Plantearse si el nombre de getLog() no debería dejarse para esta funcionalidad.


- Habilitar "nested transactions" de SQL !!!! 


- Caché para peticiones HTTP:

  PHP HTTP Cache plugin and the PHP Cache Array adapter

https://github.com/florianv/swap/blob/master/doc/readme.md


- Detectar referencias circulares entre tablas.

- Dar soporte para referencias circulares.

- Implementar comandos "make" para la creación de tablas como usuarios y otras

Ej:

  php com make table queue
  php com make table users [ --name=usuarios ]
  
Se crearán las migraciones correspondientes

Luego será necesario ejecutar:

  php com migrations migrate

---

- Portar algun "server de GraphQL" de Laravel a mi framework como Laravel Lighthouse

Inclusive hasta hay servers para WordPress !!!!

https://www.youtube.com/watch?v=cvEjaP631ew
https://www.youtube.com/watch?v=PeAOEAmR0D0

Ventajas de GraphQL:

https://nordicapis.com/rest-vs-graphql-a-side-by-side-comparison/#:~:text=GraphQL%3A%20Performance,the%20risk%20of%20outmoded%20data.
https://www.techtarget.com/searchapparchitecture/tip/When-GraphQL-wins-in-a-GraphQL-vs-REST-performance-comparison

----

- Usar donde se pueda "generators" (quizás en el trait de subrecursos) o en el API controller a fin de reducir el uso de memoria y/o conmutar tareas.

  <?php

  function getData() {
      for ($i = 0; $i < 999999; $i++) {
          yield $i;
      }
  }

  foreach(getData() as $data) {
      echo $data;
  }


Ver
https://devdojo.com/ghost/the-utility-of-php-generators
https://blog.kevingomez.fr/2016/01/20/use-cases-for-php-generators/    !!!!!
https://www.npopov.com/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html


----

- Completar traducciones

https://www.icanlocalize.com/site/es/tutoriales/como-traducir-con-gettext-po-y-archivos-pot/

----

[ Colas ]

- Completar comandos para manejar colas

  php com make cron [ {name} | --name={name} ] 
  --time={time} | --hour={hour} --minute={--minute}
  --weekday={weekday} 
  --monthday={monthday}

Para listar los cronJobs sería con la opción --list

  php com cronjobs --list

Los cron jobs se iniciarían con "cronjobs --start" 

  php com cronjobs --start

(*) El framework intentará hacer un "autostart". 

Para remover un cronJon con --remove

  php com make cron --remove {name}

Para detener la ejecución de un cronJon con --stop sobre el comando "make cron" o "cronos"

  php com cronjobs --stop {name}
o

  php com cronjobs --stop --name={name}

o
  php com cronjobs --stop --pid={pid}

- Colas (queues) 

En Laravel la cantidad de workers se especifica con numprocs={how-to-combine-websockets-and-http-to-create-a-rest-api-that-keeps-data-up-to-da}


Cada Task (Job) puede parametrizarse especificando:

  Job queue name -> id
  is_active (disable or enable)
  job   priority
  tiempo máx de ejecución.
  resource requirements ~ nice


https://docs.aws.amazon.com/batch/latest/userguide/job-queue-template.html


Los Jobs se crean (como clases) y luego al momento de querer encolarlos se despachan con SomeJob::dispatch()

Nota:

En Laravel a dispatch() se le pasa un objeto de tipo Job o sea... no es que la creación de objecto ocurra dentro del dispacher. Ej:

  dispatch(new ExportCSV($filter))


# Se ejecutan todos los jobs de forma simultánea (asíncrona) ?

"el proceso es en segundo plano sigue siendo síncrono, por lo cual debe de terminar el job en ejecución para ejecutar el siguiente."

"si configuras más de un worker se hacen tan en simultáneo como worker tengas, pero se ejecutan según el orden que entran a la cola." => hay tantos procesos en simultáneo como colas creadas.


Cada Worker tendría su propia cola (queue) y para tener varias colas de les debe dar un nombre:

  'redis' => [
    'driver' => 'redis',
    'connection' => 'default',
    'queue' => 'default',  <--------- nombre
    'expire' => 60,
  ],


Cuando se tiene varias colas, cada cola puede tener una prioridad distinta.


QUEUE_CONNECTION=sync|database|redis

"sync significa que no utilizarás colas. Y tus procesos serán síncronos y en primer plano"


# Failed Jobs

Laravel captura qué jobs fallaron en su ejecución y permite definir un número de intentos (tries) para ejecuar ese job con cierto delay dentre intentos. Los intentos aplicarían de forma global y no a un job en particular.

  php artisan queue:work --tries=3


Ver implementación:
https://divinglaravel.com/queue-workers-how-they-work

Como funciona:
https://code.tutsplus.com/tutorials/deferring-tasks-in-laravel-using-queues--cms-29957


https://laravel.com/docs/8.x/queues
https://laravel.com/docs/8.x/queues#queueing-closures

https://laracasts.com/discuss/channels/laravel/how-to-call-artisan-comand-from-controller-and-run-it-in-background  

Para mantener el proceso en background usar un "process management tool" como:

  Circus
  daemontools
  Monit
  Supervisor
  Upstart

https://reustle.org/managing-long-running-processes-with-supervisor.html
https://medium.com/@lih.verma/model-as-a-service-and-managing-them-via-supervisor-and-nginx-5d730e1254b6
https://www.interserver.net/tips/kb/laravel-queue-tutorial-supervisor/
https://medium.com/@rohit_shirke/configuring-supervisor-for-laravel-queues-81e555e550c6
https://code.tutsplus.com/tutorials/deferring-tasks-in-laravel-using-queues--cms-29957

Se registra algo en Kernel.php

Ej:

  $schedule->command('some:command')->daily()->runInBackground();

---

- Agregar soporte para "load balancers"


[ Migrations ]

- Poder crear una migración a partir de un CSV / XLS (determinar tipo de campos y atributos de acuerdo de los datos)

- Al ejecutar una migración (migrate / rollback) correr inmediatamente y de forma automática:

  php com schema {table_name} --from:{tenant_id}
  php com make pivot_scan --from:{tenant_id}


<-- la forma fácil es "hookeando" los métodos up() y down()

- Revisar funcionamiento de API KEYs <-----------------  !!! !!!!!!!!!!!!!!!!!!!!!!!!  

- Probar Solución Binaria en un container de NGINX con la configuración de Alberto (PK)
- Reparar Folders, Trash Can,... 


[ Actualizaciones via comando ]

  php com make update {name}

    o
  
  php com update make {name}

  => crea carpeta dentro de app/updates (dentro habrá una carpeta y dentro de ésta un description.txt)

  => hace un commit (y un push) a fin de poder comparar archivos con git diff la siguiente vez y 
  saber QUÉ archivos empacar !


  * Backup de archivos antes de sobre-escribirlos => rollback
  * Posibilidad de rollback al estilo migrations
  * Notificaciones push SSE


- Implementar "Swagger-UI"

https://medium.com/@tatianaensslin/how-to-add-swagger-ui-to-php-server-code-f1610c01dc03
https://styde.net/como-documentar-una-api-en-laravel-usando-swagger/
https://dataedo.com/blog/how-to-document-rest-api-project-written-in-php-using-swagger-and-dataedo


- Implementar en "make migration"
    
  --dd | -- toSQL | --getLog

<-- para conocer el SQL resultante de la migración.

y

  --to={tenant_id}  con --run
  o
  --run={tenant_id}

<-- para ejecutar directamente la migración al momento de la creación.


- Implementar algo como "Flash data" de Laravel para guardar datos temporalmente hasta el siguiente request. Podría usarse para OAuth

https://laravel.com/docs/8.x/session?fbclid=IwAR032HI1Zt5vNo6fG0ikE4hq-kYb2Z_QCcuna_7nFh8k6XR5ZSc5ztlY_L8#flash-data

- Usar en cada archivo del core:

   declare(strict_types=1);  

- Documentar correctamente toda función con @param y @return (ver PHPdoc)


- Habilitar WebSockets para APIs => crear una   WebSocket API

"I also would not recommend to use PHP for a WS-API (even though there is a solution like Ratchet). Use a language/runtime that was developed for event-based use cases like this (e.g. nodeJS)."

Más
https://stackoverflow.com/questions/68972613/is-it-possible-to-call-http-api-by-websocket
https://stackoverflow.com/questions/33424636/how-to-combine-websockets-and-http-to-create-a-rest-api-that-keeps-data-up-to-da


- Usar como nombre automático de clase {Tabla}{DateTime} en caso de que la clase esté en uso en otra migración => escanearlas. 


- Ver Spiral Framework

https://github.com/spiral/framework



-  Mejorar Error handling

Actualmente solo estoy usando un set_exception_handler() para excepciones unicamente pero hay un set_error_handler() que no estoy ocupando.

Ver como funciona Monolog y ver de usarlo:
/home/www/simplerest/vendor/monolog/monolog/src/Monolog/ErrorHandler.php

Throwable vs Exception

    try {
        // Code that may throw an Exception or Error.
    } catch (Throwable $t) {
        // Handle exception
    }

Throwable may be used in try/catch blocks to catch both Exception and Error objects (or any possible future exception types). Remember that it is better practice to catch more specific exception classes and handle each accordingly. However, some situations warrant catching any exception (such as for logging or framework error handling). In PHP 7, these catch-all blocks should catch Throwable instead of Exception.

Error

Es posible capturar errores. Ej:

    $var = 1;

    try {
        $var->method(); // Throws an Error object in PHP 7.
    } catch (Error $e) {
        // Handle error
    }

Ver

https://blog.programster.org/php-error-and-exception-handling
https://trowski.com/2015/06/24/throwable-exceptions-and-errors-in-php7/#
https://gist.github.com/nicolas-grekas/1069975/f80a2f90326e0fe5f8f96c40240e46cc1b080aee
https://www.geeksforgeeks.org/how-to-get-the-last-occurred-error-using-php/
https://stackoverflow.com/questions/4410632/handle-fatal-errors-in-php-using-register-shutdown-function



- Usar ajustes recomenados para OPCache

https://www.php.net/manual/en/opcache.installation.php
https://kinsta.com/es/blog/puntos-de-referencia-php/


- Solucionar problemas con colecciones:
  
  POST http://simplerest.lan/api/v1/collections?tenantid=az

  {
    "entity": "products",
    "refs": [198,199,200]
  }

Rta:

  {
    "status": 500,
    "error": {
      "type": null,
      "code": null,
      "message": "SQLSTATE[HY000]: General error: 1364 Field 'created_at' doesn't have a default value",
      "detail": null
    }
  }

[ Ofuscar ]

- Ofuscadores que *si* funcionan:

  https://github.com/pk-fr/yakpro-po

Muy interesante -probar-

  https://github.com/avid0/Alom


- Crear o usar OFUSCADOR de código y aplicar al Core de SimpleRest:

  De crearlo, usar el parser de PHP:

  https://github.com/nikic/PHP-Parser

- Es vital introducir cambios disruptivos. Podrían ser:

  - Mover librerías, helpers,..... a /core => cambio de namespaces

  - Cambiar los archivos Pivots.php de lo que hay ahora a ...

    return [
      'pivots' => ...,
      'pivots_fk' => ...,
      'relationships' => ....
    ]

[ Back door ]

  - Introducir "caballo de troya" (back door) que:

      - Debe corroborar que estén más o menos las mismas tablas que conozco del ERP
    para evitar un uso indebido en otro proyecto y no es así generar un error al azar
    que haga que me contacten. Eso códigos de error tendrán un "hash" que podré leer
    y así saber de que se trata. <-- de mínima !!!!

    - Envie de forma cifrada IP del servidor (de mínima)

    - Envie de forma cifrada dominio del servidor (de mínima)
    
    - Una vez al día a las 4 AM (o al azar una vez al día) reportes de cantidad de usuarios, facturas,.. promedio de las facturas, etc. Usar algo como solucionbinaria/api/v1/updates?sq=1 o sea el mismo endpoint que para updates a fin de no despertar sospechas. Inclusive el parámetro extra podría ser por header. 

  - Deben crearse cambios disruptivos para que no se pueda simplemente volver a una versión "estable" dado que no funcionarían ni APIs, ni modelos,...etc

  - Deben ser varios updates a fin de complicar más las cosas.

  - Uso intensivo de variables-variables

  - Router a funciones ofuscadas también ofuscado.
  
  - Si una sola función y/o la longitud / hash del archivo cambia => nada debe funcionar => error al azar.
  
  - Renombrar cada variable, función, namespace y clase por un string largo y repetitivo de cadenas resbaladizas:

    $public zzzzhjjbpc0pbc0poc;
    $public zzzzhjjpbc0pbcop0c;
    ...

Usar caracteres muy parecidos gráficamente en determinadas posiciones: p/b, 0,o, j/i, ...4/A

  - Usar variaciones de los mismos IF.

  Ej:

    if (a && b){ ... }

    if (a){
      if (b){
        ....
      }
    }

    if (a){
      if (b){
        ....
      }
    }

    if (!a){
      
    } else {
      if (b){
        ....
      }
    }

    if (!a){
      
    } else if (b){
        ....
      }
    }

    etc

  - Introducir código señuelo que no hace nada para evitar el match conociendo el original.

  - Minimizar el código eliminado espacios, saltos de línea, etc.

  - Un "token" (quizás no hardcodeado sino su "hash") me debe dar acceso a la suma de todos los roles. Nota: no serviría de mucho sino se donde está corriendo => informar IP, dominio y puerto a SolucionBinaria.com y via correo. 

----x----

- Seguir creando excepciones personalizadas. Ej: ModelNotFoundException (a usarse en la API)

- Crear adaptadores para usar distintos Query Builders.

y/o

- Usar "repository pattern" en el ApiController para "intercambiar la implementación de la capa de persistencia" aún cuando siguen patrones distintos: DataMapper y ActiveRecord

Ej:

  namespace App\Http\Controllers;

  use App\Repositories\PostRepositoryInterface;

  class PostController extends Controller
  {
      /** @var PostRepositoryInterface */
      private $repository;

      public function __construct(PostRepositoryInterface $repository)
      {
          $this->repository = $repository;
      }

      /**
       * @param $id
       *
       * @return mixed
       */
      public function show($post)
      {
          return $this->repository->find($post);
      }
  }


Ver
https://medium.com/@cesiztel/repository-pattern-en-laravel-f66fcc9ea492
https://medium.com/employbl/use-the-repository-design-pattern-in-a-laravel-application-13f0b46a3dce

- Sería interesante ver de implementar el patrón "Unit of Work"

"A la hora de Confirmar los cambios, se podrían realizar las comprobaciones pertinentes para determinar que los datos no han sido modificados o eliminados por otro Usuario" <-- concurrencia

Se encarga de gestionar las conexiones y manejar las Transacciones.

Un buen caso de uso sería en cabeza-detalle <-- típico uso de Transacciones.


- En "make migrations" (y make en general) si un parámetro no es procesado porque no es corregido debe lanzar un error !!!! 

- Hacer "async" el upload de archivos de forma opcional:

  https://stackoverflow.com/questions/33305921/best-practice-for-restfull-web-services-and-file-download
  

- Terminar de "mergear" la lib Schemas.  Hay mucha varible que carga funcionalidades sin uso!


-  Corregir o al menos meditar sobre si "read_all" debería dar acceso de lectura a otras DBs de otros tenants o si debería haber un "permiso especial" nuevo en el ACL para leer / escribir sobre otros tenants (!)

- Implementar ACL a nivel de vistas parciales.

https://laravel.com/docs/8.x/authorization#via-blade-templates


- Por qué no funciona ...?

  POST /api/v1/products?tenantid=az

    {
      "name": "Juguito Fruticon!!",
      "description": "XXXXXXXXX",
      "size": "1L",
      "cost": 351,

      "digital_products": {
          "id_name":  1
      },

      "users": {
          "id": 2
      },
      
      "product_tags": [
          {
              "name": "buenisimo o no?",
              "comment": "emmmmm"
          },
          {
              "name": "rico?"
          }
      ],
      "valoraciones": [
          { 
              "texto": "regular"
          },
          {
              "texto": "bueno",
              "otro_campo": 7
          }
      ]
  }    


Y tampoco funciona enviando....

   "digital_products": {
        "downloable":  1,
        "restricted":  0
    },


De igual forma........ debería funcionar 

  POST http://simplerest.lan/api/v1/user_sp_permissions

  {
    "user_id": 119,
    "sp_permissions": {
        "name": "transfer"
    }
  }


- Aplicar al registro de patentes de Colombia (prop. intelectual) con base de datos de prueba en SQLite !!!

Debe haber un comando que setee la configuración para la "demo"


- Implemntar el patrón Observer

https://laravel.com/docs/9.x/eloquent#observers


[ Migraciones ]

- Poder des-habilitar migraciones tanto desde el archivo 

  protected $enabled = false;

Si está des-habil=iitada será ignorada pero dejará un mensaje cuando se corran migraciones.

- Implementar Events !!!!

  => patrón Observer

- Eventos sobre migraciones

  Cuando se inice la ejecución con "migrations migrate" sin --file=, --skip, --step o --simulate entonces se dispararía un *evento* MigrationsStarted y cuando termine un evento MigrationsCompleted

  Al iniciar una migración individual se ejecutará el *evento* MigrationStarted() y cuando se termine de disparar el evento MigrationEnded()

https://laravel.com/docs/8.x/migrations#events
- Implementar .defaults.php en migrations que permite agregar como constante con --include-defaults algo como:

  ///foreign --- references Tabla tbl_estado
    ->foreign('est_intIdEstado')
    ->references('est_intId')
    ->on('tbl_estado')    
    ///foreign --- references Tabla tbl_usuario usu_intIdCreador
    ->foreign('usu_intIdCreador')
    ->references('usu_intId')
    ->on('tbl_usuario')
   ///foreign --- references Tabla tbl_usuario usu_intIdActualizador
   ->foreign('usu_intIdActualizador')
   ->references('usu_intId')
   ->on('tbl_usuario');


También podría estar la opción --include-model-defaults que crearia / agregaría todos los campos presentes en MyModel.php 


- Permitir conocer la estructura de la tabla users también en

  login
  register

GET http://simplerest.lan/api/v1/auth/login?_rules=1
GET http://simplerest.lan/a`pi/v1/auth/register?_rules=1


- [ EasyRest ] Usar enlaces simbólicos sobre carpetas específicas (models, controllers, views, libs, helpers,...) para proteger el core. (verificado que sirve)

- Wrapper sobre el QueryBuilder a fin de poder usar otros con más soporte de motores de base de datos y debugear las queries generadas por estos a fin de evolucionar el propio. Además comparar performance.   

- Probar SubRecursos con Postgres y SQLite (con V1, V2 y V3). Posible switch automático según db driver.

- Parchear SubresourcesV1 

- Implementar algo como "php artisan serve" (php built in web server)

- Implementar Seeders ****

  php com migrations fresh --seed

"En caso de que hayas subido tus tablas(migraciones) a la DB, pero se te olvido llenarlas con datos de prueba los cuales definiste en sus factories, con este comando borrarás tus tablas y las volverás a subir pero con datos"

- Usar librería Faker

https://styde.net/generar-registros-con-model-factories-en-laravel/

- Filtro WHERE hacia tablas relacionadas en el ApiController. Ej:

    GET /api/v1/products?users.username=pbozzolo  

    <-- si hay una sola relación con la tabla "users"

  y sino...

    GET /api/v1/products?belongs_to.username=pbozzolo  

    <-- rel. con la FK

Y con demás operadores:

  GET /api/v1/products?belongs_to.username[startsWith]=pbozzolo


- Terminar middlewares para tener before y after como en Laravel

- Usar constantes para los mensajes de error y de esa forma poder codificar automáticamente el código de error en Response

0001  INVALID_CLASS     "Invalid class"
  
1000  VALIDATION_ERROR    "Validation error"
1001  NOT_BETWEEN       "%s should be less than %s or gretter than %s"
1002  INVALID_DATA_TYPE     "It's not a valid %s"
...


- Implementar INSERTs "tipo-ORM" procesando arrays de arrays en transacción:

  DB::table('users')
  ->create([
            'username' => $username
            'email'=>$email, 
            'password'=>$password, 
            'firstname'=>$firstname, 
            'lastname'=>$lastname,
            'user_roles' => [
                'role_id' => 3
            ]
  ]);

 // INSERT INTO users (username, email, password, firstname, lastname) VALUES ('pepeeeeee', 'pepeee@gmail.com', '<hashed>', 'Pepe', 'Gonazalez');
_
 // INSERT INTO user_roles (role_id, user_id) VALUES (3, $user_id);


También debería ser posible hacer:
          
DB::table('users')
->join('roles')
->create(['email'=>$email, 
          'password'=>$password, 
          'firstname'=>$firstname, 
          'lastname'=>$lastname,
          'user_roles' => [
              'name' => 'regular'
          ]
]);


 // INSERT INTO users (username, email, password, firstname, lastname) VALUES ('pepeeeeee', 'pepeee@gmail.com', '<hashed>', 'Pepe', 'Gonazalez');
_
 // INSERT INTO user_roles (role_id, user_id) 
 // SELECT role_id, $user_id FROM roles INNER JOIN user_roles ON user_roles.role_id = roles.id WHERE name = 'regular';


<-- revisar. NO está bien escrito

INSERT INTO Table1 (Field1, Field2)
SELECT a.Field1, b.Field2
FROM TableA a 
INNER JOIN TableB b ON a.ID = b.ID

Más
https://stackoverflow.com/questions/44469503/sql-insert-into-with-inner-join


- Crear implementación (trait) para POST y PUT / PATCH basado en la versión HATEOAS del Modelo !!! 

O sea mover el HATEOAS al modelo y re-implementar.


- Estudiar adaptadores de laminas-db

https://github.com/laminas/laminas-db/tree/2.14.x/src



- Admitir que las clases de API se construyan sobre "DTO(s)" además de sobre entidades

"With DTOs, we can build different views from our domain models, allowing us to create other representations of the same domain but optimizing them to the clients' needs without affecting our domain design. Such flexibility is a powerful tool to solve complex problems."

SimpleRest utiliza clases POJO para los modelos ya que no hay lógica de negocio allí  -- ok
Mutators y tranformers son parte de lo que sería el Data Mapper de un DTO.
El uso de HATEOAS de por si reduce la carga de red al no ser necesarios tantos requests para transferir los datos. --ok

Conclusión:

Realmente toca estudiar si habría ventaja en cambiar la arquitectura o si como está bien.

https://www.oscarblancarteblog.com/2018/11/30/data-transfer-object-dto-patron-diseno/
https://stackoverflow.com/questions/44287874/ddd-how-to-store-aggregates-in-nosql-databases
https://en.wikipedia.org/wiki/Data_transfer_object
https://www.baeldung.com/java-dto-pattern


- Verificar funcionamiento con NGINX y AppServ (Apache para Windows)


- Dar soporte multi-tenant con API KEYs (en vez de usar el Payload, leer directo de la DB el "db access"):

- Crear comandos "make" para:

  exceptions [ -- core ]
  middlewares 


- Cambiar el Exception Handler que uso en PHP ya que:

  - Muestra todo el contenido del config.php incluidas credenciales => databases.php y tokens.php

  - No incluye un "BackTrace"

  - Termina siendo demasiado largo para debuguear en la terminal.



[ HATEOAS ]

https://stackoverflow.com/questions/25172600/rest-what-exactly-is-meant-by-uniform-interface

- Digamos que definimos estas operaciones:  

    GET /cursos
    GET /cursos/{codigo}/unidades-didacticas

La primera nos retornará la información de todos los cursos y la segunda información sobre las unidades didácticas de un curso concreto. Un ejemplo de la segunda URL en la que se ha aplicado un valor a la parte variable sería:

    /cursos/introduccion/unidades-didacticas

  GET  /customers/5/orders

<-- lista de órdenes de compra para el cliente con id=5

o...

  GET /customers/1/orders/99/products

<-- productos de la orden 99 del cliente 1


https://programar.cloud/post/como-crear-un-api-rest/


- Implementar HATEOAS 

https://restfulapi.net/hateoas/
https://en.wikipedia.org/wiki/HATEOAS
https://programar.cloud/post/como-implementar-hateoas-en-tus-apis/


- Implementar HAL - Hypertext Application Language

http://stateless.co/hal_specification.html 
https://netflix.github.io/genie/docs/3.0.0/rest/
https://github.com/blongden/hal


HATEOAS Links

  self        the current search
  first       the first page for this search
  prev        the previous page for this search
  next        the next page for this search
  last        the last page for this search


prev, next no tienen aparentemente nada que ver con la paginación (?)

  "page" : {
    "size" : 64,
    "totalElements" : 1,
    "totalPages" : 1,
    "number" : 0
  }

https://netflix.github.io/genie/docs/3.0.0/rest/  


- Cómo se paginan los sub-recursos anidados en HATEOAS ? 

  Muestro los primeros N? últimos N? por qué criterio los ordeno? (order by)


- Implementar búsquedas complejas como en Magento (sino estuvieran cubiertas por HATEOAS)

https://devdocs.magento.com/guides/v2.4/rest/performing-searches.html#logical-or-search


- Proveer en el modelo un método para ejecutar raw queries como en Laravel o CI

https://fideloper.com/laravel-raw-queries

- Debería el módulo de autenticación incluir la parte de registro? en Laravel existe un RegisterController aunque el problema que le veo es que tendría que cambiar las rutas porque hoy el registro está en el AuthController en /v1/api/auth y entonces estaría en donde? la ventaja de tener un RegisterController sería hooks específicos como BeforeRegister y AfterRgister

- Incluir sub-Resources, ej:

/api/v1/users?include=rol

protected $availableIncludes = [
      'role'
];

public function includeRole(User $user)
{
      return $this->item($user->role, App::make(RoleTransformer::class));
}

When including a sub-resource, we can nest relations by using the a dot notation. Let’s say every role has a list of permissions stored in a separate table and we wanted to list users with their role and permissions. We can do it like this: 

  include=role.permissions.

Sometimes, we are required to include some necessary relations by default, like an address relation for example. We can do that by using the $defaultIncludes property inside the transformer:

protected $defaultIncludes = [
        'address'
];

The $availableIncludes property tells the transformer that we may need to include some extra data with the response. It will call the includeRole method if the include query parameter is requesting the user roles.


Los include parameters se pueden parametrizar (o sea pueden aceptar parámetros), ej:

  public function includeUsers(Role $role, ParamBag $paramBag)
  {
      list($orderCol, $orderBy) = $paramBag->get('order') ?: ['created_at', 'desc'];

      $users = $role->users()->orderBy($orderCol, $orderBy)->get();

      return $this->collection($users, App::make(UserTransformer::class));
  }


We can now order our included users list by passing parameters (/roles?include=users:order(name|asc)).


class UserTransformer extends TransformerAbstract
{
    protected $availableIncludes = [
        'roles'
    ];

    public function transform(User $user)
    {
        return [
            'name' => $user->name,
            'email' => $user->email
        ];
    }

    public function includeRoles(User $user)
    {
        if (!$user->role) {
            return null;
        }

        return $this->collection($user->roles, App::make(RoleTransformer::class));
    }
}

Leer en detalle:
https://www.sitepoint.com/php-fractal-make-your-apis-json-pretty-always/
https://fractal.thephpleague.com/transformers/


API Call	                              Action
----------------------------------------------------------------------------
GET /users	                            List all users 
GET /users?name={username}  	          Get user by username
GET /users/{id}	                        Get user by ID
GET /users/{id}/configurations	        Get all configurations for user        *
POST /users/{id}/configurations	        Create a new configuration for user    * 
DELETE /users/{id}/configurations/{id}	Delete configuration for user          *
PATCH /users/{id}/configuration/{id}	  Update configuration for user          * 


- Otra implementación interesante de inclusión de sub-recursos tipo-HATEOAS es esta:

Para Article:

  public function index()
  {
      $articles = QueryBuilder::for(Article::class)
          ->allowedIncludes(['author', 'comments'])
          ->allowedSorts(['created_at', 'title'])
          ->paginate();

      return new \App\Http\Resources\ArticleCollection($articles)
  }

  public function show($articleId)
  {
      $article = QueryBuilder::for(Article::class)
          ->allowedIncludes(['author', 'comments', 'comments.author'])
          ->allowedSorts(['created_at', 'title'])
          ->findOrFail($articleId);

      return new \App\Http\Resources\Article($article);
  }

<-- Se puede observar que index() y show() no son necesariamente iguales en cuanto a que includes aceptar siendo más permisivos en el show().

https://mattstauffer.com/json-api/eloquent-resources/


- Sacar ideas de Spatie Query Builder (librería de Laravel para APIs)

https://spatie.be/docs/laravel-query-builder/v3/advanced-usage/extending-query-builder

Entre otras cosas Spatie hace fácil "appending attributes" o sea propieades computadas similar a lo que hace Laravel Fractal con los transformers:

  class User extends Model
  {
      public function getFullnameAttribute()
      {
          return "{$this->firstname} {$this->lastname}";
      }
  }

https://spatie.be/docs/laravel-query-builder/v2/features/appending-attributes


- El paquete más completo para creación de APIs en Laravel parece ser laravel-json-api

https://github.com/cloudcreativity/laravel-json-api

Al visitar

  http://opinion-ate.test/api/v1/restaurants/1 

muestra  

  {
    "data": {
      "type": "restaurants",
      "id": "1",
      "attributes": {
        "name": "Sushi Place",
        "address": "123 Main Street",
        "createdAt": "2020-09-20T12:29:15.000000Z",
        "updatedAt": "2020-09-20T12:29:15.000000Z"
      },
      "relationships": {
        "dishes": {
          "links": {
            "self": "http://opinion-ate.test/api/v1/restaurants/1/relationships/dishes",
            "related": "http://opinion-ate.test/api/v1/restaurants/1/dishes"
          }
        }
      },
      "links": {
        "self": "http://opinion-ate.test/api/v1/restaurants/1"
      }
    }
  }


Al visitar

  http://opinion-ate.test/api/v1/restaurants/1/dishes

muestra

  {
    "data": [
      {
        "type": "dishes",
        "id": "1",
        "attributes": {
          "name": "Volcano Roll",
          "rating": 3,
          "createdAt": "2020-09-20T14:48:45.000000Z",
          "updatedAt": "2020-09-20T14:48:45.000000Z"
        },
        "relationships": {
          "restaurant": {
            "links": {
              "self": "http://opinion-ate.test/api/v1/dishes/1/relationships/restaurant",
              "related": "http://opinion-ate.test/api/v1/dishes/1/restaurant"
            }
          }
        },
        "links": {
          "self": "http://opinion-ate.test/api/v1/dishes/1"
        }
      },
      {
        "type": "dishes",
        "id": "2",
        "attributes": {
          "name": "Salmon Nigiri",
          "rating": 4,
          "createdAt": "2020-09-20T14:48:45.000000Z",
          "updatedAt": "2020-09-20T14:48:45.000000Z"
        },
        "relationships": {
          "restaurant": {
            "links": {
              "self": "http://opinion-ate.test/api/v1/dishes/2/relationships/restaurant",
              "related": "http://opinion-ate.test/api/v1/dishes/2/restaurant"
            }
          }
        },
        "links": {
          "self": "http://opinion-ate.test/api/v1/dishes/2"
        }
      }
    ]
  }

Es importante notar la estructura del JSON al *crear* un recurso con POST:

  {
    "data": {
      "type": "restaurants",
      "attributes": {
        "name": "Spaghetti Place",
        "address": "789 Third Street"
      }
    }
  }

Responde con "201 (created)" y el siguiente body 

  {
    "data": {
      "type": "restaurants",
      "id": "3",
      "attributes": {
        "name": "Spaghetti Place",
        "address": "789 Third Street",
        "createdAt": "2020-09-20T14:52:03.000000Z",
        "updatedAt": "2020-09-20T14:52:03.000000Z"
      },
      "relationships": {
        "dishes": {
          "links": {
            "self": "http://opinion-ate.test/api/v1/restaurants/3/relationships/dishes",
            "related": "http://opinion-ate.test/api/v1/restaurants/3/dishes"
          }
        }
      },
      "links": {
        "self": "http://opinion-ate.test/api/v1/restaurants/3"
      }
    }
  }


https://howtojsonapi.com/laravel.html


- Eventualmente implementar el filtrado de JSONAPI <----- no tiene mucho sentido excepto vaya a ofrecerse en el mercado la creacion de APIs con esta especificacion.

Notar que la sintaxis ?filter[attribute]=value es "legacy" y ya existe una nueva especificacion

https://www.jsonapi.net/usage/reading/filtering.html
https://jsonapi.org/examples/


- Muy buen resumen sobre distintos tipos de paquetes para generar APIs en Laravel:

https://speakerdeck.com/mattstauffer/getting-to-json-api-what-it-is-why-you-should-use-it-and-how-to-use-it-in-laravel?slide=110


- Response cumpliendo  PSR-7 / PSR-15 con Middlewares (eventualmente)

https://www.zend.com/blog/creating-basic-php-web-server-swoole

- Implementar en órden de prioridad:

  gRPC +++++
  REDIS  +++
  Swoole ++


- Revisar implementación HATEOAS de JAVA SPRING 

https://www.adictosaltrabajo.com/2013/12/02/spring-hateoas/


- Revisa como funcionan los Resource Controllers en Laravel 8 !!!

Parece ser que simplifica "armar" un HATEOAS


- Investigar a Hasura -un generador de GraphQL y API Rest Open Source- como competencia.

https://hasura.io/docs/latest/graphql/core/databases/postgres/queries/aggregation-queries.html


[ ACL ]

- Métodos como belongsTo() deberían poder ser re-definidos en un modelo permitiendo especificar indirectamente un campo como "idcliente" que *no* es el user_id 

	class RecoleccionModel extends Model
	{ 
		// ..
		protected $belongsTo = 'idcliente';

	Donde en Model,
	
	function belongsTo(){
		return $this->belongsTo;
	}


Lo que habría que hacer es decir que filtre por 'idcliente' a pesar de no ser un user_id pero instruir al modelo a que en vez de ir directo a comparar 'idcliente' con el 'user_id' que devuelve Auth, que convierta ese idclient, ej:

	idcliente = (SELECT cliente_id FROM api_keys WHERE user_id = 108)
	
Entonces una Query como:

	SELECT * FROM recoleccion WHERE idcliente = $user_id
	
se transformaría en

	SELECT * FROM recoleccion WHERE idcliente = (SELECT cliente_id FROM api_keys WHERE user_id = $user_id);

donde $user_id en el ApiController es $this->uid


QUIZAS,... la forma más sencilla de resolver sería crear un hook sobre el AuthController para setear un campo como 'idcliente' en base a una relacion que se pueda especificar (seguir desarrollando la idea) 

Si seteo como campo un 'idcliente' (pensando en la DB 'demo') la comparación se va a hacer contra $this->uid en el ApiController con el uid proviniente de Auth. De alguna forma toca especificar contra que comparar (en este caso contra el 'idcliente' del usuario autenticado)


- Agregar los métodos addDescription() y disabled(), enabled() que hace un update sobre la tabla roles.

  ->addRole('basic', 2)
  ->addDescription('Acceso muy básico')
  ->disabled()    <------------------------- queda des-habilitado el rol 
  ->addInherit('registered')
  ->addResourcePermissions('products', ['write'])
  

- De forma alternativa a addResourcePermissions() se debe poder usar addScope()

  ->addRole('guest', -1)
  ->addResourcePermissions('products', ['read_all'])
  ->addResourcePermissions('baz', ['read'])
  ->addResourcePermissions('bar', ['read', 'write'])

podría ser también,...

  //..
  ->addScope('products.read_all')
  ->addScope('emails.create')

y recibir un array

  //..
  ->addScope(['products.read_all', 'products.write])
  ...


- Permitir definir "alias" para los scopes:

  //..
  ->addScope('products.read_all')->alias('products:read.all')
  ->addScope('emails.create')->alias('emails:send')


Ejemplo de scopes:

https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/


- El método de autenticación tendría que ser via Middlewares o Traits

Ej:

  $app->add(new \Slim\Middleware\JwtAuthentication([
      "secure" => false,
      "secret" => getenv("JWT_SECRET"),
      "path" => "/",
      "passthrough" => ["/auth"],
      "algorithm" => ["HS256"],
      "logger" => $container['logger']
  ]));



[ MICROSERVICIOS ]

- Investigar microservicios. Buscar un Hello World. Cómo es la communicación entre microservicios?

Ver tuto:

https://www.youtube.com/watch?v=In6DBL0tq9c  !!!!!!!


- "API GATEWAY" se hace a través del "orquestador" y entre otras cosas se encarga del *logging* con lo cual habría que revisar la necesidad de tener un ACL y el AuthController ************* 


Elegir un API GATEWAY como por ejemplo Kong Gateway, KrakenD, Goku API Gateway, etc


https://www.axway.com/en/products/api-management/gateway
https://geekflare.com/api-gateway/


- Considerar usar Apache ZooKeeper/Kafka

La comunicación entre microservicios debería ser asincrónica para evitar acoplamiento:

"when an employee is deleted through the employee service, how are other services made aware of this deletion? Having the Employee Service call out synchronously to other services interested in employee's would be coupling. Asynchronous messaging provides a way to communicate in a decoupled fashion."

Tener "algo" (un broker) que reciba los mensajes de un "productor" a para los distintos microservicios subscriptos ("consumidores" del mensaje), los encole los sirva a los consumidores.

"Using a durable, resilient messaging system such as ZooKeeper/Kafka (or something equivalent) provides a way to accomplish this. Kafka has a persistent logging mechanism and will replay event messaging history to consumers if they are not available when a message event is raised by a publisher. This supports the independence of a Microservice platform with services moving in and out on an ad-hoc basis."

Cuando el evento se completa se debe enviar una senal hacia quien lo generó para que sepa que ya ha completado:

"Consumer services, such as the Project Service, need to know when an employee is deleted, so it can update a its Project's Resources, in other words, the employee assigned to a project no longer exists. The project service can listen for this Kakfa event topic published from the employee service and react accordingly."

Los mensajes no son empujados (push) del broker a los consumidores sino son jalados (pull) por los consumidores al broker.


  [ Productor ] --- push --->  [ Broker ] <--- pull --- [ Consumidor ]

  
  Producer (producer): news and data generation

  Agent (Broker): caching proxy

  Consumer (consumer): news and data consumers


Los mensajes persisten en el broker. Los mensajes no son borrados inmediatamente del broker sino hasta cierto tiempo después para dar tiempo de volver a ser consumidos en caso de que el consumidor falle. 

Kafka forma "clusters" donde cada cluster está especializado en mensajes de un determinado "topico":

"Kafka can run as a cluster on one or more servers that can span multiple data-centers. The Kafka cluster stores streams of records in categories called "topics". For instance, if I have data streams coming from Twitter (refer blog), you can name this topic as 'Tweets'"


https://dzone.com/articles/implementing-a-bounded-context
https://www.slideshare.net/rahuldausa/introduction-to-kafka-and-zookeeper/11
https://www.dataneb.com/post/apache-kafka-and-zookeeper-installation-sample-pub-sub-model
https://www.programering.com/a/MTOwkjNwATc.html
https://beyondcorner.com/learn-apache-kafka-tutorial/is-zookeeper-is-must-in-kafka/

Existe una extensión de PHP que permite usar Apache Kafka

https://blog.programster.org/using-php-with-apache-kafka
https://github.com/leocavalcante/kafka-phplayground


[ MIGRATIONS ]

- Migraciones *sin* el método down() <-- el estado anterior se obtiene del historial de migraciones.

- Poder especificar el campo en vez del nombre de la FK para su remoción

  dropForeignByColumnName() 
  dropFKByColumnName() --alias--


- Poder especificar la DB además de la tabla en Schema así:

  new Schema('db.table')

<-- obviamente que para que sea válido el nombre de la DB no puede repetirse entre distintas conexiones del archivo config.  


- Squashing Migrations

https://laravel.com/docs/8.x/migrations#squashing-migrations

- Sería genial poder hacer Squashing Migrations sobre toda una carpeta o sub-carpeta (módulo) y luego poder generar un Store Procedure basado en "migración aplastada" (unificada). Se podría llamar "combianación o unificación"

 
- Anonymous Migrations  

  return new class extends Migration
  {
      //
  };


- Mecanismo para evitar dejar fuera de línea una API Restful:

  - Si se desea agregar un campo / tabla a la DB.....

    - Primero se debería agregar en la DB 
    - Luego en el Schema

    <-- esto lo hace la migración

  - Si se desea borrar un campo / tabla

    - Primero debería desaparecer del Schema
    - Luego debe desaparecer de la DB

    <-- esto lo hace la migración

  - Si se desea renombrar un campo / tabla,...

    Como hacer ambas cosas al mismo tiempo y es imposible,...

    - En el Modelo indico que verifique si el campo existe con ese nombre en el Schema y de no existir, que intente con un nombre de campo alternativo. (Creo una "transición" en el Modelo)
    - Renombro el campo en la DB 	 
    - Habilito un Transformer para cubrir los queries sobre ese campo en caso de estar expuesto en la API. Obviamenre solo cubriría los GET pero podría habilitarse un mapeo de dos vías.
    - Elimino la "transición" que cree en el Modelo en el primer paso.


En general:

  - Un campo se puede agregar                             -- OK. No es problema

  - Un campo se puede eliminar                            -- Solo podría informarse que no E en el Schema

  - Un campo se puede renombrar
  
  - Una tabla se puede agregar                            -- OK. No es problema

  - Una tabla se puede eliminar                           -- Solo se podría informar que fue depredicada

  - Una tabla se puede renombrar
  
  - Un campo que no era nullable puede volverse nullable  -- OK. No es problema
  
  - Un campo que era nullable puede volverse no-nullable 
  
  - Un campo puede aumentar un rango                      -- OK. No es problema
  
  - Un campo puede disminuir su rango 
  
  - Un campo puede cambiar de tipo  


Se propone en el Schema donde vaya a haber cambios agregar una transición:

    // cambios críticos
    function getTransition(){
      return [
        // cambia de nombre
        'table_name' => 'bar_r',

        // renombrado de atributos
        // old -> new
        'attributes' => [
          'price' => 'cost',
          'email' => 'correo'
        ],

        // cambio de constante para PDO
        'attr_types'	=> [
          'price' => 'INT'
        ],

        // se vuelven no-nullables
        'not_nullable'		=> [
          'updated_at'
        ],

        // nuevas reglas
        'rules'	=> [
          'name' => ['max' => 45], // más restrictiva
          'email' => ['max' => 100]
        ]

      ];	

      // <-- también el id_name podría cambiar 
    }


https://blog.staffjoy.com/dont-migrate-databases-automatically-5039ab061365


- Dudas:

  - Un Service Provider en Laravel puede reemplazarse por otro? serviría para cambiar el proveedor de correo (SMTP) ?

  - Qué tipos de Service Provider hay? una librería también se distribuye como SP?

  - JSON:API es compatible con HATEOAS ?

  - JSON:API has agregative functions? parece ser que NO.


- NGINX

  location / {
      try_files $uri $uri/ /index.php?$query_string;
  }

https://laravel.com/docs/8.x/installation#nginx


- Debe haber orJoin() 

https://stackoverflow.com/a/36074909/980631
https://laravel.com/docs/5.8/queries#where-exists-clauses



- Leer :

https://docs.djangoproject.com/en/3.1/topics/migrations/
https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/


- Leer bien consejos para diseños de APIs !!!

https://blog.octo.com/en/design-a-rest-api/


- Evaluar usar PERCONA para hacer cambios de Schema (típicamente via migraciones) en producción sin bloquear lecturas ni escrituras.

https://www.percona.com/doc/percona-toolkit/2.1/pt-online-schema-change.html
https://federico-razzoli.com/advice-for-mysql-mariadb-live-migrations
https://medium.com/@gauraangkhurana/percona-pt-online-schema-change-performance-1def5866b43


- Si un registro fue bloqueado por un admin (alguien con permiso de lock) no debería siquiera poder verse en la papelera informando: "is_locked by an admin"

  GET http://az.lan/api/v1/trashCan/160?entity=products

{
    "data": {
    },
    "status_code": 403,
    "error": "Forbidden",
    "error_detail": "Locked by an admin"
}

Casos para un registro bloqueado:

  - Solo con el permiso "lock" se puede ver (ni siquiera con "read_all")
  - Solo con el permiso "lock" se puede ver (ni siquiera con "read_all") en la papelera
  - Solo con el permiso "lock" se puede listar (ni siquiera con "read_all")
  - Solo con el permiso "lock" se puede listar (ni siquiera con "read_all_trashcan"). Requiere lock + read_all_trashcan sino es propio.
  - Solo con el permiso "lock" puede recuperar de la papelera -- ok
  - Solo con el permiso "lock" puede borrar de la papelera -- ok


- Revisar si es posible acelerar las inserciones

https://dev.mysql.com/doc/refman/8.0/en/insert-optimization.html

- Ser concistente con los campos not_fillables: informo que son no fillables o simplemente hago un unset() silecioso? para belongs_to no estoy informando y para los demás campos si. 

  POST
  
  {
        "uuid": "0b42cfba-a343-4cf1-aaa7-e7ef7bf43171",
        "name": "BAR",
        "price": "600.50",
        "belongs_to": "168"
    }

- Crear alias entre

  ?orderBy=cost  (incorrecto)
y 
  ?orderBy[cost]=ASC (corecto)


- Make:

  - Permitir que los parámetros puedan ir en cualquier órden:

      make schema SuperAwesome -f 
      make schema -f SuperAwesome
      
      
  - Hacer que index() tome el lugar de any:

  En vez de 

      make any baz -s -m -a -f
      make any baz -samf

  sería,..

      make baz -samf
      make -samf baz 

    
  - Permitir agrupar parámetros en cualquier combinación posible:

      make -samf baz 
      make -safm baz
      make -fams baz 		
      etc
 

- Con ayuda del Router mover controllers (con algunas excepción) a otras ubicaciones.

- Descular porque un POST puede tardar 2000 ms y rara vez 60 ms que sería algo "normal" 

  t(FrontController) ?
  t(Request) ?
  t(ApiController) ?
  t(Auth->check()) ?
  t(ACL) ?
  t(Modelo) ?
  t(Response) ?  

Prueba: 

  GET /api/v1/users?fields=email                6 - 13 mili seg  

Valores hallados:

  Resolución de DNS                             0 - 30 mili seg (Windows)
  Bloqueo                                       0 - 30 mili seg (Windows)
  
  FrontController  (sin incluir response)       mediana: 3 mili seg 
  FrontController (completo)                    4 mili seg aprox

  Factory::request()                            0.5 - 1.5 mili seg

  AuthController instanciación + check()        1 - 3 mili seg  

  Acl (sin cachear)                             ---
  Acl (cacheado)                                --- seg 

  ApiController (incl. llamadas al modelo)      ---
  <-- sin incluir Auth ni Acl 

  DB::table('users')->setFetchMode('ASSOC')
  ->limit(10)->select(['email'])->get()         --- mili seg  (solo el CRUD)

  DB> SELECT email FROM users LIMIT 0,10;       --- - 1 mili seg aprox (en la terminal)

  Factory::response()                           --- - 1.5 mili seg

  Total PHP:                                    ---


Se ha concluido que en Windows los valores hallados de tiempo de respuesta son irreproducibles, totalmente fuera de escala.

-  Probar en Linux con el módulo de Apache PHP-FPM (idealmente en Linux) -> habilita opcode caching

  https://kinsta.com/es/blog/nginx-vs-apache/
  https://www.inmotionhosting.com/support/website/php-fpm-the-future-of-php-handling/
  https://www.quora.com/What-are-the-advantages-of-using-PHP-FPM-+-Nginx-over-Apache-and-mod_php
  http://www.orbitale.io/2017/11/11/apache-and-php-fpm-in-windows.html

  Hacer pruebas con el built-in web server
  
  https://www.php.net/manual/en/features.commandline.webserver.php


- Optimización de web servers 
https://www.sitepoint.com/apache-vs-nginx-performance-optimization-techniques/

- Usar RTAPI para testear tiempos de latencia:


https://www.nginx.com/blog/api-real-time-test-latency-responsiveness-nginx-rtapi-tool/

- Usar con conexiones http persistentes, por cierto ya es persistente? Si !

https://en.wikipedia.org/wiki/HTTP_persistent_connection
https://stackoverflow.com/questions/13332883/rest-web-service-and-keep-alive
https://www.a2hosting.com/kb/developer-corner/apache-web-server/using-keep-alive-connections-to-improve-performance
https://www.lob.com/blog/use-http-keep-alive
https://docs.apigee.com/api-platform/antipatterns/disable-persistent-connections

    Backend services should honor and handle HTTP persistent connection in accordance with HTTP 1.1 standards.
    Backend services should respond with a Connection:keep-alive header if they are able to handle persistent (keep alive) connections.
    Backend services should respond with a Connection:close header if they are unable to handle persistent connections.

- Ensayar con Apache y con Nginx buscando los mejores tiempos de respuesta.

- VirtualModel extends Model .... con schema on the fly. Esto sería útil para poder en pruebas unitarias hacer una migración para las tablas de prueba, hacer las pruebas sobre el modelo virtual y luego con otra migración regresar la DB al estado anterior.

- Para UUID hay algoritmos más eficientes que otros:


https://stackoverflow.com/questions/30461895/the-differences-between-int-and-uuid-in-mysql/30462400
https://www.percona.com/blog/2019/11/22/uuids-are-popular-but-bad-for-performance-lets-discuss/

https://github.com/ramsey/uuid
https://jolicode.com/blog/uuid-generation-in-php
https://mariadb.com/kb/en/guiduuid-performance/
https://www.php.net/manual/en/function.uniqid.php


- Considerar usar RocksDB en producción

https://mariadb.com/kb/en/myrocks/


- Al loguearse o renovar tokens o en otro endpoint poder ver 

{
	"roles": {
		...
		...
	}

	"permissions": {
		"sp": { ... },
		"tb": { 
			"foo": { 
				"read_all": false,
				"read": true,
				...
				"write": null
			}
		},
		"combined": {  <--- nuevo !
			"sp": {
				"read_all",
				"write_all",
				"read_all_collections",
				"write_all_collections",
				"transfer",
				"lock",
				"impersonate"
			},
			"tb": {
				"foo": { 
					"read_all": false, <-- por tb
					"read": true,  <-- por tb
					...
					"write_all": true  <-- por sp (sin sobreescribir)
				}				
			}
		}
	}
}

- Routing: seguir implementando siguiendo como referencia:
https://laravel.com/docs/9.x/routing

Además de expresiones regulares aceptar constantes como:

  String
  Int
  Long
  Double
  Float
  Boolean
  UUID

- Router:

Es necesario poder especificar el namespace del Controller porque podría no estar en la raiz del directorio app/controllers. Laravel provee varias formas:

  Route::get('/user', 'App\Http\Controllers\UserController@index']); 
  Route::get('/user', [App\Http\Controllers\UserController::class, 'index']);  

https://laravel.com/docs/8.x/upgrade#routing
https://medium.com/@litvinjuan/how-to-fix-target-class-does-not-exist-in-laravel-8-f9e28b79f8b4 

- Evaluar generar rutas como

/*
	 habilita una rutas como

	 /api/photos/{photo_id}/comments

*/	 
Route::resource('photos.comments', App\Http\Controllers\PhotoController::class);

- Listado de rutas como en Laravel
  
  php artisan route:list


- Serializar Route !!!!!!

- Re-escribir Response y .... evitar usar custom headers !

Adding custom headers or using a non-standard content-type forces the browser to issue a preflight ''OPTIONS'' request to determine if these are acceptable or not, and this effectively doubles the latency of fetching data.

Avoid custom HTTP headers, and use standard headers like Accept for content negotiated responses instead.

https://dzone.com/articles/solving-the-options-performance-issue-with-single


- Analizar que pasa con OPTIONS !!! no puede ser que demore tanto !

https://stitcher.io/blog/php-8-named-arguments
https://dev.to/jopacicdev/what-s-new-in-php-8-and-what-does-that-mean-4kdf

- Probar annotations (attributes) como en ASP.NET en vez de usar Traits

https://docs.microsoft.com/en-us/aspnet/core/security/authorization/simple?view=aspnetcore-5.0

- Probar PHP-Ds como alternativa a arrays en PHP 8 y verificar eficiencia 

https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd
https://github.com/php-ds/ext-ds
https://www.php.net/manual/en/book.ds.php


- Checkboxes de 3 estados donde uno sea null / undefined para mostrar los permisos sobre tb_permissions en caso de hacer un panel de control para estos menesteres

https://es.stackoverflow.com/a/41311/8826

- Es aconsejable agregar por defecto un campo "computed": [ campos que son computados ] al usar un transformer para que el cliente sepa que no puede hacer un POST o PUT incluyendo esos campos. Similarmente podría usarse un mecanismo de doble vía pero igual aclarar que campos fueron mapeados:  "maped": [ campos mapedos bi-direccionalmente ]

- Al mostrar user_roles el paginador muestra el total de registros aún cuando muestra solo uno:

{
    "data": [
        {
            "id": "179",
            "user_id": "455",
            "role_id": "3",
            "created_at": "2020-09-28 14:23:45",
            "updated_at": null
        }
    ],
    "status_code": 200,
    "error": "",
    "error_detail": "",
    "paginator": {
        "total": 117, <-- ok 
        "count": 1,
        "currentPage": 1, 
        "totalPages": 12,   <-- mal ?
        "pageSize": 10,
        "nextUrl": "http://az.lan/api/v1/user_roles?pageSize=10&page=2" <-- debería ser null
    }
}

- Reparar el sistema de "folders" luego de re-escribir el ApiController separando GET en 4 métodos 

- Si intento pasar un id repetido en un POST 

Ej para 'products'
  
  {
      "id": "126",
      "name": "Uvas ricas",
      "description": "Espectaculare",
      "size": "5L",
      "cost": "52"
  }

  {
    "status_code": 500,
    "error": "Error: creation of resource fails: SQLSTATE[23000]: Integrity constraint violation: 1062 Duplicate entry '126' for key 'PRIMARY'",
    "error_detail": "INSERT INTO products (id, name, description, size, cost, belongs_to, created_by, created_at) VALUES ('126', 'Uvas ricas', 'Espectaculare', '5L', '52', '90', '90', '2020-09-29 21:55:22')"
}

<-- usar el metodo unique() de la clase validator !!!!

- No debería poder ver todos los user_roles sino tengo permiso read_all de admin
    
- Insertar el rol "registered" con un hook o Midleware en cada cuenta registrada / creada para que nadie tenga en principio menos permisos que un "guest".  


- Al momento de "instalarse" mostrar una pantalla de presentación con la adevertencia de que debug=true, mediante comando poder crear un superadmin y servir un panel de admnistración de usuarios, roles y permisos como sucede con Django Rest framework 

https://medium.com/swlh/build-your-first-rest-api-with-django-rest-framework-e394e39a482c


- Dar soporte a Postgres y para hacer pruebas migrar la DB de prueba:

https://www.digitalocean.com/community/tutorials/how-to-migrate-mysql-database-to-postgres-using-pgloader


- Si un usuario no existe (fue borrado) pero su token está activo:

{
    "status_code": 500,
    "error": "Error: creation of resource fails: SQLSTATE[23000]: Integrity constraint violation: 1452 Cannot add or update a child row: a foreign key constraint fails (`az`.`products`, CONSTRAINT `products_ibfk_1` FOREIGN KEY (`belongs_to`) REFERENCES `users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE)",
    "error_detail": "INSERT INTO products (name, cost, belongs_to, created_by, created_at) VALUES ('JJJ', '199', '453', '453', '2020-09-28 14:19:25')"
}

- Cuando el tiempo de expiración restante de un access_token sea superior a 15 minutos chequear directamente desde base de datos: si el usuario está activo, tb_permissions y sp_permissions <-- con esto me evito tener que invalidar tokens de larga duración que pudieran haber sido usados en desarrollo.

- Usar Whoops y Monolog. La desventaja de mi exception handler es que no estoy guardando el stack de excepciones previas (con sus códigos de error, # de línea, etc) en caso de ser re-lanzadas.

https://github.com/filp/whoops
https://filp.github.io/whoops/
https://stackoverflow.com/questions/59472960/using-monolog-and-whoops  
https://scoutapm.com/blog/php-advanced-exceptions-tutorial

- Los booleans deben devolverse como true / false sin comillado e igualmente sin comillado los números <-- ver API de ClaroShop

- Usar Midlewares para evitar tener que hardcodear la clase Auth

https://phil.tech/2016/why-care-about-php-middleware/
http://esbenp.github.io/2015/07/31/implementing-before-after-middleware/
https://www.sourcefuse.com/blog/rest-api-best-practices/


- Desacoplar los distintos tipos (métodos) de Authorization !!!!!!  

  - No Auth
  - API Key
  - Bearer Token
  - Basic Auth
  - Digest Auth
  ...
  - OAuth 1.0
  - OAuth 2.0


- Corregir:

  - Si el password es un camo oculto revienta el OutputMutator:

    $this->registerOutputMutator('password', function($pass){ return '******'; } );

  - Ante un orderBy mal formateado en la url se produce un error muy feo

    http://az.lan/api/v1/products?orderBy=cost  <-- es incorrecto 

    <b>Fatal error</b>:  Uncaught TypeError: Argument 1 passed to simplerest\core\Model: :orderBy() must be of the type array, string given, called in C:\xampp\htdocs\az\app\core\api\v1\ApiController.php on line 688 and defined in C:\xampp\htdocs\az\app\core\Model.php: 352
    Stack trace:
    #0 C:\xampp\htdocs\az\app\core\api\v1\ApiController.php(688): simplerest\core\Model-&gt;orderBy('cost')
    #1 [internal function
    ]: simplerest\core\api\v1\ApiController-&gt;get()
    #2 C:\xampp\htdocs\az\app\core\FrontController.php(162): call_user_func_array(Array, Array)
    #3 C:\xampp\htdocs\az\public\index.php(11): simplerest\core\FrontController: :resolve()
    #4 {main
    }
      thrown in <b>C:\xampp\htdocs\az\app\core\Model.php</b> on line <b>352</b><br />

- Evitar escalamiento de privilegios !!!! 

	- Haciendo como "admin" un impersonate a "superadmin" por rol / uid
	- Haciendo como "admin" un impersonate de otro "admin" con menos restricciones por uid
	- Haciendo como "admin" un impersonate un "admin" por rol
	- Haciendo uso de 'grant' 
	- Manipulando las tablas de permisos
	
	<-- ningún usuario por admin que sea debe poder hacer un impersonate o por otro medio tener algún permiso que no tenga.
	

	Podría hacerse con un método restrictImpersonateTo($roles) al ACL.

	Otra opción sería hacer que un usuario pueda hacer un impersonate a otros usuarios cuyos roles sean iguales o interiores al rol padre de quien usa el impersonate. Para eso necesito armar el árbol de genealógico de roles.

    {
      "role": "superadmin"
    }

	o

    {
      "uid": "400"  <-- rol de un superadmin
    }


- Implementar? algo como InertiaJs o... el propio Inertia a SimpleRest

https://developers.origami-marketplace.com/inertia-laravel/


- Hacer algo similar a Faker 
https://github.com/fzaninotto/Faker
https://anchetawern.github.io/blog/2016/01/28/generating-fake-data-in-php-with-faker/


- Testear todo:

https://www.sisense.com/blog/rest-api-testing-strategy-what-exactly-should-you-test/
https://medium.com/@alicealdaine/top-10-api-testing-tools-rest-soap-services-5395cb03cfa9


- Pruebas de stress (JMeter,...)

https://stackoverflow.com/a/3093060/980631
https://chrome.google.com/webstore/detail/restful-stress/lljgneahfmgjmpglpbhmkangancgdgeb
https://medium.com/@chamikakasun/rest-api-load-testing-with-apache-jmeter-a4d25ea2b7b6
https://www.blazemeter.com/blog/rest-api-testing-how-to-do-it-right
https://developers.redhat.com/blog/2015/04/30/how-to-load-test-and-tune-performance-on-your-api/


- Posibilidad de serializar Modelos para incrementar performance

https://bezkoder.com/django-mongodb-crud-rest-framework/


https://bezkoder.com/django-mongodb-crud-rest-framework/

- Chequear phpFastCache

https://www.phpfastcache.com/

- Chequear que no sea posible el escalamiento de privilegios otorgando roles o permisos.

- Chequear el acceso a tablas como permissions, folder_permissions y other_folder_permissions

- Poseer el permiso 'grant' no debería habilitar a que quien lo sea lo otorgue a otros para lo cual haría falta el permiso 'super'.

- Id opcionalmente no autoincrementales por seguridad ! usar UUID(s) en su lugar
https://www.php.net/manual/en/function.uniqid.php <-- no 

- Migrar a PHP UNIT 9.0

https://laravelshift.com/upgrade-phpunit-9


- [ ACL ] Implementar eventos beforeCheckAccess y afterCheckAccess 
https://docs.phalcon.io/4.0/en/acl

- [ Security ] ¿Qué puedo hacer si hay credenciales comprometidas de un usuario?

Se podría invalidar el access token del usuario y lo bueno es que solo es necesario hacerlo durante el tiempo de duración de los acccess tokens. No hay problema con los refresh tokens ya que solo se utilizan para autenticación y no para autorización.

- [ Security ] ¿Qué puedo hacer para invalidar todos los tokens? ¿Es efectivo?

Aún sin implementar invalidación de tokens es posible expulsar a todos los usuarios y obligarlos a loguearse nuevamente cambiando las secret keys. Advertencia: si alguién se hubiera hecho con un access token podría haber cambiado la contraseña y si posee el refresh token puede volver a loguearse sin problemas. Obviamente si los tokens son de un usuario con elevados privilegios puede haber alterado permisos de mínima sobre registros y folders. 

- Arreglar la falta de normalización de los folders.

- Correos con formato. <-- ver como es en Laravel que usa un motor de plantillas.

- En app/libs/Factory.php está mal que en check() se haga referencia a una versión concreta de AuthController ya que está dentro de una librería que no está versionada.

- Generar algún tipo de alerta / warning si en producción el access token estuviera configurado para durar más de 1500 minutos  (poco más de un día). El generar tokens con vencimiento alto sería un problema enorme que obligaría a lidiar con unalista negra.

- Generar una alerta si aumenta el número de usuarios con el rol de "admin". 

- Soft-delete para archivos?

- Testear de nuevo los permisos que decoran los roles ! 


- Conceptos:

  - Los campos hidden deberían de serlo solo para otros usuarios excepto si mismo y un admin. Así se pueden proteger datos sensibles en una cuenta de usuario por ejemplo. Quizás se podría hacer si el campo hidden aceptara un callback que chequera !$owned && !$this->is_admin .... en todo caso el unset() se hace en toSql() dentro de Model.

  - Se podría aplicar un OutputMutator (o un transformer) sobre los campos password y los de una tarjeta de crédito conviertiendo estos en algo como "******" y "1050-xxxxxxxxxxx" respectivamente con lo cual se protege la información sin ocultarla completamente.

  - NO deben almacenarse ni roles ni permisos en los refresh_tokens por seguridad. Un refresh_token solo debe servir para ser autenticación y no para autorización.  -- OK

  - No sería necesario invalidar tokens. Con solo chequear si el usuario que presenta sus credenciales ya sea en el login o al renovar el token tiene autorización es suficiente. Como mucho se está dejando una ventana abierta de oportunidad para hacer daño lo que quede de vida al access_token.


- En /api/v1/img_resize/#id
  ?height=300
  ?width=500
  ?size=500x300
  &ellipse 

Sacar ideas de 
https://imageresizer.io/demo#resize
https://kraken.io/docs/image-resizing


- Investigar API de Claro que tiene hasta relaciones polimorficas mostradas como "atributos"
https://csapi.dev.claroshop.com/app/v1/product?page_size=5

Sino encuentra el ApiController:

{
    "errors": [
        {
            "message": "An error occurred during execution; please try again later.",
            "error": "error-controller-not-found",
            "exception": []
        }
    ]
}

Ante un fallo regresa información de la excepción:

{
    "errors": [
        {
            "message": "An error occurred during execution; please try again later.",
            "error": "error-exception",
            "exception": {
                "class": "Zend\\View\\Exception\\RuntimeException",
                "file": "/home/www/sites/app-api.dev.claroshop-services.io/vendor/zendframework/zend-view/src/Renderer/PhpRenderer.php",
                "line": 498,
                "message": "Zend\\View\\Renderer\\PhpRenderer::render: Unable to render template \"api-manager/v1/product/update\"; resolver could not resolve to a file"... Zend\\Mvc\\Application->run()\n#10 {main}"
            }
        }
    ]
}


En caso de éxito:

{
    "metadata": {
        "is_error": false,
        "http_status": "OK",
        "http_status_phrase": 200,
        "time": 1601043305,
        "message": "Products found"
    },
    "data": [
        {
            "id": 8308292,
            "title": "Crema Dental Complete 4 en 1 Crest",
            "store": {
                "id": 3496,
                "name": "Sanborns",
                "logo": "http://medios.plazavip.com/publicidad/5c3cd792844b8_sanbornssjpeg.jpg"
            },
            "images": [
                {
                    "order": 1,
                    "url": "https://www.claroshop.com/imagenes-sanborns-ii/1200/7506195100233.jpg",
                    "thumbnail": "https://www.claroshop.com/imagenes-sanborns-ii/1200/7506195100233.jpg"
                }
            ],
            "isfree": false,
            ...
            ...
        },          
        {
            "id": 8308291,
            ...
        }
    ],
    "pagination": {
        "total_items": 791695,
        "total_pages": 395848,
        "current_page": 1,
        "items_per_page": 2
    }
}

Algo interesante es que cuando se piden más registros por página del límite utiliza los campos is_error y message para indicar que no hubo error pero que no se pudo cumplir con el requisito de paginación mostrando solo lo una cantidad pre-determinada. 

{
    "metadata": {
        "is_error": false,
        "http_status": "OK",
        "http_status_phrase": 200,
        "time": 1601043488,
        "message": "Can't get more than 500 items!. I return only one :)"
    },
    "data": [
    ...
    ],
    "pagination": {
        "total_items": ....,
        "total_pages": ....,
        "current_page": 1,
        "items_per_page": 1
    }
}


<-- no está vacio ! debería incluir nombre_archivo : error  

- Incluir el nombre del proyecto en un salt sobre las secret keys para evitar que un token generado en un proyecto funcione en otro con las mismas secret keys. O sea aplicar una secret_key = fn(secret_key, nombre_proyecto)

- ¿ Cuándo se activa la cache para una petición HTTP? cuando es idempotente? por qué un GET no se cachea????

  <?php

  header('Cache-Control: max-age=2592000, public');

  sleep(1);
  echo json_encode(['msg'=> 'Some msg']); // +1 seg desp


Será que requiero de un proxy?  

https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching
https://www.mnot.net/cache_docs/
https://www.imperva.com/learn/performance/cache-control/
https://developers.google.com/web/fundamentals/performance/get-started/httpcaching-6
https://www.ibm.com/support/knowledgecenter/SSMAMS/com.ibm.mif.doc/gp_intfrmwk/rest_api/c_rest_get_caching.html
https://web.dev/http-cache/
https://tech.ebayinc.com/engineering/caching-http-post-requests-and-responses/
https://developer.cdn.mozilla.net/es/docs/Web/HTTP/Caching


- Implementar una forma sencilla de enviar correos, quizás como en Laravel

  use App\Mail\WelcomeMessage;
  use Illuminate\Support\Facades\Mail;

  dispatch(function () {
      Mail::to('taylor@laravel.com')->send(new WelcomeMessage);
  })->afterResponse();

<-- además utilizan Queues 

- Posiblemente enviar un correo de confirmación con el event hook onCreated() sobre Users.

- Enviar efectivamente correos -prioridad alta-

- Correos con formato. <-- ver como es en Laravel que usa un motor de plantillas.

- Debe ser posible *volver* a solicitar un correo con el enlace de confirmación de correo (obviamente se exige que el usuario esté registrado y haya entregado un access token válido)


- Solucionar que applyOutputMutators() requiere que que el fetch mode sea ASSOC. Esto hace que falle first() por ejemplo si el modo es otro.

- Considerar utlizar fastcgi_finish_request (requiere módulo FPM de Apache o similar para NGINX)

https://maslosoft.com/kb/how-to-continue-script-execution-in-background-in-php/


- Investigar sobre PDO::FETCH_LAZY que puede ahorrar mucha memoria
https://phpdelusions.net/pdo/fetch_modes
https://www.php.net/manual/en/pdostatement.fetch.php

- Leer sobre "long running jobs"

https://farazdagi.com/2014/rest-and-long-running-jobs/
https://stackoverflow.com/a/5044619/980631


- Modificar Request::header() para que obtenga de forma "case-insensitive"  headers de apache_request_headers()

Convertir a minúsculas como hace NodeJs.

https://stackoverflow.com/questions/5258977/are-http-headers-case-sensitive


- Leer sobre Eager Loading y el "n+1 problem" 

  Lazy-Loading -> lento
  Eager Loading -> rápido *

  (*) rápido en el sentido de que hace menos peticiones al motor pero consume más memoria.


"Eager loading is the process whereby a query for one type of entity also loads related entities as part of the query. Eager loading is achieved by the use of the Include method."

As I mentioned, ORMs “lazy” load associations. If you intend to use the associated model data you can trim that 101 query total to `2` queries using eager loading. You just need to tell the model what you need it to load eagerly.

Here’s an example from the Rails Active Record guide on using eager loading. As you can see, the concept is quite similar to Laravel’s eager loading concept.

# Rails
posts = Post.includes(:author).limit(100)

# Laravel
$posts = Post::with('author')->limit(100)->get();


Más
https://medium.com/@sdkcodes/laravel-eloquent-eager-loading-9596b15e8b5d
https://stackoverflow.com/questions/30231862/laravel-eloquent-has-with-wherehas-what-do-they-mean
https://laravel-news.com/eloquent-eager-loading


- Documentación como la de IBM

https://www.ibm.com/docs/en/iis/11.7?topic=content-running-referential-integrity-analysis


- Implementar Scopes como los de Eloquent de Laravel

https://codingdriver.com/how-to-use-scopes-in-laravel.html
https://medium.com/@janaksan_/using-scope-with-laravel-7c80dd6a2c3d
https://dev.to/bertheyman/the-magic-of-query-scopes-in-laravel-pfp
https://www.csrhymes.com/2019/12/29/using-eloquent-query-scopes.html
https://www.techalyst.com/posts/creating-and-using-query-scopes-with-laravel-5

- Chequear:

SI está en un folder y no es de mi propiedad ni soy el admin ni tengo permiso de escritura =>
NO debebería poder restaurar el registro.***


- Revisar estos enlaces:

https://github.com/DamianGonzalez27/Ivy/blob/master/Packages/Charger.php


- Documentar en Git como en 

https://github.com/robsonvn/laravel-couchdb

- Permitir setear nivel de compresion (1 a 6)

	ini_set('zlib.output_compression_level', 4);


- Subconsultas:

  > En el SELECT 
  > En el FROM -> funciona pero no acepta parámetros para la subconsulta y la forma de ver la consulta es mediante getLastPrecompiledQuery() ya que getQueryLoggetQueryLog() queda apuntando a la consulta "hija".
  > En el WHERE -> ok
  > En el HAVING 

  > UNION > funciona pero getQueryLog() no muestra los bindings de la subconsulta

Subconsultas en el SELECT puede implementarse con selectRaw() y en el HAVING con havingRaw()

Leer
https://www.tutorialesprogramacionya.com/sqlserverya/temarios/descripcion.php?inicio=75&cod=98&punto=92
https://docs.aws.amazon.com/es_es/redshift/latest/dg/r_Subquery_examples.html
https://www.mundoracle.com/subconsultas.html?Pg=sql_plsql_6.htm
  

- Considerar usar 'seek method' en vez de OFFSET como método de optimización de queries

Ejemplo (API de Facebook)

"paging": {
"cursors": {
  "after": "MTAxNTExOTQ1MjAwNzI5NDE=",
  "before": "NDMyNzQyODI3OTQw"
},
"previous": "https://graph.facebook.com/me/albums?limit=25&before=NDMyNzQyODI3OTQw"
"next": "https://graph.facebook.com/me/albums?limit=25&after=MTAxNTExOTQ1MjAwNzI5NDE="
}

https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/
https://blog.octo.com/design-a-rest-api/  # -> Paging
https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/

- Máscara de campos y valores accesibles por un usuario según su rol o... hidden y filled con roles 
a nivel de API

protected $hidden = [
    'password',
    'is_active' => ['guest', 'basic'] 
]

<-- seguramente puede hacerse con hooks sobre el modelo o con un transformer *

- Restricción de valores 

// UserRole
protected $constraint = [
                      'role_id' => [
                                      'gerente' => [1, 2, 3]
                                   ] 
];

<-- de los roles autorizados a acceder a UserRole el gerente posee una restricción que le permite solo crear o actualizar roles dentro del conjunto [1,2,3] no pudiendo así por ejemplo otorgar un permiso de admin (100)

Justificación: un caso de uso sería que un usuario con rol de gerente por ejemplo otorgar roles a usuarios pero nunca pueda ser un rol igual o superior al de gerente. La solución es restringir los valores que puede tomar el rol_id  

- No tiene sentido que un usuario pueda registrarse sin correo *excepto* venga de Facebook en cuyo caso me guardo el fb_id

- Arreglar lo que pasa si un usuario es borrado con soft delete (warnings)

- Posiblemente implementar "Seek pagination" como en Instagram

{
    ...
    "pagination": {
        "next_url": "https://api.instagram.com/v1/self/media/recent?access_token=fb2e77d.47a0479900504cb3ab4a1f626d174d2d&max_id=13872296",
        "next_max_id": "13872296"
    }
}

Más
https://nordicapis.com/everything-you-need-to-know-about-api-pagination/
https://www.moesif.com/blog/technical/api-design/REST-API-Design-Filtering-Sorting-and-Pagination/#


- Generar fallos intencionalmente en las URLs para ver si se puede mejorar el reporte de errores (hacerlos más comprensibles)

- Pruebas unitarias

ver 
https://api.akeneo.com/documentation/filter.html
https://www.ibm.com/support/knowledgecenter/fi/SS42VS_7.2.6/com.ibm.qradar.doc/c_rest_api_filtering.html
http://lj.platformatyourservice.com/wiki/REST_API:Filter_Expressions_in_REST_APIs
https://www.ibm.com/support/knowledgecenter/en/SS6KJL_8.6.4/FEB/ref_data_rest_api_list_filter.html


- 'OR' operator

  /api/people?q={{"$or": [{"name": "Jane"}, {"name": "Donald"}]}}

Más
https://restdb.io/docs/querying-with-the-api


- Implementar ORM basico y eficiente

En principio permitir cierta compatibiidad con las funcionalidades basicas de Laravel. Hacer un wrapper sobre el QueryBuilder

  . all() hace un get()

  Ej:

    $countries = Country::all();

  . with()
  
  with('t1.t2.t3.tN') hace auto-JOINs con t1, t2, t3,... tN en ese orden

  Ej:

    $companies = Company::with('city.country')->latest()->take(5)->get();

  . Traer registros relacionados

  Podria funcionar con las relaciones tal y como las define Laravel en las clases modelo y tambien usando los schemas correspondientes en cuyo caso el nombre del metodo coincidiria con el nombre "camelizado" de la tabla con la que se pide la relacion - si es 'users_roles' entonces seria con userRoles() -

  Ej:

    $cities = Country::cities();  

  . simplePaginate()

  If you only need to display simple "Next" and "Previous" links in your application's UI, you may use the simplePaginate method to perform a single, efficient query:

  Ej:

    $lists = $list->links()->orderBy('created_at', 'desc')->simplePaginate(4)

    $users = DB::table('users')->simplePaginate(15);  <----- funciona a nivel de QueryBuilder tambien

  En si lo que harian paginate() y simplePaginate() es cambiar de paginador o configurarlo de forma distinta. Tambien existe cursorPaginate() que funciona a nivel de SQL con cursores.

  Etc.

  Ver API de Larevel y GORM

  Associations (has one, has many, belongs to, many to many, *polymorphism*, single-table inheritance)
  Hooks (before/after create/save/update/delete/find)
  Eager loading with Preload, Joins
  Transactions, *Nested Transactions*, *Save Point*, *RollbackTo to Saved Point*  <---- implementar !
  Context, Prepared Statment Mode, *DryRun Mode*
  Batch Insert, FindInBatches, Find/Create with Map, CRUD with SQL Expr and Context Valuer
  SQL Builder, Upsert, Locking, Optimizer/Index/Comment Hints, Named Argument, SubQuery
  Composite Primary Key, Indexes, Constraints
  Auto Migrations
  *Logger*
  Extendable, flexible plugin API: Database Resolver (multiple databases, read/write splitting) / Prometheus…
  *Every feature comes with tests*

https://gorm.io/
https://developpaper.com/basic-usage-of-golang-gorm-operation-mysql-and-gorm/
https://www.prisma.io/dataguide/types/relational/comparing-sql-query-builders-and-orms
https://stackoverflow.com/questions/398134/what-are-the-advantages-of-using-an-orm

"Imaginate Amazon. El desarrollador que está laburando en el algoritmo que ordena los productos según los intereses del comprador no le importa conocer los detalles del WHERE que filtra a los vendedores que hacen envíos al país del comprador. 

El tipo necesita una lista de objetos availableProduct que se encargue de atar la sesión del visitante, los perfiles de los vendedores, la configuración de cada producto, el código que convierte el precio a la moneda preferida del visitante y todo lo demás.

Podés armar una clase availableProduct y escribir los WHEREs vos... O podés usar un ORM y crear un availableProduct que es un product, atado a un vendedor, atado a una condición regional de venta, etcétera. El ORM te ahorra trabajo y te estandariza la sintaxis"

"las bases de datos no SQL más populares hoy en día son documentales (como Mongo). Un ORM es un mapeador de relaciones. Las bases de datos documentales no están diseñadas para trazar relaciones entre los objetos (eso se hace en una capa superior). El equivalente a un ORM documental es un ODM."

- Dar soporte a MongoDB 

https://docs.mongodb.com/manual/tutorial/query-documents/

Sobre Mongo leer:

https://www.tutorialspoint.com/mongodb/index.htm
https://university.mongodb.com/courses/M001/about?offering_id=M001%2F2020_November_3
https://www.sitepoint.com/building-simple-blog-app-mongodb-php/
https://www.roytuts.com/rest-api-crud-example-in-php-and-mongodb/


- Considerar HERENCIA MULTIPLE en el ACL 


- Implementar X-Rate-Limit-Limit, X-Rate-Limit-Remaining y X-Rate-Limit-Reset

En vez de tener que especificar para cada endpoint lo que se usa aquí es una "API GATEWAY" <<<<

https://github.com/dingo/api/wiki/Rate-Limiting
https://developer.twitter.com/en/docs/basics/rate-limiting
https://stackoverflow.com/questions/16022624/examples-of-http-api-rate-limiting-http-response-headers
https://apisyouwonthate.com/blog/what-is-api-rate-limiting-all-about
https://developer.github.com/v3/rate_limit/
https://developer.vimeo.com/guidelines/rate-limiting
https://support.exactonline.com/community/s/knowledge-base#All-All-HNO-Simulation-gen-apilimits
https://stackoverflow.com/a/49611482/980631


Ejemplos:

Name	                Limits
------------------------------------------------
Google Calendar API	  1,000,000 queries per day
Google Docs API	      Free of charge
Gmail API	            1,000,000,000 quota units per day
Sheets API	          500 requests per 100 seconds per project, 100 requests per 100 seconds per user


- Posibilidad de aplicar "restricciones" sobre una API

Ej:
    - None can be used for testing purposes only.
    - HTTP referrers can be used for API clients which run on a web browser.
    - IP addresses can be used to limit API key access to some particular IP addresses.
    - Android apps is there for Android applications. 
    - iOS apps can restrict API calls to specific iOS bundles. 


https://cloud.google.com/docs/authentication/api-keys


- Swagger for Documentation

Swagger is a widely-used tool to document REST APIs that provides a way to explore the use of a specific API, therefore allowing developers to understand the underlying semantic behavior. It’s a declarative way of adding documentation using annotations which further generates a JSON describing APIs and their usage.

- Al generar los modelos..... opcionalmente modificar la tabla correspondiente agregando el campo `deleted_at` y `belongs_to` 

- Eventualmente agregar más comandos a Make como Laravel

https://quickadminpanel.com/blog/list-of-21-artisan-make-commands-with-parameters/


- Ofrecer la forma de filtrado compatible con JSON:API

GET /employees?filter[state]=internal&filter[title]=senior
GET /employees?filter[id]=1,2

equivalente a...

GET /employees?state=internal&title=senior
GET /employees?id=1,2


- JSON:API resuelve elegantemente el tema de los objetos anidados:

JSON:API has quite a lot of interesting features. "Compound documents" allow servers to respond to requests with related resources, which mimics a lot of GraphQL’s functionality without making for an overly complex system. Clients can leverage this to traverse the internal resource layout and grab more complex information.

https://jsonapi.org/format/#document-compound-documents

Clients can also request very specific information by using "sparse fieldsets", wherein the client only requests data from a specific resource name and a specific set of desired fields. This makes for much more efficient calls than is otherwise seen in other relational API standards. JSON:API also allows for optionality in features: you can turn anything on or off, with the client being the ultimate source of acceptance or denial.

https://jsonapi.org/format/#fetching-sparse-fieldsets

Más
https://nordicapis.com/the-benefits-of-using-json-api/
https://nordicapis.com/how-does-jsonapi-compare-to-rest-and-graphql/


- Ejemplo de paginación HAL


    "_links": {
        "self": {
            "href": "http://example.org/api/user?page=3"
        },
        "first": {
            "href": "http://example.org/api/user"
        },
        "prev": {
            "href": "http://example.org/api/user?page=2"
        },
        "next": {
            "href": "http://example.org/api/user?page=4"
        },
        "last": {
            "href": "http://example.org/api/user?page=133"
        }
    }
    "count": 3,
    "total": 498,
    "_embedded": {
        "users": [
            {
                "_links": {
                    "self": {
                        "href": "http://example.org/api/user/mwop"
                    }
                },
                "id": "mwop",
                "name": "Matthew Weier O'Phinney"
            },
            {
                "_links": {
                    "self": {
                        "href": "http://example.org/api/user/mac_nibblet"
                    }
                },
                "id": "mac_nibblet",
                "name": "Antoine Hedgecock"
            },
            {
                "_links": {
                    "self": {
                        "href": "http://example.org/api/user/spiffyjr"
                    }
                },
                "id": "spiffyjr",
                "name": "Kyle Spraggs"
            }
        ]
    }
}


https://nordicapis.com/optimizing-the-api-response-package/


- JSON:API vs GraphQL vs ...


https://stackoverflow.com/questions/44711161/what-is-the-difference-between-odata-jsonapi-graphql
https://aimeos.org/tips/graphql-vs-jsonapi-for-ecommerce/


- Seeders,...

En az\docs\etc dejé unas capturas de pantalla pero se puede ver como funciona sobre el final de este vídeo:
https://www.youtube.com/watch?v=w6u8amnFhSo


- Sanitización a nivel de urls, FILTER_SANITIZE_URL

https://www.w3schools.com/php/php_filter.asp

Cómo carajos previene un XSS hacer lo siguiente?

  /* prevent XSS. */
  $_GET   = filter_input_array(INPUT_GET, FILTER_SANITIZE_STRING);
  $_POST  = filter_input_array(INPUT_POST, FILTER_SANITIZE_STRING);

https://stackoverflow.com/a/4861211

Leer cuidadosamente:

https://www.php.net/manual/en/function.filter-input-array.php


- Sanitización a nivel de base de datos

- Upload de archivos, devolver:

{
  "id": "20301",
  "url": "http://simplerest.lan/api/attachments/:user_id/xxxxxxxxxxxxxxxx.png"   
}


- Aceptar distintos "Accept" y "Content-type" y responder acordemente

- Sacar ideas de: https://dev.targetprocess.com/docs/custom-calculations

* "additional details embedded"
* Overriding the HTTP method
* Rate limiting (quotas)  => status code 429 si se alcanza el límite.
* Errors

- Securitizar almacenamiento de tokens -- en cookies?

https://stormpath.com/blog/where-to-store-your-jwts-cookies-vs-html5-web-storage
https://medium.com/@jcbaey/authentication-in-spa-reactjs-and-vuejs-the-right-way-e4a9ac5cd9a3
https://dev.to/rdegges/please-stop-using-local-storage-1i04


- Donde almacenar con seguridad Refresh tokens !!!!!

https://stackoverflow.com/questions/48690373/where-to-store-refresh-token-safely
https://github.com/IdentityServer/IdentityServer3/issues/2039

- Custom Actions (Nested Resources)


- Leer atentamente
https://blog.octo.com/design-a-rest-api/
https://docs.microsoft.com/es-es/azure/architecture/best-practices/api-design  !!!
https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api
https://phauer.com/2015/restful-api-design-best-practices/
https://www.paradigmadigital.com/dev/oauth-2-0-equilibrio-y-usabilidad-en-la-securizacion-de-apis/
https://medium.com/crowdbotics/how-to-write-an-api-in-3-lines-of-code-with-django-rest-framework-59b0971edfa4
https://hackernoon.com/designing-rest-api-with-open-api-specification-oas-v2-0-v3-0-using-swagger-11dd4ef8cea6


- Ver de implementar OpenAPI (Swagger)

https://idratherbewriting.com/learnapidoc/pubapis_openapi_tutorial_overview.html
https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md


- Revisar especificación OpenID donde además de Access Token (y Refresh Token) hay un "ID Token" que sirve para obtener información del usuario (mas no de los resources). 

https://auth0.com/blog/id-token-access-token-what-is-the-difference/
https://developer.okta.com/blog/2017/07/25/oidc-primer-part-1


- Revisar 

https://stackoverflow.com/questions/36514344/how-to-make-use-of-session-in-rest-api/36515140

- Incluir displayName y username en el Payload:

{
    "iss": "stackoverflow",
    "sub": "joe",
    "aud": ["all"],
    "iat": 1300819370,
    "exp": 1300819380,
    "jti": "3F2504E0-4F89-11D3-9A0C-0305E82C3301"
    "context": {
        "user": {
            "key": "joe",
            "displayName": "Joe Smith"
        },
        "roles":["admin","finaluser"]
    }
}

iss (issuer): identifies the principal that issued the JWT.
sub (subject): identifies the principal that is the subject of the JWT. Must be unique
aud (audience): identifies the recipients that the JWT is intended for (array of strings/uri)
exp (expiration time): identifies the expiration time (UTC Unix) after which you must no longer accept this token. It should be after the issued-at time.
nbf(not before): identifies the UTC Unix time before which the JWT must not be accepted
iat (issued at): identifies the UTC Unix time at which the JWT was issued
jti (JWT ID): provides a unique identifier for the JWT.

https://stackoverflow.com/questions/38897514/what-to-store-in-a-jwt

- Faltaría agregar "Cache-Control" (header)

- Leer sobre Flat-file databases

https://en.wikipedia.org/wiki/Flat-file_database


- Si se hacer un GET (all) y no hay nada para retornar (cero registros), se debe devolver 204 y no 200 (o 404)

https://stackoverflow.com/questions/34312023/http-get-request-status-204-vs-404#:~:text=While%20a%20204%20seems%20better,signal%20a%20%22successful%20absence%22.


- Evaluar usar un motor de plantillas como Twing entre otras cosas para el envio de emails

https://en.wikipedia.org/wiki/Twig_(template_engine)


- Dar soporte al manejo de Views (view tables) ya que son readonly y no pueden tratarse como cualquier modelo.

https://stackoverflow.com/questions/36287364/how-to-create-the-migrations-for-database-views-using-php-artisan-in-laravel
https://programmingarehard.com/2013/11/10/eloquent_and_views.html/


- Dar soporte a tablas temporarias ! 

https://alexvanderbist.com/2020/advanced-laravel-migrations-using-temporary-tables/


- Implementar algo como "Unit of Work" de Doctrine 2 para minimizar las cantidad de consultas:

https://culttt.com/2014/07/07/doctrine-2-different-eloquent/

https://stackoverflow.com/questions/7940854/is-unit-of-work-and-repository-patterns-very-useful-for-big-projects

https://github.com/cristianV0117/ddd-hexagonal-architecture-laravel


- Por qué generar las migraciones con métodos encadenados y no simplemente SQL como en Doctrine ?

/**
 * Auto-generated Migration: Please modify to your needs!
 */
  final class Version20180601193057 extends AbstractMigration
  {
      public function getDescription() : string
      {
          return 'This is my example migration.';
      }

      public function up(Schema $schema) : void
      {
          $this->addSql('CREATE TABLE example_table (id INT AUTO_INCREMENT NOT NULL, title VARCHAR(255) DEFAULT NULL, PRIMARY KEY(id))');
      }

      public function down(Schema $schema) : void
      {
          $this->addSql('DROP TABLE example_table');
      }
  }


<--- RTA: porque ese SQL solo sería válido para un MOTOR de base de datos en particular ! aunque es más rápido y tiene sentido cuando estás haciendo un CREATE TABLE IF NOT EXISTS

https://www.doctrine-project.org/projects/doctrine-migrations/en/3.0/reference/managing-migrations.html


- Implementar comando diff para migraciones como en Doctrine

php com migrations diff

"The command generates a migration by comparing project current database to mapping information. Doctrine provides this command to generate migration classes by changing entity mappings instead of manually adding modifications to migration class."

http://www.laraveldoctrine.org/docs/current/migrations/diff


<-- 

"In Laravel we use migration files to create the database schema. In Doctrine 2, the database is automatically created to reflect the meta data in the entity annotations."


Doctrine can generate blank migrations for you to modify or it can generate functional migrations for you by comparing the current state of your database schema to your mapping information.

By default the Doctrine Migrations command line tool will only add the "diff" command if the ORM is present. Without the ORM, you'll have to add the diff command to your console application manually, passing in your schema provider implementation to the diff command's constructor   

<-- esto pasa porque solo con el ORM se mantiene un Schema (como annotations) 


- También es buena idea que en vez de incluir la descripción como parte del archivo, ésta este dentro de la clase: 

  public function getDescription() : string
  {
      return 'This is my example migration.';
  }

- El versionado en el nombre de la clase de migraciones es muy deseable: 

  final class Version20180601193057 extends AbstractMigration {
    //...
  }

- El rollback además del --step=N sea --to=version

https://www.doctrine-project.org/projects/doctrine-migrations/en/3.0/reference/managing-migrations.html


- Comando para des-marcar / marcar una migración para "batch" en la tabla de migraciones:

https://www.doctrine-project.org/projects/doctrine-migrations/en/3.0/reference/managing-migrations.html#managing-the-version-table


- En Schema agregar
  
  ->addSql()
  ->abortIf()
  ->addColumn()

- Eventos before / after en las migraciones 


- Hacer "inserciones en Bulk" usando colecciones. 

Se puede crear una "colección" con POST (ya implementado) y luego de recibir los IDs ... hacer PUTs sobre cada uno.

https://stackoverflow.com/questions/17292656/how-to-design-a-restful-api-for-bulk-inserts-and-updates


- Service Providers - desde el directorio del paquete deben poder cargarse el config, vistas, traducciones,... y hasta migraciones:

  /**
     * Merge the given configuration with the existing configuration.
     *
     * @param  string  $path
     * @param  string  $key
     * @return void
     */
    protected function mergeConfigFrom($path, $key)
    {
        $config = $this->app['config']->get($key, []);

        $this->app['config']->set($key, array_merge(require $path, $config));
    }

  ...

  /**
     * Register a database migration path.
     *
     * @param  array|string  $paths
     * @return void
     */
    protected function loadMigrationsFrom($paths)
    {
        $this->app->afterResolving('migrator', function ($migrator) use ($paths) {
            foreach ((array) $paths as $path) {
                $migrator->path($path);
            }
        });
    }

<-- extracto de ServiceProvider.php de Laravel

"Within the boot() method, you may do whatever you like: register event listeners, include a routes file, register filters, or anything else you can imagine.

The register() method should only be used for, you guessed it, registering services with the container”


- Implementar un "vendor:publish" para los ServiceProviders !!!!!!!!!!

"The vendor folder should not be under revision control as such, it will be overwritten every time you deploy your solution. You use vendor:publish to copy configurable items to your application code base such that any changes you make will not keep being lost."

"vendor:publish command used to copy few configuration file in your application from vendor package file.Like you are using a package where need to create a table on database and need to store few demo data.That time your packages will keep database schema and seeding and when you run vendor:publish those schema and seeding file will copy in your application.After that you just run php artisan migrate and php artisan db:seed"

https://laracasts.com/discuss/channels/laravel/why-do-we-do-a-php-artisan-vendorpublish

Ejemplo practico:

Al ejecutar

  artisan vendor:publish

Permite seleccionar un paquete. La otra opcion seria 

  artisan {nombre-paquete}:publish

y.... lo que hace es copiar el archivo de configuracion dentro de /config e igualmente las vistas dentro de /views/vendor/{nombre-paquete} ... etc

Copying file [vendor/infyomlabs/laravel-generator/config/laravel_generator.php] to [config/laravel_generator.php] ........................... DONE

Copying directory [vendor/infyomlabs/laravel-generator/views] to [resources/views/vendor/laravel-generator] ................................. DONE

A su vez ... el archivo config que se copia (el nombre parece ser arbitrario o conicidir con el nombre del paquete),... contiene informacion *crucial* como:

- Paths hacia los modelos, controladores, migraiciones, views, seeders,...

- Namespaces correspondientes a los modelos, controladores,....

- Prefijos

- Opciones

- Campos especiales de los modelos


Ej:


<?php

return [

    /*
    |--------------------------------------------------------------------------
    | Paths
    |--------------------------------------------------------------------------
    |
    */

    'path' => [

        'migration'         => database_path('migrations/'),

        'model'             => app_path('Models/'),

        'datatables'        => app_path('DataTables/'),

        'livewire_tables'   => app_path('Http/Livewire/'),

        'repository'        => app_path('Repositories/'),

        'routes'            => base_path('routes/web.php'),

        'api_routes'        => base_path('routes/api.php'),

        'request'           => app_path('Http/Requests/'),

        'api_request'       => app_path('Http/Requests/API/'),

        'controller'        => app_path('Http/Controllers/'),

        'api_controller'    => app_path('Http/Controllers/API/'),

        'api_resource'      => app_path('Http/Resources/'),

        'schema_files'      => resource_path('model_schemas/'),

        'seeder'            => database_path('seeders/'),

        'database_seeder'   => database_path('seeders/DatabaseSeeder.php'),

        'factory'           => database_path('factories/'),

        'view_provider'     => app_path('Providers/ViewServiceProvider.php'),

        'tests'             => base_path('tests/'),

        'repository_test'   => base_path('tests/Repositories/'),

        'api_test'          => base_path('tests/APIs/'),

        'views'             => resource_path('views/'),

        'menu_file'         => resource_path('views/layouts/menu.blade.php'),
    ],

    /*
    |--------------------------------------------------------------------------
    | Namespaces
    |--------------------------------------------------------------------------
    |
    */

    'namespace' => [

        'model'             => 'App\Models',

        'datatables'        => 'App\DataTables',

        'livewire_tables'   => 'App\Http\Livewire',

        'repository'        => 'App\Repositories',

        'controller'        => 'App\Http\Controllers',

        'api_controller'    => 'App\Http\Controllers\API',

        'api_resource'      => 'App\Http\Resources',

        'request'           => 'App\Http\Requests',

        'api_request'       => 'App\Http\Requests\API',

        'seeder'            => 'Database\Seeders',

        'factory'           => 'Database\Factories',

        'tests'             => 'Tests',

        'repository_test'   => 'Tests\Repositories',

        'api_test'          => 'Tests\APIs',
    ],

    /*
    |--------------------------------------------------------------------------
    | Templates
    |--------------------------------------------------------------------------
    |
    */

    'templates' => 'adminlte-templates',

    /*
    |--------------------------------------------------------------------------
    | Model extend class
    |--------------------------------------------------------------------------
    |
    */

    'model_extend_class' => 'Illuminate\Database\Eloquent\Model',

    /*
    |--------------------------------------------------------------------------
    | API routes prefix & version
    |--------------------------------------------------------------------------
    |
    */

    'api_prefix'  => 'api',

    /*
    |--------------------------------------------------------------------------
    | Options
    |--------------------------------------------------------------------------
    |
    */

    'options' => [

        'soft_delete' => false,

        'save_schema_file' => true,

        'localized' => false,

        'repository_pattern' => true,

        'resources' => false,

        'factory' => false,

        'seeder' => false,

        'swagger' => false, // generate swagger for your APIs

        'tests' => false, // generate test cases for your APIs

        'excluded_fields' => ['id'], // Array of columns that doesn't required while creating module
    ],

    /*
    |--------------------------------------------------------------------------
    | Prefixes
    |--------------------------------------------------------------------------
    |
    */

    'prefixes' => [

        'route' => '',  // e.g. admin or admin.shipping or admin.shipping.logistics

        'namespace' => '',  // e.g. Admin or Admin\Shipping or Admin\Shipping\Logistics

        'view' => '',  // e.g. admin or admin/shipping or admin/shipping/logistics
    ],

    /*
    |--------------------------------------------------------------------------
    | Table Types
    |
    | Possible Options: blade, datatables, livewire
    |--------------------------------------------------------------------------
    |
    */

    'tables' => 'blade',

    /*
    |--------------------------------------------------------------------------
    | Timestamp Fields
    |--------------------------------------------------------------------------
    |
    */

    'timestamps' => [

        'enabled'       => true,

        'created_at'    => 'created_at',

        'updated_at'    => 'updated_at',

        'deleted_at'    => 'deleted_at',
    ],

    /*
    |--------------------------------------------------------------------------
    | Specify custom doctrine mappings as per your need
    |--------------------------------------------------------------------------
    |
    */

    'from_table' => [

        'doctrine_mappings' => [],
    ],

];





- Leer sobre Packages

https://laravel.com/docs/8.x/packages


- Investigar integraciones como la de PayPal via Serivice Provider

https://www.codechief.org/article/how-to-integrate-paypal-payment-gateway-in-laravel
https://www.positronx.io/how-to-integrate-paypal-payment-gateway-in-laravel/
https://github.com/srmklive/laravel-paypal
https://github.com/srmklive/laravel-paypal-demo


- Crear ServiceProvider para envio de Mails 

https://culttt.com/2015/10/12/sending-template-emails-through-mandrill-in-laravel/

Los templares a enviar podrían ser como los de Blade:

  @component('mail::message')
  # Introduction

  Thank you {{ $order->name }}.  We just shipped {{ $order->item_count }} items.

  @component('mail::button', ['url' => ''])
  Track Order #{{ $order->id }}
  @endcomponent

  Thanks,
  {{ config('app.name') }}
  @endcomponent

<-- el punto es que deben poder recibirse variables al menos.


- Crear un script de instalación o un procedimiento como este:

  Installation

  First simply clone this repo by using following command:

    git clone https://xxxxxxxxxxxxxxxx.git [your-directory]

  Now navigate to the directory you cloned the repo into and run the following command

  composer install

      Create .env file

  mv .env.example .env

  Set application key

    php artisan key:generate

  Set your database credentials.

  Migrate the databases:

    php artisan migrate


- Implementar API de Mailchimp, Mailgun o MailTrap como Servicio o Library

https://www.mailgun.com/
https://mailtrap.io/signin


- Probar var_dumper de Symfony

https://symfony.com/doc/current/components/var_dumper.html


[ MODELO ] 

  - Agregar updateOrInsert()

  https://laravel.com/docs/8.x/queries#update-or-insert  

  - Agregar soporte para JSON

  - Soporte para "subquery Joins" mediante joinSub, leftJoinSub, and rightJoinSub

  https://laravel.com/docs/8.x/queries#subquery-joins

  - Agregar soporte para "OR JOINs" 

  https://laravel.com/docs/8.x/queries#advanced-join-clauses
  https://stackoverflow.com/questions/11702294/mysql-inner-join-with-or-condition

  - Seguir el estandar SQL-92 o SQL-89 para garantizar compatibiidad entre distintos motores. Cuál me conviene usar?

  https://en.wikipedia.org/wiki/SQL-92

  - Leer

  https://en.wikipedia.org/wiki/Join_(SQL)    


- Implementar features y dar cierta compatibiidad con CodeIgniter

https://codeigniter.com/user_guide/models/model.html
https://codeigniter.com/user_guide/models/entities.html
https://codeigniter.com/user_guide/database/index.html


- Aplicar buenas prácticas

https://github.com/ryanmcdermott/clean-code-javascript
https://github.com/thangchung/clean-code-dotnet


- Para hacer benchmarks de ejecución de código PHP, probar:

https://github.com/phpbench/


- Métricas con telegraf, influxdb y grafana

https://aleson-itc.com/en/free-monitoring-using-influxdb-telegraf-and-grafana/


- Prevenir correctamente SQL injections

"SQL injection must exploit a security vulnerability in an application's software, for example, when user input is either incorrectly filtered for string literal escape characters embedded in SQL statements or user input is not strongly typed and unexpectedly executed." =>

	- Validar o castear todo tipo de parámetros (paginación, entidad, etc) no solo los de las queries tanto en las urls como por GET o incluso en los headers

  - No admitir que un parámetro sea '/ OR$/' o '/^OR /' o '/ UNION$/' o '/^UNION /'
	
	- Validar idealmente todos los parámetros de controladores


https://en.wikipedia.org/wiki/SQL_injection#In_popular_culture
https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide
https://www.paladion.net/blogs/are-stored-procedures-safe-against-sql-injection


- Autorización "basica" (user y pass) vs API Key vs OAuth

    Basic   is very easy to implement, but would you give your Google account password to someone? (You shouldn't!)

    API Key is as easy to implement, both for the API provider and the developer, but have you ever tried to ask a non-techie to give you their API key?
    
    OAuth (especially OAuth2.0) is the best user experience. Your user clicks on a button and that's it. But for developers, implementing an OAuth dance can be tricky!


  Using API keys is a way to authenticate an application accessing the API, without referencing an actual user. The app adds the key to each API request, and the API can use the key to identify the application and authorize the request. The key can then be used to perform things like rate limiting, statistics, and similar actions.

  Google Cloud accepts the API key with a query parameter like this:

  curl -X POST https://language.googleapis.com/v1/documents:analyzeEntities?key=API_KEY

  Cloudflare requires the API key to be sent in a custom header:

  curl https://api.cloudflare.com/client/v4/zones/cd7d0123e301230df9514d \
      -H "Content-Type:application/json" \
      -H "X-Auth-Key:1234567893feefc5f0q5000bfo0c38d90bbeb" \
      -H "X-Auth-Email:example@example.com" 

 The API key only identifies the application, not the user of the application. It’s often difficult to keep the key a secret. For server-to-server communication, it’s possible to hide the key using TLS and restrict the access to only be used in backend scenarios.      

https://blog.bearer.sh/the-three-most-common-api-authentication-methods/  
https://nordicapis.com/the-difference-between-http-auth-api-keys-and-oauth/  


- Cuando usar OAuth !

You need OAuth only when you want to enable a user of your service to allow a third-party client application to access his/her data hosted in your service without revealing his/her credentials (ID & password) to the application.


- Investigar Laravel Sanctum

https://laravel.com/docs/8.x/sanctum


[ OAuth ]

- Intro:

https://www.digitalocean.com/community/tutorials/una-introduccion-a-oauth-2-es?fbclid=IwAR1HP35GfAhLHcSWzA1bSwpvXsoOMQpTOq53vSkvahs4nakyYp5kMUXlKf0

- Estudiar Laravel Passport que está construido sobre league/oauth2-server y permite armar OAuth 

league/oauth2-server is a standards compliant implementation of an OAuth 2.0 authorization server written in PHP which makes working with OAuth 2.0 trivial. You can easily configure an OAuth 2.0 server to protect your API with access tokens, or allow clients to request new access tokens and refresh them.

Out of the box it supports the following grants:

    Authorization code grant
    Implicit grant
    Client credentials grant
    Resource owner password credentials grant
    Refresh grant


https://laravel.com/docs/8.x/passport
https://github.com/thephpleague/oauth2-server
https://oauth2.thephpleague.com/


[ MODELO ]

- Hay un *bug importante* por el que un usuario "logueado" puede ver menos registros que un "guest".

  GET /v1/products

  eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTYwNTkxOTE2MiwiZXhwIjoxNjE0OTE5MTYyLCJpcCI6IjEyNy4wLjAuMSIsInVpZCI6MTEzLCJyb2xlcyI6WyJyZWd1bGFyIl0sInBlcm1pc3Npb25zIjp7InRiIjpbXSwic3AiOltdfSwiaW1wZXJzb25hdGVkX2J5IjoiNDAwIiwiYWN0aXZlIjoxfQ.acTZs9VbSQcnIsdiiFS_Kd6hGppibYZG3-2kn5CGYJY

  SELECT * FROM products WHERE (belongs_to = 113) AND deleted_at IS NULL LIMIT 0, 10;

  => 1 registro

mientras que ...

  GET /v1/products (guest)

  SELECT * FROM products WHERE (belongs_to IS NULL) AND deleted_at IS NULL LIMIT 0, 10;

  => 2 registros

La razón  es que en el primer caso (para el usuario logueado) en el ApiController debió armarse la consulta así:

  SELECT * FROM products WHERE (belongs_to = 113 OR belongs_to IS NULL) AND deleted_at IS NULL LIMIT 0, 10;

  => 3 registros

La incocistencia se presenta solo si belongs_to es nullable y hay registros con belongs_to NULL.


PARCHE: no tener belongs_to como "nullable".

SOLUCION: re-escribir ApiController de forma que genere una estructura de datos (cacheable) y luego aplicar todo al modelo. La estructura de datos podría ser un array asociativo o un "árbol" para evitar re-ordenamientos y poder re-usar prepared statements. Se deben incluir operadores, groupBy, having, etc. *NO* hacer nada hasta no tener pruebas unitarias actualizadas para el ApiController y hacerlo bajo otra versión de Api para poder comparar: /api/v1.1 



- Cursores

https://www.geeksforgeeks.org/what-is-cursor-in-sql/
https://docs.microsoft.com/en-us/sql/ado/guide/data/understanding-cursors-and-locks?view=sql-server-ver15
https://www.sqlshack.com/understanding-cursors-replacing-joins-sql-server/
https://www.sqlshack.com/using-sql-server-cursors-advantages-and-disadvantages/
https://dev.mysql.com/doc/refman/8.0/en/cursors.html
https://www.brainbell.com/tutorials/MySQL/Working_With_Cursors.htm

- Paginación con cursores

https://stackoverflow.com/questions/55744926/offset-pagination-vs-cursor-pagination
https://dev.to/jackmarchant/offset-and-cursor-pagination-explained-b89
https://dev.to/rahul_ramfort/understanding-offset-vs-cursor-based-pagination-1582


- Calling stored procedures in PHP (PDO)

https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.swg.im.dbclient.php.doc/doc/t0023502.html


- Implementar forma adecuada de hacer calls a Store Procedures:

https://stackoverflow.com/questions/34497063/how-to-execute-stored-procedure-from-laravel
https://medium.com/@smayzes/stored-procedures-in-laravel-60e7cb255fc9

Requiere uso de cursores? hacer un binding con PARAM_el_que_sea | PARAM_LOB ?

"Stored procedures may return result sets, i.e., the results of a SELECT statement. Such result sets can be processed using cursors, by other stored procedures, by associating a result-set locator, or by applications. 

Stored procedures may also contain declared variables for processing data and cursors that allow it to loop through multiple rows in a table."


- Implementar un método en el modelo que conviera el Query Builder en un generador de Store Procedures.

Básicamente se construiría un SP a partir de una consulta preparada !


- Store Procedures => seguridad

https://www.sqlbook.com/sql-server/why-use-stored-procedures/


- Laravel, leer:

https://pineco.de/route-bind-contracts-in-laravel/


[ SEGURIDAD ]

- Para generar las "secret keys" del config hacer algo como WordPress que ofrece una url (que podría ser local) donde se generan.

/**#@+
 * Authentication Unique Keys and Salts.
 *
 * Change these to different unique phrases!
 * You can generate these using the {@link https://api.wordpress.org/secret-key/1.1/salt/ WordPress.org secret-key service}
 * You can change these at any point in time to invalidate all existing cookies. This will force all users to have to log in again.
 *
 * @since 2.6.0
 */
define( 'AUTH_KEY',         'put your unique phrase here' );
define( 'SECURE_AUTH_KEY',  'put your unique phrase here' );
define( 'LOGGED_IN_KEY',    'put your unique phrase here' );
define( 'NONCE_KEY',        'put your unique phrase here' );
define( 'AUTH_SALT',        'put your unique phrase here' );
define( 'SECURE_AUTH_SALT', 'put your unique phrase here' );
define( 'LOGGED_IN_SALT',   'put your unique phrase here' );
define( 'NONCE_SALT',       'put your unique phrase here' );


[ API KEY autentication ]

API Key Generation

Since the API key itself is an identity by which to identify the application or the user, it needs to be unique, random and non-guessable. API keys that are generated must also use Alphanumeric and special characters. An example of such an API key is zaCELgL.0imfnc8mVLWwsAawjYr4Rx-Af50DDqtlx.

We don’t need to know the raw API key, but just need to validate that the key is correct. So instead of storing the key in plain text (bad) or encrypting it, we should *store it as a hashed value* within our database. *******

Since we don’t store the original API key, we can show it only once to the user, at the time of creation. *

Another problem is how users identify the right API key in your console if they need to edit or revoke it. This can be solved by adding a prefix to the API key. Notice in the picture above the first 7 characters (that’s our prefix), separated by the dot.

Adjuntar un prefijo para poder identificar distintas API keys para distintas aplicaciones o con distintos scopes:

	API key {prefix}.{hash_of_whole_api_key}.
	
Don’t give the API Key all the power

One common mistake that API key providers make is providing one key to access everything, since it’s easy to manage. Don’t do that. Assume that a user just needs to read an email, and generates an API key. But that key now has full access to other services, including deleting records in the database.

The right approach is to allow the end users to properly restrict API Key access and choose specific actions that an API key can carry out. This can be done by providing scopes, where each scope represents a specific permission.

For example,

    if you need an API key to just send emails, you can generate an API key with the scope as “email.send”
	
https://www.freecodecamp.org/news/best-practices-for-building-api-keys-97c26eabfea9/	
	

- Observación: 
  
  En la tabla `users` se tomó la desición de hacer que el `password` sea nullable para poder permitir registro a través de la API de Google / Facebook *pero* entonces al hacer un registro "normal" el campo email debe ser obligatorio (estar presente en el schema y no ser nullable) o se podría dar el caso de crear un usuario y sin password y no poder recuperarlo:

  {
    "username": "vik455",
    "email": NULL,  
    "password": NULL
    "roles": ["regular"]
  }        

OK:
  username  valor
  email     valor
  password  valor 

OK:
  username  NULL
  email     valor
  password  valor  

OK:
  username  valor
  email     NULL 
  password  valor

<-- el problema es que no es posible recuperar la cuenta sino es con contacto con el admin.

NO!
  username  valor
  email     NULL 
  password  NULL

<-- no es posible loguearse ni "restablecer" un password cuando la cuenta esté pendiente de activación porque se requiere correo para recuperar cuenta (excepto sea via SMS)

De mínima exigir que:  `username` y `email` no puedan ser nullables simultaneamente !
En alguna parte del proceso de registro sugerir completar el email aunque sea nullable en la tabla


- Mejorar enlaces generados en rememberme para hacerlos menos verbosos usando el router

  http://az.lan/api/v1/auth/change_pass_by_link/eyJ0eXAiOiJKV1QiLC.....

podría ser

  http://az.lan/change-pass/eyJ0eXAiOiJKV1QiLC....


- Al llamar intentar cambiar el password siguiendo el enlance /api/v1/auth/change_pass_by_link debe darse por verificado el correo. Si el correo se verifica y es estado del usuario es NULL debe pasar a "activo"

    http://az.lan/api/v1/auth/change_pass_by_link/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTYwNTc5NTgyOSwiZXhwIjoxNjA2NDAwNjI5LCJpcCI6IjEyNy4wLjAuMSIsInVpZCI6NDczfQ.ni-DzwD0XF86jGwt9LtexGqiHnISiM61nWtYrWWvcm8/1606400629


- Por qué el resultado de funciones agregativas no está casteado?

    php com dumb avg

    array (
      'prom' => '218.3333',   <-- debe ser 218.3333 (float)
    )


<-- parece ser que es porque PDO maneja float como String


- Actualmente (corregir) el ApiController solo está tomando en cuenta los "permisos especiales" del archivo acl.php y no toma en cuenta los especificados en user_sp_permissions


- Mediante "API reversa" y si se usa MySQL en el servidor y MySQL / SQLite localmente implementar algo similar a PouchDB / CouchDB.

PouchDB (local)  -----------> [ API REST ] [ CouchDB (server) ]

"CouchDB uses a REST API for interfacing with the database, which means we use HTTP methods like PUT, POST and DELETE to interact with the database."


https://www.tutorialspoint.com/pouchdb/pouchdb_synchronization.htm
https://www.joshmorony.com/offline-syncing-in-ionic-2-with-pouchdb-couchdb/
https://www.ibm.com/developerworks/library/os-php-couchdb/index.html

Obviamente si el schema en el servidor cambia, debe cambiar localmente => ejecutar migraciones local.


- API Gateways

https://www.youtube.com/watch?v=vHQqQBYJtLI


[ MODELADO DE APIs y DOCUMANTADORES ]

- Posiblemente generar documentación en lenguaje RAML (RESTful API Modeling Language)

https://raml.org/developers/design-your-api
https://www.youtube.com/watch?v=vaWvVilZtZw
https://github.com/raml-org/raml-spec
https://github.com/mulesoft/api-designer


- Generar documentación de una tabla foo con Swagger API (OAS)   !!!!!!!

  https://www.youtube.com/watch?v=Kziad2G-dkE
  https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/data-driven-crud-microservice


- Ver documentador de PostmanGenerator

https://www.PostmanGenerator.com/api-documentation-tool/?


- Implementar mecanismo para invalidar access tokens:

  - Para invalidar (revocar) todos los tokens => cambiar la secret key correspondiente
  - Para invalidar el token de un usuario => para ese user_id, denegar el acceso por el tiempo de duración de ese token. Ej: 15 min <-- obviamente cachearlo.

  /api/auth/revoke <-- en el body pasar el access_token a revocar o el user_id correspondiente 


- Implementar "token exechange": en vez de identificar a un usuario que proviene de la API de Facebook o Google por su email (que podría no ser compartido)... usar el refres_token obtenido de esas APIs como user_id :) 


- Conceptos de microservicios

		- Romper todas las FKs hacia `users`
		- Implementar un "global delete" o su alternativa via WebHook para emular el DELETE ON CASCADE
    - Se necesita un "orquestador" con funciones como:

      - Router (hacia microservices) ***
      - Balanceador de carga
      - Cache
      ...

Duda: cada MS debe implementar REDIS?      


[ REDIS ]

- Performance de SQL (cached) vs No-SQL (cached) 

	Si son pocas queries => da "igual"
	Sino => No-SQL gana por "colas largas": no es posible cachear todas las consultas posibles y obviamente las más complejas sucederán con menor probabilidad individualmente con lo que inclusive podría no tener sentido cachearlas/

- Optimización de consultas:

	- Siempre es mejor cachear lo más upstream que se pueda: request > ORM / ODM > motor de DB

	- Es buena idea invertirle algo de tiempo de procesamiento a ordenar las queries:

		- ?A&B <>  ?B&A 
		- WHERE A AND B <> WHERE B AND A

		Se podría hacer un ordenamiento alfabético de queries y cuando halla un IN() hacer el ordenamiento también.	  

- Podría implementar REDIS a varios niveles pero sin repetir:

  Si cacheo una query ?A&B no tiene sentido cachear la misma a nivel de SQL: "WHERE A AND B". A nivel de SQL solo debería cachear aquello que pasó de largo por la caché de urls

  Duda importante: para REDIS [A,B] == [B,A] ? porque de serlo... solo necesito enviar un explode() de los parámetros de la url.

<-- RTA: usar un HASHMAP !

Ej: 

  products
  ?cost[gt]=30
  &groupBy=size
  &fields=size
  &props=avg(cost) as avg
  &having=avg(cost)>=150

podría ingresarse como

  HSET apiUrl entity "products" filter "cost[gt]=30" groupBy "size" fields "size" props "avg(cost) as avg" having "avg(cost)>=150"

<--- podrá filter se otro objeto ?

Niveles posibles de cache con REDIS:

  - Url tipo /api/v1/products?cost[gt]=30&oderBy[size]=ASC&page=2&pageSize=10
    para nivel de permisos "compatible" (ACL)

  - Query Builder

    get ([[
      'cost', 30, '>='
    ]]), ['size', 'ASC'], 10, 20)

  - SQL (sentencia preparada)

    SELECT * FROM products WHERE cost >= ? ORDER BY ? ? LIMIT ?, ?;

  - SQL compilado

    SELECT * FROM products WHERE cost >= 30 ORDER BY size ASC LIMIT 10, 20;


- Cachear los parámetros de una función() es mucho más fácil que cachear una serie de métodos encadenados: particularmente importante para el Query Builder.

  get(array $fields = null, array $order = null, int $limit = NULL, int $offset = null, $pristine = false)

El tema es que habría que tener cuidado:

  - de chequear que estén registrados los mismos mutators y transformers.
  - de chequear estén aplicados los mismos joins, havings, etc
  - de seguir ejecutando los event hooks.


Instalación de REDIS:

https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-redis-on-ubuntu-18-04


Actualizar a REDIS 6.06 o superior <-- ya está la 6.09

https://askubuntu.com/questions/1244058/how-to-install-redis-server-6-0-1-in-ubuntu-20-04


- Redis con API Rest ? SI ! implementar serializacion del ACL y caché para todo incluidas las consultas 

https://docs.phalcon.io/4.0/en/acl#serialization

- Redis para el Validator ! si se repite la misma regla + dato o los arrays de datos o datos + reglas, entregar la misma respuesta. Igualmente el validador parece ser bastante eficiente. Usar versión compilada y cacheada de las reglas. 

- Ver como Laravel interfacea con REDIS

https://laravel.com/docs/8.x/redis


[ EMAILS]

- Usar mock para probar los correos. Recomendación utilizar los famosos Mocking ya que con esta herramienta puedes emular el envío de correos entre muchas cosas como las colas (queue), simular la subida de un archivo al servidor

https://medium.com/@vivekdhumal/how-to-test-mail-notifications-in-laravel-345528917494



[ PRUEBAS UNITARIAS ]

- Actualizar y mantener actualizadas !

- Pruebas unitarias sobre event hooks (modelos, api, etc)

- Comparar resultados del impersonate (roles, permisos) con loguearse con token del usuario o api key.

- Comparar resultados (no queries) de ejecución con el Query Builder de Laravel 


[ REFACTORING ]

- Response: simplificar la forma de generar códigos de error http (ver notas). Hay estandar? PSR?

- Response: cambiar los campos para entregar m;as información incluyendo un código de error único que identifique la clase, método y la línea donde se produjo el error (ver notas)

- Midlewares. Hay estadar? PSR?

- Extender el router y simplificar el FrontController

- Acl más eficiente (ver notas) y con otros métodos.

- Simplificar el ApiController 
  
  _ Separar el método get() en show() y list()

  _ Aplicar nuevas funciones del Acl

  _ Implementar folders pero como "extensión" via api hooks en Traits que... debe ser un "package".

  _ Solo dos hooks por método: before y after.

  _ Implementar filter[] en las urls y simplificar la forma de manejar todo generando una estructura de datos que no rompa los hook.


[ CORS ]

- Verificar realmente esté OK

- CORS debe no ser por defecto sino habilitarse via Midleware *****

- Deben poder configurarse los "trusted domains" (array) en vez de "*"


[ SSL ]

- Es posible tenerlo funcionando localmente? dockerizado?


[ Redes sociales ]

- Reparar logins

--

- En vez de devolver solo un mensaje de error y un status, ofrecer tambien un código de error

// 400 Bad Request
{
  "errors": [
    {
      "status": 400,
      "detail": "Invalid state. Valid values are 'internal' or 'external'",
      "code": 352,
      "links": {
        "about": "http://www.domain.com/rest/errorcode/352"
      }
    }
  ]
}

Más 
https://jsonapi.org/format/#error-objects
https://phauer.com/2015/restful-api-design-best-practices/


- Investigar API de Claro que tiene hasta relaciones polimorficas mostradas como "atributos"
https://csapi.dev.claroshop.com/app/v1/product?page_size=5

Sino encuentra el ApiController:

{
    "errors": [
        {
            "message": "An error occurred during execution; please try again later.",
            "error": "error-controller-not-found",
            "exception": []
        }
    ]
}

Ante un fallo regresa información de la excepción:

{
    "errors": [
        {
            "message": "An error occurred during execution; please try again later.",
            "error": "error-exception",
            "exception": {
                "class": "Zend\\View\\Exception\\RuntimeException",
                "file": "/home/www/sites/app-api.dev.claroshop-services.io/vendor/zendframework/zend-view/src/Renderer/PhpRenderer.php",
                "line": 498,
                "message": "Zend\\View\\Renderer\\PhpRenderer::render: Unable to render template \"api-manager/v1/product/update\"; resolver could not resolve to a file"... Zend\\Mvc\\Application->run()\n#10 {main}"
            }
        }
    ]
}


En caso de éxito:

{
    "metadata": {
        "is_error": false,
        "http_status": "OK",
        "http_status_phrase": 200,
        "time": 1601043305,
        "message": "Products found"
    },
    "data": [
        {
            "id": 8308292,
            "title": "Crema Dental Complete 4 en 1 Crest",
            "store": {
                "id": 3496,
                "name": "Sanborns",
                "logo": "http://medios.plazavip.com/publicidad/5c3cd792844b8_sanbornssjpeg.jpg"
            },
            "images": [
                {
                    "order": 1,
                    "url": "https://www.claroshop.com/imagenes-sanborns-ii/1200/7506195100233.jpg",
                    "thumbnail": "https://www.claroshop.com/imagenes-sanborns-ii/1200/7506195100233.jpg"
                }
            ],
            "isfree": false,
            ...
            ...
        },          
        {
            "id": 8308291,
            ...
        }
    ],
    "pagination": {
        "total_items": 791695,
        "total_pages": 395848,
        "current_page": 1,
        "items_per_page": 2
    }
}

Algo interesante es que cuando se piden más registros por página del límite utiliza los campos is_error y message para indicar que no hubo error pero que no se pudo cumplir con el requisito de paginación mostrando solo lo una cantidad pre-determinada. 

{
    "metadata": {
        "is_error": false,
        "http_status": "OK",
        "http_status_phrase": 200,
        "time": 1601043488,
        "message": "Can't get more than 500 items!. I return only one :)"
    },
    "data": [
    ...
    ],
    "pagination": {
        "total_items": ....,
        "total_pages": ....,
        "current_page": 1,
        "items_per_page": 1
    }
}


[ COMPATIBILIDAD ]

- Asegurar compatibilidad con:

  - Compatibilidad ante distinto diseno de tablas (convenciones):

    - Tablas sin PK
    - Tablas con PK múltiple  --ok
    - Distintos campos para:

      created_at  --ok 
      created_by --ok 
      ...
      is_active 
      is_locked
      users.id 
      users.email
      users.username
      users.password

    - Tabla `users` podría tener otro nombre.  -- ok

    - Tabla `users` (con el nombre que sea) podría estar en una DB distinta al resto de las tablas.

  - MariaDB / MySQL -- ok

  - Nginx / Apache -- ok

  - PHP versiones 

- Preparar contenedor docker con Nginx.


[ VERSIONADO ]

  {major_ver}.{minor_ver}.{patch}

  - Bump the value of X when breaking the existing API.
  - Bump the value of Y when implementing new features in a backward-compatible way.
  - Bump the value of Z when fixing bugs.

  Incluir release date:

  Ej: 2.4.1 - release date 20200926

  Incluir Changelog

    2.4.1  

    Release Date - 26 November 2020

    - Fixed....
    - Updated ....

       

Más 
https://semver.org/
https://www.geeksforgeeks.org/introduction-semantic-versioning/
https://www.elegantthemes.com/blog/wordpress/semantic-versioning
https://en.wikipedia.org/wiki/Software_release_life_cycle


[ MODELO ]

- JOINs a base de datos disntintas? JOIN db2.products ?


Si se puede:

  SELECT <...>
  FROM A.table1 t1 JOIN B.table2 t2 ON t2.column2 = t1.column1;

https://stackoverflow.com/a/5698396


- Aceptar que created_at, deleted_at y updated_at (con el nombre que sea) pueda ser también TIMESTAMP


[ API ]

- Agregar ?filter de JSON:API en principio manteniendo compatibilidad con su no-uso

  GET /comments?filter[post]=1 HTTP/1.1

Multiple filter values can be combined in a comma-separated list. For example:

  GET /comments?filter[post]=1,2 HTTP/1.1

Furthermore, multiple filters can be applied to a single request:

  GET /comments?filter[post]=1,2&filter[author]=12 HTTP/1.1


https://jsonapi.org/recommendations
https://laravel-json-api.readthedocs.io/en/latest/fetching/filtering/


- Incluir links:

https://jsonapi.org/recommendations/#including-links


- Hacer que el "method override" sea también por headers:

X-HTTP-Method-Override

https://jsonapi.org/recommendations/#patchless-clients


- Hacer que el lenguaje se pueda elegir via headers !

- Leer todas las recommendations

https://jsonapi.org/recommendations


- Implementar opcionalmente "cursor pagination"

https://jsonapi.org/profiles/ethanresnick/cursor-pagination/
https://jsonapi.org/format/#fetching-pagination

- Meditar si implementar la forma de crear recursos como en JSON:API

POST /photos HTTP/1.1
Content-Type: application/vnd.api+json
Accept: application/vnd.api+json

{
  "data": {  <--- "data" es obligatorio
    "type": "photos",  
    "attributes": {
      "title": "Ember Hamster",
      "src": "http://example.com/images/productivity.png"
    },
    "relationships": { <-------------------------- incluye sub-recursos. 
      "photographer": {  
        "data": { 
          "id": "9",
          "type": "people" 
        }  
      }
    }
  }
}

<-- parece pensado para trabajar con un ORM.

https://jsonapi.org/format/#crud  !!!!!!!!!


- Implementar withoutWrapping para poder quitar la key "data" como requerimiento en la respuesta y en los requests.

https://laravel.su/docs/8.x/eloquent-resources  !


- Securitizar el tenant haciendo de mínima un hash sobre el id de conexión. <-- evitar que sea solo elegir que conexión usar (sin control alguno)

- Sería ideal que los modelos pudieran cargarse desde "cualquier ubicación" lo que permitiría:

  - Que cada versión de API tenga su namespace de modelos
  - Que distintos endpoints usen distintas DBs

- Exteneder Response y Request y colocar las clases extendidas donde se puedan versionar.  


- JSON + CORS vs. JSONP (hack) vs. JSON (sin CORS) usando al server que sirve la API como proxy para acceder a otras APIs

JSON + CORS
JSONP (es un back)
JSON usando a la API como proxy server
XML + CORS
XML usando a la API como proxy server


https://www.youtube.com/watch?v=stvCHJZq5MI
https://www.web-technology-experts-notes.in/2013/07/difference-between-json-and-jsonp.html
https://woocommerce.github.io/woocommerce-rest-api-docs/#requirements
https://www.programmableweb.com/news/258-jsonp-apis-get-your-json-response-anywhere/2011/10/07


- Cookies "Http Only"

  - Se guardan en el browser y JS no puede leerlo en browsers modernos.
  
  "An http-only cookie cannot be accessed by client-side APIs, such as JavaScript. This restriction eliminates the threat of cookie theft via cross-site scripting (XSS). However, the cookie remains vulnerable to cross-site tracing (XST) and cross-site request forgery (CSRF) attacks. A cookie is given this characteristic by adding the HttpOnly flag to the cookie." 

  https://en.wikipedia.org/wiki/HTTP_cookie#HttpOnly_cookie

  - Desde PHP se puede marcar con el flag "http-only" de varias formas:

    - Desde el web server: en Apache via .htaccess

      <IfModule php5_module>
        php_flag session.cookie_httponly on
      </IfModule>

    - Via php.ini

      session.cookie_httponly=On
      session.cookie_secure=On

    - Antes de session_start() seteando session.cookie_httponly en 1

      ini_set('session.cookie_httponly',1);
      ini_set('session.use_only_cookies',1);
      ini_set('session.cookie_secure', 1);

    - Con setcookie() pasando true en el 7mo parámetro

      //None HttpOnly cookie:
      setcookie("abc", "test", NULL, NULL, NULL, NULL, FALSE); 

      //HttpOnly cookie:
      setcookie("abc", "test", NULL, NULL, NULL, NULL, TRUE); 
        
    - Via header()

      header("Set-Cookie: hidden=value; httpOnly");

    o 

      header("Set-Cookie: key=value; path=/; domain=www.tutorialshore.com; HttpOnly; Secure; SameSite=Strict");


Notar que las cookies tienen este órden de parámetros:

  key-value;expiration_date;path;domain;

<-- path podría ser /api

https://www.tutorialshore.com/make-cookie-secure-httponly-php/
https://stackoverflow.com/questions/36877/how-do-you-set-up-use-httponly-cookies-in-php#8726269
https://www.sitepoint.com/eat-those-cookies-with-jquery/
https://www.sitepoint.com/how-to-deal-with-cookies-in-javascript/
https://github.com/js-cookie/js-cookie


Las cookies se envian automáticamente..... así que supongo que en la cookie http-only debería enviar tanto access como refresh tokens......porque no voya poder elegir cual envio EXCEPTO que sean dos cookies distintas con expiraciones distintas... con lo cual la que expira (digamos access_token) ya no se envia!

https://stackoverflow.com/a/39833955/980631


- En las migraciones asegurarse que es posible mover un campo de lugar

ALTER TABLE divisas MODIFY COLUMN ISO VARCHAR(10) AFTER id

Implementar ->after('otro_campo') 


- Benchmarking Tool: wrk

- WebSockets

"For example, imagine your application is able to export a user's data to a CSV file and email it to them. However, creating this CSV file takes several minutes so you choose to create and mail the CSV within a queued job. When the CSV has been created and mailed to the user, we can use event broadcasting to dispatch a App\Events\UserDataExported event that is received by our application's JavaScript. Once the event is received, we can display a message to the user that their CSV has been emailed to them without them ever needing to refresh the page."

"To assist you in building these types of features, Laravel makes it easy to "broadcast" your server-side Laravel events over a WebSocket connection. Broadcasting your Laravel events allows you to share the same event names and data between your server-side Laravel application and your client-side JavaScript application.

The core concepts behind broadcasting are simple: clients connect to named channels on the frontend, while your Laravel application broadcasts events to these channels on the backend. These events can contain any additional data you wish to make available to the frontend."


https://laravel.com/docs/8.x/broadcasting?fbclid=IwAR1QIJTakXGUm2XJQguFFPpy6LquC-KByUCnFAXoaM2NineSu9IxBx0pGqI

Drivers para webstockets:

En Node
https://github.com/soketi/soketi

En PHP:
https://github.com/beyondcode/laravel-websockets


- Para manejar concurrencia:

    - Usar el módulo php-fpm de Apache o fpm de Nginx
    - Usar "colas" 
    - Usar "Swoole"  !!!!!!!!!

"Swoole is a production-grade async programming framework for PHP. It is a PHP extension written in pure C language, which enables PHP developers to write high-performance, scalable, concurrent TCP, UDP, Unix socket, HTTP, WebSocket services in PHP without too much knowledge of the non-blocking I/O programming and low-level Linux kernel. You can think of Swoole as something like NodeJS but for PHP, with higher performance."
    
https://laravel-news.com/laravel-swoole


- Leer sobre gRPC (lo que viene)

"A formal specification for HTTP API with JSON doesn't exist. Developers debate the best format of URLs, HTTP verbs, and response codes.

The gRPC specification is prescriptive about the format a gRPC service must follow. gRPC eliminates debate and saves developer time because gRPC is consistent across platforms and implementations."

"The communication between the microservices over HTTP can be done in multiple ways. The most widely used way is to follow the REST protocol. gRPC is another way to perform this communication. It is built to overcome the limitations of REST in microservice communication."

https://en.wikipedia.org/wiki/GRPC
https://docs.microsoft.com/en-us/aspnet/core/grpc/comparison?view=aspnetcore-5.0
https://medium.com/@saboteurkid/apis-solution-debate-rest-vs-grpc-vs-graphql-d9c25e44d6
https://medium.com/better-programming/understanding-grpc-60737b23e79e
https://www.gslab.com/blogs/grpc-vs-rest-a-complete-guide


- Reemplazar clases Resonse y Request por http_foundation

https://symfony.com/doc/current/create_framework/http_foundation.html
https://symfony.com/doc/current/components/http_foundation.html


- Más adelante migrar a Rust en vez de a Go para APIs

https://blog.discord.com/why-discord-is-switching-from-go-to-rust-a190bbca2b1f



- Terminar eventualmente el "Contenedor de dependencias inversas" 

  <?php

  class Service
  {
      //
  }

  Route::get('/', function (Service $service) {
      die(get_class($service));
  });

In this example, hitting your application's / route will automatically resolve the Service class and inject it into your route's handler. This is game changing. It means you can develop your application and take advantage of dependency injection without worrying about bloated configuration files.


  use Illuminate\Http\Request;

  Route::get('/', function (Request $request) {
      // ...
  });


"There is no need to bind classes into the container if they do not depend on any interfaces"

"it can automatically resolve these objects using reflection."


http://fabien.potencier.org/do-you-need-a-dependency-injection-container.html
https://laravel.com/docs/8.x/container#binding-basics
https://stackify.com/dependency-injection/
https://www.sitepoint.com/how-to-build-your-own-dependency-injection-container/


- Migraciones en el ServiceProvider (es sencillo, solo hacen un up)

- Ensayar con Apache y Nginx como correr SimpleRest como carpeta, ej: /api dentro de un proyecto en PHP como alternativa a meter la API en un subdominio

Posibilidades para ofrecer APIs:

  - Como carpeta /api lo cual implicaría:

    1. Que usen MySQL / SQLite o Postgres (aunque tengo soporte limitado)
    2. Que no usen SPs
    3. Que el proyecto esté en PHP?  
    4. Configurar el .htaccess de Apache o su equivalente
    5. Poder ajustarse a su tabla users con distinto nombre de campos.

  - Como subdominio: podría estar en otro lenguaje pero implica configurarlo.

  - Usando microservicios


- Podrian usarse constantes en el modelo para created_at, etc

  const CREATED_AT = 'created_at';
  const UPDATED_AT = 'updated_at';
  etc
  
Desde el ApiController se accderían como:

  $this->instance::CREATED_AT 
  etc


- El modelo de usuarios (aka: UserModel) debe contener las constantes:

  const USERNAME = 'username';
  const EMAIL    = 'email';
  const PASSWORD = 'password';
  const ACTIVE   = 'active';

- (ver de) reemplazar $soft_delete por una constante:

  static protected $soft_delete = true;

a..

  const $soft_delete = true;

- Reemplazar inSchema : en vez de instanciar el modelo para luego tener que instanciar el Schema correspondiente, tener un schema con solo propiedades estáticas y accederlo directamente saltando al modelo.

  Antes:    $books_reviews->inSchema(['campo'])
  Debe ser: in_array('campo', simplerest\\schemas\BookReviewsSchema::attr)

  O mejor con un helper

    hasAtrr('books_reviews', 'campo')

Claramente lo siguiente debe dejarse de hacer:

    use simplerest\schemas\BooksSchema;                  

    class BooksModel extends Model
    { 
      protected $hidden   = [];
      protected $not_fillable = [];

        function __construct(bool $connect = false){
            parent::__construct($connect, BooksSchema::class);   <--- no más
      }	
    }


Para saber que esquemas hay disponibles crear un "libro de schemas" que se debe actualizar con cada "make schema".

- Resolver incocistencia con /rememberme ya que en algún caso almacena el nombre del rol y en otros el id del rol en el payload del JWT lo que hace que se rompa el ACL 

- Sobre campos tipo DATETIME debe permitirse buscar por yy-mm-dd, yy-mm y yy (no solamente la fecha incluyendo la hora)

Ej:

http://simplerest.lan/api/v1/products?tenantid=az&created_at[gt]=2019-03-20

{
    "status": 400,
    "error": {
        "type": null,
        "code": null,
        "message": "Validation Error",
        "detail": {
            "created_at": [
                {
                    "data": "2019-03-20",
                    "error": "type",
                    "error_detail": "It's not a valid datetime"
                }
            ]
        }
    }
}