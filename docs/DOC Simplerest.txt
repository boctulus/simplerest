DOCUMENTACION 
-------------

SimpleRest utiliza la arquitectura MVC, está orientado a API Restful y es un framework para desarrollo rápido de aplicaciones (RAD).

Algunas características:

- MVC architecture 
- Router
- Middlewares
- APIs work out-of-the-box, i.e. without writing any code ***
- Authentication via OAuth 2 style web tokens and API Keys
- Centralized ACL with granular role and permissions system + custom permissions decorating roles
- Possibility to "share" resources via "folders".
- Impersonate
- Recycle garbage can
- Collections for mass actions
- Versioning
- Internationalization
- Query Builder (which include autojoins among other cool features) and the Model class
- UUIDs
- Migrations
- Multitenant support
- Service Providers
- Validator and auto-validations on models
- WebHooks and Server Sent Events
- Sub-resources
- API consumption utility
- Code profiler (execution times)
- Reverse dependency container (IoC)
- CronJobs
- Job Queue Manager
- View Templates
- HTML / Form Builder 
- Cache


Cómo "índice" para buscar documentación puede buscar por las características enumeradas previamente más las siguientes referencias:

- Requerimientos
- Instalación
- Variables de entorno
- Componentes del core
- La clase DB
- Procedimientos almacenados
- El helper db


(*) A pesar de ser un framework orientado a API Rest es posible servir vistas aunque no posee un motor de plantillas. Es posible que esta característica sea removida en futuras versiones.

# Estructura del proyecto

```
├── app                           # Main MVC file structure directory
│   ├── controllers               # Controllers directory 
|   |   └── api                   # API controllers  
│   ├── models                    # Models directory
│   ├── views                     # Views directory
│   ├── libs                      
|   ├── helpers                   # helpers
│   ├── locale                    # i18n translations
│   └── core                      # Core directory
|
├── core                          # Basically mvc engine directory
│   ├── api
|   |   ├── v1
|   |   ├── v2
|   |   └── vN
│   ├── exceptions
│   ├── interfaces                          
│   └── config                    # Configuration directory
│		├── acl.php 
│       ├── config.php          
│       └── constants.php           
│         
├── public
|   ├── assets                     
│   |   ├── css               
│   |   ├── img    
|   |   └── js
|   ├── .htaccess      
|   ├──  index.php
|   └──  favicon.ico
|
├─── vendor                    
└── .htaccess                     
```

# Requerimientos 

	PHP 7.4+
	MySQL / MariaDB - SqlLite - PostgreSql (*)
	Apache Web Server 2.4

Es posible hacer funcionar el framework con Nginx y en cuanto a PostgreSql está parcialmente soportado porque no se dispone actualmente de migraciones para este motor de base de datos.


# Instalación

Hay varios archivos por configurar y hay que correr un script de instalación.

Vea archivo adjunto sobre Instalación para más información.


### Archivo config.php

Hay varios archivos de configuración del framework en /config del cual el config.php es el principal.

El config.php es cargado via constructor en controladors y modelos siempre y cuando se extienda dicho constructor y está disponible como $this->config

Además, se puede cargar la configuración de varias formas:

	- Con el helper config()

	- Desde la clase Factory como config()

Incluir el archivo config.php directamente no es recomendado.

Ud. puede cambiar un valor de configuración con Config::set() aunque tenga en cuenta que muchas librerías y componentes del framework pueden estar guardándose una copia de la configuración e inclusive la clase DB lo hace con lo cual lo siguiente *no* funcionará:

	Config::set('db_connection_default') = 'db_xyz';
	DB::getDefaultConnection(); // sin cambio


# Configuración de "tenant groups"

Si se tienen varias bases de datos se deben configurar los "tentant_groups" en el archivo config.php

La implementación de "tenant groups" permite en principio separar schemas y modelos de distintas bases de datos y agrupar los que se se supone son de bases de datos con igual estructura.

Ej:

	'tentant_groups' => [
		'legion' => [
		  'db_[0-9]+',
		  'db_legion',
		  'db_flor'
		],
		'az' => [
		  'az'
		],
	],

Es recomendado definir grupos de multitenencia aunque se tenga bases de datos que no constituyan "clusters" para que los schemas queden organizados en carpetas distintas dentro de app/models/schemas y no se mezclen.

Además, si llegaran a existir dos tablas en dos bases de datos distintas con el mismo nombre no habrá problemas.

Se pueden definir varios patrones de nombres para un mismo grupo que en si son expresiones regulares de PHP. El órden en que se definan puede alterar el resultado de la clasificación de haber superposición de patrones.

Ej:

Lo siguiente define dos grupos

	'tentant_groups' => [
		'db_az' => [
			'db_az'
		],
		'legion' => [
			'db_[a-z0-9]+',
			'db_legion',
			'db_flor'
		]		
	],

Pero... lo siguiente define dos pero clasificará todo en el primero pues la primera expresión regular contiene a "db_az"  

	'tentant_groups' => [
		'legion' => [
			'db_[a-z0-9]+',
			'db_legion',
			'db_flor'
		],
		'db_az' => [
			'db_az'
		],
	],


# Variables de entorno

Se ofrece la clase Env con la finalidad de poder acceder a variables de entorno (del archivo .env) como alternativa al paquete Dotenv

Ej:

	// Usando Env::get()

	$dbname = Env::get('DB_NAME);
    $user   = Env::get('DB_USERNAME');
    $pass   = Env::get('DB_PASSWORD');
    $dsn    = "mysql:dbname=$dbname;host=127.0.0.1";

	// Crear la conexión manualmente 
	
    try {
        $conn = new \PDO($dsn, $user, $pass);
    } catch (PDOException $e) {
        throw new \Exception('DB connection fails: ' . $e->getMessage());
    }


# Configuración de endpoints

Endpoints pueden o no comienzar con /api

Las urls comienzan *sin* /api si en /config/config.php 

	'REMOVE_API_SLUG' => true

<-- remover el /api puede dar lugar a colisiones con controladores. Inclusive no funcionarán los resource controllers. 

OJO ! afecta al DownloadController


# El comando "make"

Este comando sirve para crear cualquier archivo importante para el framework ya sea helpers, librerías, modelos, esquemas, controladores, controladores para uso en la consola, serivice providers, migraciones, etc.

El uso básico del comando make puede aprenderse simplemente invocando la ayuda ejecutando:

	php com make

Crear nuevos comandos es bastante sencillo y la clase Make se puede extender. Observe la estrucura básica:

Ej:

	function controller($name, ...$opt) {
        $namespace = 'simplerest\\controllers';
        $dest_path = CONTROLLERS_PATH;
        $template_path = self::CONTROLLER_TEMPLATE;
        $prefix = '';
        $subfix = 'Controller';  

        $this->generic($name, $prefix, $subfix, $namespace, $dest_path, $template_path, ...$opt);
    }

Con "make" puede por ejemplo generar un archivo de controlador:

	make controller my_controller

Es posible "proteger" los archivos de ser sobreescritos por accidente incluyéndo la ruta relativa en el archivo ".make_ignore". En caso de querer en un caso puntual anular la protección puede usar la opción --unignore o bien --retry.

	make controller my_controller --retry

Con la opción --remove puede eliminar el archivo creado:

	make controller my_controller --remove

Si desea que el archivo se cree con la declaración de tipado estricto utilice --strict

	make controller my_controller --strict

Los controladores en particular pueden crearse en una carpeta o sub-carpeta dentro de app/controllers

Ej:

	make controller folder/my_controller


# Creación de usuarios

	POST /api/v1/auth/register	

	{
		"username": "super_ventas",
		"email": "b2@mail.com",
		"password": "gogogo"
	}		

<-- campos mínimos

Y se devuelve un JSON como este:

{
    "data": {
        "access_token": "eyJInR5cC....4Vhvo",
        "token_type": "bearer",
        "expires_in": 900,
        "refresh_token": "eyJ0e...EKhNjuc",
        "roles": [
            []
        ],
        "uid": "351",
        "email_confirmation_link": "http://localhost/incu_users/auth/confirm_email/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTU5NzUxNDA1NSwiZXhwIjoxNTk4MTE4ODU1LCJpcCI6Ijo6MSIsImVtYWlsIjoiYWFhQG1haWwuY29tIn0.J2pUPHmmIwpXtlTpgDqu23jb-h0HlAz9ife-4HVfa1c/1598118855"
    },
    "error": "",
    "error_detail": ""
}

Es posible solicitar un rol (comprador o vendedor por ejemplo) al momento del registro. Es requisito tener definidos los roles como pre-aprobados en config/config.php

Ej:
	'auto_approval_roles' => ['vendedor'],

Entonces al momento de hacer el registro se puede especificar el o los roles que se desean obtener:

{
		"username": "super_ventas",
		"email": "b2@mail.com",
		"password": "gogogo",
        "roles": ["vendedor"]
}


# Login 

	POST /api/v1/auth/login

	{
		"email": "usuario@mail.com",
		"password": "xxxx"
	}

Se devuelve un JSON como el siguiente:

{
    "data": {
        "access_token": "eyJ0eXAiOiJ.....QwjPRA",
        "token_type": "bearer",
        "expires_in": 900,
        "refresh_token": "eyJ0e....SUxd_dpg-Js",
        "roles": [
            "contabilidad",
            "mercadotecnia"
        ],
        "uid": 350
    },
    "error": "",
    "error_detail": ""
}


# Verficación de correo

Es solo seguir el enlace provisto al momento de registrarse o .........


# Recordar contraseña

	POST /api/v1/auth/rememberme

	{
		"email": "usuario@mail.com"
	}

=> devuelve un JSON con el enlace (request por GET) para cambiar la contraseña 	

Ej:

	{
		"data": {
			"link_sent": "http://localhost/incu_users/auth/change_pass_by_link/eyJ0eX...I15SY/1598117791"
		},
		"error": "",
		"error_detail": ""
	}

Al seguir el enlace se devuelve un nuevo JSON con el access token necesario para poder realizar el cambio de contraseña. Redireccionar a la vista correspondiente es un asunto aparte.

{
    "data": {
        "access_token": "eyJ0eXAi.....4fAs",
        "token_type": "bearer",
        "expires_in": 900,
        "uid": "350",
        "roles": [
            "contabilidad",
            "mercadotecnia"
        ],
        "permissions": []
    },
    "error": "",
    "error_detail": ""
}

Finalmente para cambiar efectivamente la contraseña se hace uso del siguiente endpoint enviando las credenciales correspondientes (access token)

	POST /api/v1/auth/change_pass_process

	{
		"password": "xxxxx"
	}


# Renovación de tokens

	POST /api/v1/auth/token

<-- enviando el refres_token en headers y sin body

Se devolverá un nuevo acccess token en un JSON como este:

{
    "data": {
        "access_token": "eyJ0e.....8eXKY",
        "token_type": "bearer",
        "expires_in": 900,
        "roles": [
        ],
        "uid": "352"
    },
    "error": "",
    "error_detail": ""
}

# Impersonate

Es posible asumir la identidad de otro usuario o bien un rol en particular -solo uno a la vez-. 

Esta característica solo está disponible con autenticación via Web Tokens y no otras como API KEY ***

POST /api/v1/auth/impersonate que recibe un *refresh_token* de un admin (usuario con permiso 'impersonate') y en el body:

	{ 
		"uid" : "90"  
	}

Lo cual genera el par access y refresh token como Admin donde dentro un campo "impersonated_by" con el id del admin, ej:

{
    "data": {
        "access_token": "eyJ0...",
        "refresh_token": "eyJ0....",
        "token_type": "bearer",
        "expires_in": 90000000,
        "roles": [
            "regular"
        ],
        "uid": "90",
        "impersonated_by": 4  <-- id del Admin
    },
    "error": "",
    "error_detail": ""
}

O bien con un rol que inclusive puede ser "guest"

	POST /api/v1/auth/impersonate que recibe un refresh_token de un Admin y en el body:

	{ 
		"role": "basic"	
	}

La ventaja de hacer la impersonalización por roles es que no es necesario tener varias cuentas con diferentes roles para hacer pruebas y tampoco es necesario des-loguearse para simular ser un "guest".

Al hacer un impersonate debe elegirse si se hace por uid o por rol. No tiene mucho sentido enviar un rol y un uid en el mismo request y el resultado puede no ser el esperado.

Para parar la "impersonalización",...

POST /api/v1/auth/stopImpersonate con el access_token del admin que está haciendo uso de impersonate lo cual debe devolver un nuevo token sin impersonate, ej:

{
    "data": {
        "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTU5OTY5MjYwMCwiZXhwIjoxNjg5NjkyNjAwLCJpcCI6IjEyNy4wLjAuMSIsInVpZCI6NCwicm9sZXMiOlsiYWRtaW4iXSwiY29uZmlybWVkX2VtYWlsIjoxLCJwZXJtaXNzaW9ucyI6W119.5k272dPgzKFZVEYPC9NgKbrsf9qu1EdUe01CTagYrjE",
        "token_type": "bearer",
        "expires_in": 90000000,
        "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTU5OTY5MjYwMCwiZXhwIjoxOTE1MDUyNjAwLCJpcCI6IjEyNy4wLjAuMSIsInVpZCI6NCwicm9sZXMiOlsiYWRtaW4iXSwiY29uZmlybWVkX2VtYWlsIjoxLCJwZXJtaXNzaW9ucyI6W119.k8SNRcSD4j3JtFlV8Qj3lfVqOiP_2hVYI4bCM0rhWWg",
        "roles": [
            "admin"
        ],
        "uid": 4
    },
    "error": "",
    "error_detail": ""
}

Tanto created_by, updated_by y deleted_by reflejan referencian al Admin pero belongs_to al momento de crear un registro es con el usuario con por el que se hace la sustitución.

El token se puede seguir renovando normalmente pero con ciertas limitaciones: al renovar el token de un impersonate hecho "por rol", el rol se pierde volviendo al rol de admin. Esto ocurre porque los roles no viajan en el payload del refres_token que solo se utiliza para autenticación -y no autorización-.

S puede hacer el impersonate al rol de "guest" y en este caso particular se puede seguir renovando el token conservando dicho rol indefinidamente (hasta vencimiento el refres_token)

POST /api/v1/auth/impersonate que recibe un refresh_token de un Admin y en el body:

{ 
	"role" : "guest"	
}

Obteniendo algo como

{
    "data": {
        "access_token": "eyJ0eXAiOiJ..",
        "refresh_token": "eyJ0eXAi...",
        "token_type": "bearer",
        "expires_in": 90000000,
        "roles": [
            "guest"  
        ],
        "uid": -1,
        "impersonated_by": 4
    },
    "error": "",
    "error_detail": ""
}

<-- observar que el único rol es "guest", el uid es -1 y nuevamente queda habilitada la impersonalización.

Nota: se puede hacer un impersonate con el refresh_token de otro Impersonate.


# Confirmación de correo

Al momento de registrarse exitosamente en el JSON de la respuesta se incluye

	"email_confirmation_link": "http://az.lan/api/v1/auth/confirm_email/eyJ0eXA...KDFsI/1600830742"

Y siguiendo ese enlace el correo de la cuenta queda verificado devolviendo:

{
    "data": {
        "msg": "Email confirmed - thanks!"
    },
    "status_code": 200,
    "error": "",
    "error_detail": ""
}

<-- es posible devolver tokens pero serían inseguro -aunque el recuérdame genera tokens-. 

Luego de confirmar el correo es responsabilidad del usuario volverse a loguear. 


# Recuérdame

POST /api/v1/auth/rememberme con el body

	{
		"email": "algun_usuario@mail.com"
	}

Debe generar un enlace para cambiar el enlace por GET y en "modo desarrollador" produciría una respuesta como esta: 

	{
		"data": {
			"link_sent": "http://az.lan/api/v1/auth/change_pass_by_link/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTYwMDIyNjQxMCwiZXhwIjoxNjAwODMxMjEwLCJpcCI6IjEyNy4wLjAuMSIsInJvbGVzIjpbInJlZ3VsYXIiXSwicGVybWlzc2lvbnMiOnsicHJvZHVjdHMiOjcsImZvbyI6N30sInVpZCI6IjE2OCIsImFjdGl2ZSI6IjEifQ.Z2HsyPGfGflCG1vOq5hwKqd50QOEgLZO5flixz4hMTU/1600831210"
		},
		"status_code": 200,
		"error": "",
		"error_detail": ""
	}

<-- en producción no tiene chiste que se lea el enlace a seguir !	

Si busca el hook para colgarse del evento, este se llama onRemembered() y le pertenece a AuthController que es extendida por MyAuthController.


# Versionado

Se especifica la versión en la url y esto tiene como efecto cargar una versión distinta de la clase ApiController en /app/core/api

	GET /api/v1/products
	GET /api/v2/products
	GET /api/v3/products

En el primer por ejemplo caso carga la clase /app/core/api/v1/ApiController

La clase MyApiController en /app/controllers es la responsable de seleccionar la versión solicitada de la API.

Cuando sea necesario crear una nueva versión de la API, deberá agregarse al MyApiController algo como:

	if ($api_version == 'v2'){
		class MyApiController extends \simplerest\core\api\v2\ApiController {}
		return;
	}

Debe hacerse lo mismo en MyAuthController.php 

	if ($api_version == 'v2'){
    	class AuthController extends \simplerest\core\api\v1\AuthController {}
    	return;
	}

Esto posibilita hacer uso de hooks en la clase extendida. 

Las urls comienzan *sin* /api si en /config/config.php 

	'REMOVE_API_SLUG' => true


### La clase Config

Para usar la utilería Config debe hacerse a través de Factory para acceder a la misma instancia:

# Obtener instancia única:

	config()


# Introducir y leer datos (de forma no-persistente)

Se puede escribir mediante el método set() y leer con get() o bien acceder como array ya que se implementa la interfaz ArrayAccess:

	config()['xxx'] = 'zzz';
    dd(config()['xxx']);  // 'zzz'

o
	
	config()->set('xxx','zzz');
	dd(config()->get('xxx'));  // 'zzz' 

o

	config()->set('xxx','zzz');
	dd(config()['xxx']);  // 'zzz'   


### Autenticación

El framework soporta dos tipos de autenticación, una basada en web tokens y otra en API Keys para backend-to-backend 

Para API KEYs, se deben generar las apis para los usuarios (una por usuario) e insertarlas en la tabla api_keys.

Hay dos formas de pasar la API KEY

1) Via url agregando el parámetro api_key

Ej:

	GET /api/v1/some_resource?api_key=8ZfTPJB3VeCAAkea HTTP/1.1

2) Via header X-API-KEY 

	GET /api/v1/some_resource HTTP/1.1
	X-API-KEY: 8ZfTPJB3VeCAAkea

Más
https://swagger.io/docs/specification/authentication/api-keys/


### Controlador

Los controladores son clases cuyos métodos ejecutan acciones al ser invocados desde el FrontController o el Router.

Para demostrar como ejecutar un controlador desde la linea de comandos ejemplificaremos con un simple controlador ubicado en la carpeta controllers:

	<?php

	namespace simplerest\controllers;

	class DumbController extends Controller
	{

		function add($a, $b){
			$res = (int) $a + (int) $b;
			return  "$a + $b = " . $res;
		}

	}

La acción será ejecutada con: 

	php com dumb add 1 6

Hay soporte para sub-directorios o sub-sub-(sub)-directorios 


# Front Controller y Router 

Es posible configurar el uso del Front Controller y/o del Router. El primero es más sencillo pero se aconseja casi exclusivamente para utilizar los controllers desde la terminal. 

El Router tiene la enorme ventaja de permitir filtrar los requests por su verbo HTTP:

	# ruta: /calc/sum/4/5
	Route::get('calc/sum', function($a, $b){
		return "La suma de $a y $b da ". ($a + $b);
	})->where(['a' => '[0-9]+', 'b' =>'[0-9]+']);

	# ruta: /saludador/sp/hi/Juan/Carlos/44
	Route::get('saludador/sp/hi/', function($nombre, $apellido, $edad){
		return "Hola ". ($edad > 30 ? 'Sr. ' : '') . "$nombre $apellido";
	})->where(['edad' => '[0-9]+', 'nombre' =>'[a-zA-Z]+', 'apellido' =>'[a-zA-Z]+']);

	# ruta: /saludador/en/hi/Juan/Carlos/44
	Route::get('saludador/en/hi/', function($nombre, $apellido, $edad){
		return "Hello ". ($edad > 30 ? 'Mr. ' : '') . "$apellido $nombre";
	})->where(['edad' => '[0-9]+', 'nombre' =>'[a-zA-Z]+', 'apellido' =>'[a-zA-Z]+']);

	# ruta: /tonterias
	Route::get('tonterias',  'DumbController');

	# ruta: /chatbot/hi
	Route::get('chatbot/hi', 'DumbController@hi')
	->where(['name' => '[a-zA-Z]+']);  // <-- where() no implementado con controladores !

	# ruta: /cosas/67
	Route::delete('cosas', function($id){
		return "Deleting cosa con id = $id";
	});


El router se habilitan desde el archivo config/config.php y se configura desde /config/routes.php


### Resource Controller:

Un ResourceController es un tipo de controlador que mediante un Authorization header identifica al usuario y su rol.

Ejemplo:

class DumbAuthController extends ResourceController
{
    function __construct()
    {
        parent::__construct();
    }

    function super_cool_action($a)
    {
        if (!$this->hasAnyRole(['cajero', 'gerente']))
            Factory::response()->sendError('Unauthorized', 401);

        // acción cualquiera:
        return ++$a;
    }       
}


# Api Controller:

Un ApiController es un tipo de ResourceController que sirve para procesar un endpoint y por tanto sus métodos son los verbos correspondientes: get, post, put, patch, delete, head


# Middlewares

Los middlewares constituyen una capa intermedia que permiten interceptar una respuesta y alterarla o modificar el flujo del programa proveyendo un punto donde se pueden hacer chequeos de seguridad por ejemplo.

SimpleRest implementa Middlewares para el FrontController de la siguiente manera:

Supongamos que se tiene un Controlador llamado TestController con un método que genera una respuesta y queremos alterarla *sin* tocar el código del método:

	class TestController {
		// ...

		function mid(){
			return "Hello World!";        
		}
	}

1) Se debe crear un Middleware que tendrá una estructura parecida a:

	<?php

	namespace simplerest\middlewares;

	use simplerest\core\Middleware;

	class InyectarSaludo extends Middleware
	{   
		function __construct()
		{
			parent::__construct();
		}

		function handle(?callable $next = null){
			$data = $this->res->getData();

			if (is_string($data)){
				if (Strings::startsWith('Hello ', $data)){
					$this->res->setData(preg_replace('/Hello (.*)/', "Hello happy $1", $data,1));
				}
			}
		}
	}

2) Se registra el Middleware en config/middlewares.php

	return [
		// ...
		'simplerest\controllers\TestController@mid' => InyectarSaludo::class,
		// ...
	];

Ahora la respuesta del método mid() de TestController será interceptada y modificada.


# El Schema

Todas las tablas deben tener un único id inclusive si son "tablas intermedias" (conocidas también como "tablas puente") y se especifica en la propiedad $id_name.

Se recomienda que las tablas tengas claves primarias simples pero si son compuestas entonces es requisito que uno de los campos sea AUTOINCREMENTAL. A futuro se prevee que se acepte que uno de los campos de una PRIMARY KEY compuesta pueda ser un UUID en vez de AUTOINCREMENTAL. 


# Modelo y Query Builder

Cada modelo es definido en una clase en /app/models que extiende a Model y donde se define el schema y algunas propiedades de los campos. Ejemplo:
	
	class BazModel extends Model
 	{ 

		protected $hidden   = [];
		protected $not_fillable = [];

		function __construct(bool $connect = false){
			parent::__construct($connect, BazSchema::class);
		}	
	}

Un modelo extendiende a la clase Model que les provee toda la funcionalidad y acepta un schema. Tanto modelos como schemas pueden ser generados por el comando "make".

La clase "base" para el modelo es Model pero se sugiere extender a MyModel a fin de poder aplicar campos automáticos y hooks de forma general o sea que apliquen a todos los modelos.

Ej:

	class MyModel extends Model 
	{
		protected $createdBy = 'usu_intIdCreador';
		protected $updatedBy = 'usu_intIdActualizador';
		protected $createdAt = 'gen_dtimFechaActualizacion';
		
		function __construct(bool $connect = false, $schema = null, bool $load_config = true){
			parent::__construct($connect, $schema, $load_config);
		}
	}

En el ejemplo previo se especifica que para todos los modelos (salvo que en el propio modelo se explicite lo contrario) los campos automáticos que allí se listan (hay más) tienen los nombres mencionados.

Hay básicamente 3 formas de usar un Model:

a) Instanciando directamente Model en cuyo caso *no* dispondríamos de un schema a menos que se lo inyectemos:

	$m = (new Model(true))
		->table('products')   
		->select(['id', 'name', 'size'])
		->where(['cost', 150, '>=']);

	dd($m->get());

	Ventajas: 

	- Puede hacerse uso del Query Builder sin un schema lo cual es útil para probar la validez del mismo (pruebas unitarias)
	- Puede generar las queries sin una conexión a la base de datos (comportamiento por defecto).

	Desventaja:

	- Verboso
	- En principio no se dispone del Schema sin lo cual no es posible hacer validaciones contra el mismo.
	- No funcionan de forma automática los campos UUID

b) Instanciando una clase Model derivada

	$m = (new ProductsModel(true))
		->select(['id', 'name', 'size'])
		->where(['cost', 150, '>=']);

	dd($m->get());

	Ventajas: 

	- Se dispone del schema si se inyecta en el modelo derivado (así es generado por "make")
	- Validación out-of-the-box si se inyectando el validator.
	- Menos verboso: ya no es necesario llamar al método table('nombre_tabla')   

c) Usando la clase DB para obtener la instancia

    $m = DB::table('products')
		->select(['id', 'name', 'size'])
		->where(['cost', 150, '>=']);
    
	dd($m->get());
    
	Ventajas:

	- Es la opción menos verbosa.
	- Se dispone del Schema para hacer validaciones.

	Desventajas:

	- Obtiene una conexión a la base de datos aún antes de hacer cualquier tipo de validación.
	- Es un poco más lenta 

Es de destacar que podría darse el caso de que sea Ud. necesite acceder a la base de datos desde el archivo config.php pero si se hiciera DB::table('xxx') se generaría una referencia circular porque se incluiría nuevamente el archivo config.php

La solución es crear una conexión directamente sin uso de las clases Model o DB y luego especificar que el modelo no deba ni crear conexión ni intentar cargar el config.php para nada.

Ej:

	$dbname = 'nombre_db';
    $user = 'boctulus';
    $pass = 'xxxxxxxxxxxxxxx';
    $dsn  =  "mysql:dbname=$dbname;host=127.0.0.1";

    try {
        $conn = new \PDO($dsn, $user, $pass);
    } catch (PDOException $e) {
        throw new \Exception('DB connection fails: ' . $e->getMessage());
    }

    $m = (new Model(false, null, false))
    ->setConn($conn);
    
    $rows = $m->table('mi_tabla')
    ->get();


# El Query Builder

SimpleRest viene con un constructor de consultas ("queries") y sentencias ("statements") basado en métodos encadenados. 


# Inserción de registros

El método create() acepta un array asociativo de campos con sus valores y hace el INSERT

	$last_id = DB::table('super_cool_table'
	->create([
		'name' => 'SUPER',
		'age' => 22,
	]);


# Insert múltiple

Se puede enviar a  insertar varios registros de forma simultánea y se devolverá también el ID del último registro insertando si se hace de la siguiente forma:

Ej:

	// En caso de haber varias DB(s), selecciono la conexión donde está
	DB::getConnection('az');

	$data = [
		array (
			'name' => 'N1',
			'comment' => 'P1',
			'product_id' => 100
		),

		array (
			'name' => 'N2',
			'comment' => 'P2',
			'product_id' => 103
		),

		array (
			'name' => 'N3',
			'comment' => 'P3',
			'product_id' => 105
		)
	];

	$last_id = DB::table('product_tags')
	->create($data);

Cabe aclarar que el con el método create() se hace un INSERT INTO detrás de otro y no se envian juntas las rows la base de datos.  

Si se desea enviar todas las rows de una vez a la DB se puede hacer con insert()

Ej:

	$data = [
		array (
			'name' => 'N1',
			'comment' => 'P1',
			'product_id' => 100
		),

		array (
			'name' => 'N2',
			'comment' => 'P2',
			'product_id' => 103
		),

		array (
			'name' => 'N3',
			'comment' => 'P3',
			'product_id' => 105
		),

		array (
			'name' => 'N4',
			'comment' => '',
			'product_id' => 105
		)
	];

	/*
		id del primer registro insertado en bloque
	*/

	$id = DB::table('product_tags')
	->insert($data);


# Obtención de registros

Todos los registros (menos los marcados como borrados)

	$rows = DB::table('products')
	->get();

Para filtrar usar where()

	$rows = DB::table('products')
	->where(['size' => '2L'])
	->get();

También es válido usar el método where() con un array (campo, valor)

	$rows = DB::table('products')
	->where(['size', '2L'])
	->get();

Si bien el método where() admite userse de dos ambas dos formas no es aconsejable combinarlas:

	// ok
	$rows = DB::table('products')
	->where(['size', '2L'])
	->where(['cost', 100])
	->get();

	// ok
	$rows = DB::table('products')
	->where(['size' => '2L'])
	->where(['cost' => 100])
	->get();

	// No se recomienda (!)
	$rows = DB::table('products')
	->where(['size' => '2L'])
	->where(['cost', 100])
	->get();

La última forma es funcional pero podría fallar en algún caso.


# Comparar dos campos en el WHERE

	$m = (DB::table('users'))
	->whereColumn('firstname', 'lastname', '=');  

	dd($m->get()); 


# Forma básica de debugueo de queries

Siempre que se use el método DB::table() será posible debuguear la última query de la siguiente manera:

    dd(DB::getLog());

Ejemplo:

	$rows = (DB::table('users'))
	->whereColumn('firstname', 'lastname', '=')
	->get();  

	dd(DB::getLog()));

Hay otras formas de debugueo de consultas que se pueden encontrar más adelante en este manual.


# Ocultar y des-ocultar campos

Si existe el modelo y el schema correspondiente para una tabla se pueden suprimir campos:

	class UsersModel extends Model
	 { 	
		protected $hidden   = [	'password' ];

		// ...

En este caso password será por defecto suprimido cuando no haya un SELECT o sea cuando sea un SELECT *

Es posible ocultar o desocultar campos programáticamente siempre que se utilice select() o selectRaw() en la consulta:

	$u = DB::table('users');
    $u->unhide(['password']);
    $u->hide(['confirmed_email']);
    $u->where(['id'=>$id]);

    dd($u->get());


Si se desea des-ocultar cualquier campo oculto se dispone del método unhideAll()

	$rows = DB::table('users')
    ->crossJoin('products')
    ->where(['users.id', 90])
    ->unhideAll()
    ->get();


# Campos no rellenables 

Del mismo modo que como ocurre con los campos ocultos hay campos que son no-fillables:

	class UsersModel extends Model
	 { 	
		protected $hidden   = [	'password' ];
		protected $not_fillable = ['confirmed_email', 'is_active'];

		// ...


Igualmente hay métodos para programáticamente hacer rellenables o no-rellenables ciertos campos:

	$u = DB::table('users');
    $u->fill(['email']);
    $u->unfill(['password']);
    $id = $u->create([
    				'email'=>$email, 
    				'password'=>$password, 
    				'firstname'=>$firstname, 
    				'lastname'=>$lastname
    ]);
    

# Borrado de registros

Para eliminar un registro, establezca una condición y llame al método delete()

Ej:

	DB::table('products')
	->find(145)
	->delete();

Lo anterior equivaldría (asumiendo que el id se llama 'id') a lo siguiente:

	B::table('products')
	->where['id' => 145]
	->delete();

También la condición podría estar dada por un whereRaw()


# Borrado "suave" o soft-delete

Métodos relacionados:

	withTrashed(bool $soft_delete)	borra un registro. Hay parámetros adicionales.
	trashed()       				devuelve si el registro fue borrado suavemente.
    undelete()      				restaura el registro si fue borrado suavemente.
    forceDelete()   				borra un registro definitvamente.
    withTrashed()   				incorpora a la selección registros borrados suavemente.
    onlyTrashed()   				selecciona solo registros borrados suavemente.

Si una tabla y su schema dispone de un campo "deleted_at" de tipo DATETIME, al hacer un delete() el registro no es borrado fisicamente sino solo se oculta de los resultados.

Ej:

	DB::table('products')
	->where(['id' => $id])
	->get());

	// SELECT * FROM products WHERE id = $id AND deleted_at IS NULL

En caso de querer des-ocultar registros borrados para que sean visualizados en una consulta usar deleted() o withTrashed()

	DB::table('products')
	->where(['id' => $id])
	->deleted()
	->get());

	// SELECT * FROM products WHERE id = $id 

Por el contrario si desea mostrar solo registros que fueron borrados de forma suave use withTrashed()

Ej:

	DB::table('products')
	->where(['id' => $id])
	->withTrashed()
	->get());


# Borrar un registro de forma definitiva 

Si se desea que al momento de borrar el campo se elimine de forma definitiva puede usar setSoftDelete(false)

	$u = DB::table('users')
	->find($id)
	->setSoftDelete(false)
	->delete();  

Por defecto SimpleRest solo selecciona registros que no estén borrados ya sea físicamente o virtualmente con "borrado suave" por concistencia.

Nota: el campo de tipo DATETIME requerido para borrar registros no tiene porque llamarse "deteled_at" y ese nombre puede setearse en el modelo mediante el atributo $deletedAt.

También puede ocupar el método forceDelete() que borra un registro de forma definitiva haya o no sido previamente borrado suavemente.

Ej:

	DB::table('products');
	->find(5510)
	->forceDelete();

O..

	DB::table('products');
	->where($some_condition)
	->forceDelete();


# Chequear si un registro fue borrado "suavemente"

El método trashed() devuelve un boolean indicando si el registro fue borrado con softdelete o no pero fallará arrojando excepción si el softdelete no está habilitado.

	$trashed = DB::table('products')
	->find(145)
	->trashed());


# Restaurar un registro fue borrado "suavemente"

El método undelete() restaura un registro borrado con softdelete pero fallará arrojando excepción si el softdelete no está habilitado. 

Este método no chequea si realmente el registro fue borrado aunque sino existe tampoco generará excepción. En caso de querer verficar previamente si el registro fue borrado utilice trashed()



# Obtener el nombre del Id de la tabla

SimpleRest considera 'id' al nombre de la PRIMARY KEY (si es simple), del campo AUTOINCREMENT o bien del campo UUID de la tabla. Esto permite compatibilidad con diseños donde las tablas tienen claves primarias compuestas siempre que exista un campo que pueda representar unívocamente a cada registro.

Utilice el método id() para obtener el nombre del id correspondiente.

Ej:

	$id_name = DB::table('super_cool_table')->id();


# Joins

Un INNER JOIN se hace de la siguiente manera:

	$instance->join('table2', 'table2.id', '=',  'table1._id');

El operador puede ser =, >, <, >= o <=

Ej:

	$m = DB::table('users')
	->join('user_sp_permissions', 'users.id', '=',  'user_sp_permissions.user_id')
	->join('sp_permissions', 'sp_permissions.id', '=', 'user_sp_permissions.id')

	->select(['sp_permissions.name as perm', 'username', 'is_active']);

	dd($m->get()); 
	dd($m->dd()); 
     

Los joins pueden simplificarse como auto-joins de haber un schema para el modelo:

	$m = DB::table('users')
	//->join('user_sp_permissions');
	->join('sp_permissions');

	$m->select(['sp_permissions.name as perm', 'username', 'is_active']);

	dd($m->get()); 
	dd($m->dd()); 

Es importante notar que *no* debe hacerse el JOIN() *explícito* con la tabla puente y la table relacionada
por esta porque en tal caso la relación con la tabla puente quedaría duplicada. Si se incluyera 
se generaría para el caso de MySQL un error como

	SQLSTATE[42000]: Syntax error or access violation: 1066 Not unique table/alias: 'user_sp_permissions'

Si hay una tabla puente, la relación debe hacerse con la table del otro lado del puente y no incluir a la tabla puente en cuestión.


# Left y Right joins

Ej:

	$users = DB::table('users')->select([
	    "users.id",
	    "users.name",
	    "users.email",
	    "countries.name as country_name"
	])
	->leftJoin("countries", "countries.id", "=", "users.country_id")
	->get();

# Cross y natural joins

	$rows = DB::table('users')
    ->crossJoin('products')
    ->where(['users.id', 90])
    ->unhideAll()
    ->deleted()
    ->get();

	$rows = (new Model())->table('employee')
    ->naturalJoin('department')
    ->unhideAll()
    ->deleted()
    ->get();


# Alias (as)

Es posible declarar alias tanto para la table principal como para las tablas a ser unidas por join.

Ej1)

	DB::getConnection('az');

	$rows = DB::table('users', 'u')
	->join('products')
	->join('roles')
	->unhideAll()
	->deleted()
	//->dontExec()
	->get();
	
	dd($rows);
	dd(DB::getLog());  

Ej2)

	DB::getConnection('az');

	$rows = DB::table('users', 'u')
	->join('products as p')
	->join('roles as r')
	->unhideAll()
	->deleted()
	//->dontExec()
	->get();
	
	dd($rows);
	dd(DB::getLog());   

El SQL generado en este caso sería algo como:

	SELECT * FROM users as u 
	INNER JOIN products as p ON u.id=p.belongs_to 
	INNER JOIN user_roles ON u.id=user_roles.user_id 
	INNER JOIN roles as r ON r.id=user_roles.role_id;

Cabe notar que no es posible especificar el alias para la tabla puente del ejemplo (`user_role`)

Tampoco es posible explicitar el "alias" (con 'as') cuando haya se haga un join hacia una tabla desde la cual existe más una relación con la primera. 

Ej:

	$rows = DB::table('users', 'u')
    ->join('products as p')
	->get();

Posible salida:

	SELECT * 
	FROM users as u 
	INNER JOIN products as p ON p.belongs_to = u.id 

En el caso anterior no habría problema si products tiene dos FKs (`belongs_to` y `deleted_by`) para users pero el "problema" se presenta si la relación se hace al revés:

	$rows = DB::table('products', 'p')
    ->join('users as u')
	->get();

Posible salida:

	SELECT * 
	FROM products as p 
	INNER JOIN users as __belongs_to ON __belongs_to.id = p.belongs_to 
	INNER JOIN users as __deleted_by ON __deleted_by.id = p.deleted_by


El "problema" es que cuando hay más de una relación entre dos tablas se necesita un alias por cada relación y con "as" solo es posible especificar una por lo cual la ambiguedad la resuelve automáticamente el framework.


### Referencia de métodos de la clase Model

La clase Model responsable del Query Builder tiene una gran cantidad de métodos que proveen las distintas funcionalidades.


# where

Los arrays de los where pueden ser asociativos:

	$facturas = DB::table('facturas')
	->where(['created_by' => 401])
	->get();

O no-asociativos:

	$facturas = DB::table('facturas')
	->where(['created_by', 401])
	->get();

La ventaja de los no-asociativos es que permiten especificar un operador como tercer parámetro:

	DB::table('products')->where([ 
            ['cost', 200, '>=']
    ])->get();

Pueden haber varios WHERE en cuyo caso se hace un "AND WHERE"

	$rows = DB::table('products')
	->where(['size', '2L'])
	->where(['cost', 100, '<'])
	->get();

No se aconseja para nada mezclar arrays WHEREs con arrays asociativos y no-asociativos.

# whereNot

Efectua un WHERE {campo} != {valor}

Ej:

	$pids = DB::table('background_process')
	->whereNot('process', 'worker')
	->pluck('pid');

# whereNull / whereNotNull

	$rows = DB::table('products')
	->whereNull('workspace')
	->get();

	$rows = DB::table('products')
	->whereNotNull('workspace')
	->get();

# whereIn / whereNotIn

Es posible hacer un WHERE IN( array ) y un WHERE NOT IN ( array ) con whereIn() y whereNotIn() respectivamente.

	$rows = DB::table('products')
    ->whereIn('size', ['0.5L', '3L'])
	->get());

	$rows = DB::table('products')
    ->whereNotIn('size', ['0.5L', '3L'])
	->get());


# whereBetween / whereNotBetween

	$rows = DB::table('products')
	->select(['name', 'cost'])
	->whereBetween('cost', [100, 250])
	->get());

	$rows = DB::table('products')
	->select(['name', 'cost'])
	->whereNotBetween('cost', [100, 250])
	->get());

# whereOr

Se puede realizar un "WHERE OR"

	$rows = DB::table('products')
	->where(['belongs_to', 90])
	->whereOr([ 
		['name', ['CocaCola', 'PesiLoca']], 
		['cost', 550, '>='],
		['cost', 100, '<']
	])
	->get();

# orWhere

Se puede realizar un "OR WHERE"

	$rows = DB::table('users')
	->where([ 'email'=> $email ]) 
	->orWhere(['username' => $username ])

# whereDate

Este tipo de where busca tanto en campos de tipo date como datetime.

Ej:

	$facturas = DB::table('facturas')
	->whereDate('created_at', '2021-12-29')
	->get();

Puede especificarse un operador =, > o <

Ej:

	$facturas = DB::table('facturas')
	->whereDate('created_at', '2021-12-29', '>')
	->get();


# group

Se explica en detalle más adelante pero group() permite agrupar condiciones permitiendo crear consultas muy complejas.

Ej:

	$rows = DB::table('products')

	->where([
		['cost', 100, '>'], // AND
		['id', 50, '<']
	]) 

	// AND
	->whereRaw('name LIKE ?', ['%a%'])
	
	// AND
	->group(function($q){  
		$q->where(['is_active', 1])
		// OR
			->orWhere([
			['cost', 100, '<='], 
			['description', NULL, 'IS NOT']
		]);  
	})
	
	// AND
	->where(['belongs_to', 150, '>'])

	->select(['id', 'cost', 'size', 'description', 'belongs_to'])
	->get();


# not

El operador not() niega todo un grupo de condiciones. Ej:

	$rows = DB::table('products')
	->where(['belongs_to', 150, '>'])
	->not(function($q) {
		$q->whereRegEx('name', 'a$')
		->or(function($q){ 
			$q->where([
				['cost', 100, '<='],
				['description', NULL, 'IS NOT']
			]);
		});             
	})
	->where(['size', '1L', '>='])
	->get();


# whereRegEx / whereNotRegEx

Es posible usar expresiones regulares siempre claro que el motor de base de datos las soporte.

Ej:
	$rows = DB::table('products')
	->whereRegEx('name', 'Coke')
	->or(function($q){
		$q->where(['cost', 100, '<=']);
	})
	->get();     

	$rows = DB::table('products')
    ->whereNotRegEx('name', 'Coke')
	->get();

# whereRaw

Ej:

	$rows = DB::table('products')
	->where(['belongs_to' => 90])
	->whereRaw('cost < IF(size = "1L", ?, 100) AND size = ?', [300, '1L'])
	->orderBy(['cost' => 'ASC'])
	->get();

# orWhereRaw

Ej:

	$rows = DB::table('products', 'p')
	->where([
		['cost', 50, '>'], // AND
		['id', 190, '<=']
	]) 
	// AND
	->group(function($q){  
		$q->where(['is_active', 1])
		// OR
		->orWhereRaw('name LIKE ?', ['%a%']);  
	})
	// AND
	->where(['belongs_to', 1, '>'])
	
	->select(['id', 'name', 'cost', 'size', 'description', 'belongs_to'])
	->get();


# whereExists

Si se desea hacer un "WHERE EXISTS" utilice whereExists()

Ej:

	$rows = DB::table('products')
    ->whereExists('(SELECT 1 FROM users WHERE products.belongs_to = users.id AND users.lastname = ?)', ['AB']);

Lo anterior generá un SQL como:

	SELECT * FROM products WHERE EXISTS (SELECT 1 FROM users WHERE products.belongs_to = users.id AND users.lastname = 'AB');


# selectRaw

Por lo general cuando se desea usar un alias a un campo es necesario hacer algo como

	$vals = DB::table('products')
	->setFetchMode('COLUMN')
	->selectRaw('cost * 1.05 as cost_after_inc')->get();

O lo mismo pero con parámetros 

	$vals = DB::table('products')
	->setFetchMode('COLUMN')
	->selectRaw('cost * ? as cost_after_inc', [1.05])->get();

# havingRaw

En general las funciones raw permiten corregir situaciones donde es muy difícil expresar con el query builder exactamente lo que queremos o bien este falla en construir algo con la sintáxis correcta para el motor de base de datos que estamos utilizando.

Ej:

	$rows = DB::table('products')
	->deleted()
	->groupBy(['name'])
	->having(['c', 3, '>'])
	->select(['name'])
	->selectRaw('COUNT(*) as c')
	->get();

Podría ser traducido a SQL como:

	SELECT 
	COUNT(*) as c, 
	name 
	FROM 
	products 
	GROUP BY 
	name 
	HAVING 
	products.c > 3;

Lo cual no es totalmente válido y en MySQL genera el error:

	Uncaught PDOException: SQLSTATE[42S22]: 
	Column not found: 1054 Unknown column 'products.c' in 'having clause'

La solución en este caso viene de la mano de havingRaw()

	$rows = DB::table('products')
	->deleted()
	->groupBy(['name'])
	->select(['name'])
	->selectRaw('COUNT(*) as c')
	->havingRaw('c > ?', [3])
	->get();

Generando esta vez un SQL correcto:

	SELECT 
	COUNT(*) as c, 
	name 
	FROM 
	products 
	GROUP BY 
	name 
	HAVING 
	c > 3;


Hay situaciones que son para usar havingRaw() pero el Query Builder hace la conversión internamente de having() a havingRaw() aunque tiene un costo en rendimiento y se pierde cierto control de la Query formada.

Ej:

	DB::table('products')
	->select(['size'])
	->selectRaw('AVG(cost)')
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->get();

En este caso el primer parámetro no es un campo sino que hay una función aplicada sobre un campo e internamente se ejecutará como:

	DB::table('products')
	->select(['size'])
	->selectRaw('AVG(cost)')
	->groupBy(['size'])
	->havingRaw('AVG(cost) >= ?', [150])
	->get();

Es posible forzar el uso de havingRaw() cuando sea necesario con setStrictModeHaving(true)

Ej:

	DB::table('products')		
	->setStrictModeHaving(true)
	->select(['size'])
	->selectRaw('AVG(cost)')
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->get();

Ya con el modo estricto activado se generará una excepción:

	PHP Fatal error:  Uncaught Exception: Use havingRaw() instead for AVG(cost) >= ?


# when

El método when() simplifica la creación de queries condicionales y generalmente se usa en conjunto con where() o sus variantes.

Veamos un snipet extraido del propio core del framework escrito sin when() y luego con when() 

-- sin when()

	$m = DB::table('migrations');

	if ($to_db == '__NULL__'){
		$m->whereNull('db');
	} else {
		$m->where(['db' => $to_db]);
	}
			
	$filenames = $m->orderBy(['created_at' => 'DESC'])
	->pluck('filename');

El método when() tiene tres parámetos: la condición y dos callbacks de los cuales el primero se aplica si la condición es verdadera y la segunda si es falsa.

-- con when()

	$filenames = DB::table('migrations')
	->when($to_db == '__NULL__', 
		function($q){
			$q->whereNull('db');
		},
		function($q) use($to_db){
			$q->where(['db' => $to_db]);
		}
	)
	->orderBy(['created_at' => 'DESC'])
	->pluck('filename');


# Grupos

Para colocar paréntesis en el WHERE del SQL resultante usando el Query Builder existen los "grupos" implementados con el método group()

Ej:

	DB::table('xxxx')
	->group(function($q){
		$q->where(condA)
		->orWhere(condB)
	})
	->where(condC);


Lo anterior en el WHERE de arma algo como

	WHERE (A OR B) AND C

Veamos otro ejemplo:

	DB::table('xxxx')
	->where(condC)
	->group(function($q){
		$q->where(condA)
		->orWhere(condB)
	});

Lo anterior equivale a tener en el WHERE algo como

	WHERE C AND (A OR B)


La diferencia es que en último caso se está suponiendo que el operador que queremos usar para conectar el grupo con la primera condición (C) es un 'AND' pero podría no ser el caso por lo que se dispone de grupos especiales llamados "conectores" donde se explicita el operador de la conjunción:

Conectores:

	and()
	or()
	andNot()
	orNot()

Ej:
	A OR (B AND C)


En pseudo-código (ver como se usa la función where) sería algo así:	

	DB::table('xxxx')
	->where(condA)
	->or(function($q){
		$q->where(condB)
		->where(condC);
	})

o ..

	DB::table('xxxx')
	->where(condA)
	->or(function($q){
		$q->where([
			condB,
			condC
		]);
	})


Es importante tener en cuenta que se abren paréntesis hacia el lado derecho solamente con lo cual,

	DB::table('xxxx')
	->where(condA)
	->where(condB)
	->or(function($q){
		$q->where([
			condC
		]);
	})


Genera en SQL una expresión del tipo "A AND B OR C" y *no* "(A AND B) OR C". En caso de estar buscándo lo anterior podría hacerse de la siguiente manera:

	DB::table('xxxx')
	->where([
			condA,
			condB
	])
	->or(function($q){
		$q->where([
			condC
		]);
	})

Otra opción, más general, es usar un grupo también para "agrupar" las condiciones A y B

	DB::table('xxxx')
	->group(function($q){
		$q->where(condA)
		$q->where(condB);
	])
	->or(function($q){
		$q->where([
			condC
		]);
	})


Ejemplo funcional de operadores OR / AND anidados en WHERE con group()

	$m = DB::table('products')

	->group(function($q){  
		$q->where([
			['cost', 100, '>'],
			['id', 50, '<']
		]) 
		// OR
		->orWhere([
			['cost', 100, '<='],
			['description', NULL, 'IS NOT']
		]);  
	})
	// AND
	->where(['belongs_to', 150, '>'])
	
	->select(['id', 'cost', 'size', 'description', 'belongs_to']);

	dd($m->get()); 


Los grupos / conectores aplican también a having() y havingRaw()

Ej:

	DB::table('products')->deleted()

	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->orderBy(['size' => 'DESC'])
	->get(['cost', 'size', 'belongs_to']); 


# Restricciones que aplican para having() y havingRaw()

Puede -según sea el caso- que having() y havingRaw() no sean combinables en la misma query y que de ser necesario el uso de havingRaw() entonces todo lo que corresponda a HAVING deba realizarse con *unico* havingRaw().


# Qualificación de campos

Por defecto todos los campos son auto-qualificados como tabla.campo o si hay un alias para la tabla como alias.campo en la query construida. Esto obviamente tiene cierto impacto de performance pero es el comportamiento por defecto dado que evita posibles colisiones de nombres cuando hay JOINs.

Puede desactivarse la auto-qualificación con el método dontQualify()

Ej:

	$m = DB::table('products')
	->groupBy(['cost', 'size'])
	->having(['cost', 100])
	->select(['cost', 'size']);

	dd($m->dd());  

Produce:

	SELECT 
	products.cost, 
	products.size 
	FROM 
	products 
	WHERE 
	products.deleted_at IS NULL 
	GROUP BY 
	products.cost, 
	products.size 
	HAVING 
	products.cost = 100;

Mientras que,

	$m = DB::table('products')
	->dontQualify()
	->groupBy(['cost', 'size'])
	->having(['cost', 100])
	->select(['cost', 'size']);

	dd($m->dd());  

Produce:

	SELECT 
	products.cost, 
	products.size 
	FROM 
	products 
	WHERE 
	products.deleted_at IS NULL 
	GROUP BY 
	products.cost, 
	products.size 
	HAVING 
	products.cost = 100

Para cambiar el flag en sentido contrario se puede utilizar el método doQualify()


# Update

El update se realiza con el método update() que recibe como parámetro un array asociativo con los campos a modificar:

Ej:
	$affected_rows = DB::table('users')
	->where([
		'firstname' => 'HHH', 
		'lastname' => 'AAA'
	])
	->update([
		'firstname'=>'Nico', 
		'lastname'=>'Buzzi'
	]);
    

Es posible solo "tocar" la fecha de actualización de un registro sin modificar nada más con el método touch()

Ej:

	DB::table('products')
	->find(145)
	->touch();


### La clase DB

La clase DB es una librería clave cuyo rol principal es manejar las conexiones de base de datos y ofrecer información sobre las mismas. Posee además un mini Query Builder para consultas "raw".


# Obtención de información de drivers

Método DB::driver()							devuelve driver de la conexión actual
Método DB::driverVersion(bool $numeric)		devuelve la versión del driver			
Método DB::isMariaDB()						devuelve si es MariaDB

Ej:

	dd(DB::driver(), 'Driver');
	dd(DB::driverVersion(), 'Driver version');
	dd(DB::driverVersion(true), 'Driver version (num)');
	dd(DB::isMariaDB(), 'Is MariaDB');

El resultado será algo como:

	--[ Driver ]-- 
	mysql

	--[ Driver version ]-- 
	5.7.35-0ubuntu0.18.04.2

	--[ Driver version (num) ]-- 
	5.7.35

	--[ Is MariaDB ]-- 
	false


### Ejecución de "consultas crudas"

Las consultas puramente crudas son aquellas que son un simple string en SQL que pueden contener los "?" para los parámetros en caso de que las consultas o sentencias sean preparadas. 

# select

Se dispone del método DB::select()()

Ej:

	$res = DB::select('SELECT * FROM products');

O pasando parámetros:

	$res = DB::select('SELECT * FROM products WHERE cost > ? AND size = ?', [550, '1 mm']);

Un ejemplo completo donde se genera una query cruda y luego se ejecuta:

	$m = DB::table('products')
	->dontBind()    
	->dontExec()    
	->select(['size', 'cost'])
	->groupBy(['size'])        
	->having(['cost', null, '>='])
	->having(['size' => null]);

	$sql = $m->toSql();

	dd(DB::select($sql, [5, '1L']));
	dd($sql, 'pre-compiled SQL');
	dd(DB::getLog(), 'Excecuted SQL');

# insert

Para la inserción de registros de forma "cruda" existe el método DB::insert()

Ej:

	$id = DB::insert('insert into baz (id_baz, name, cost) values (?, ?, ?)', [100, 'cool thing', '16.25']);
    dd(DB::getLog(), 'Excecuted SQL');

Ej:

	$id = DB::insert('insert ignore into `baz2` (id_baz2, name, cost) values (?, ?, ?)', [5000, 'cool thing', '16.25']);
	dd(DB::getLog(), 'Excecuted SQL');

La función intenta encontrar la PRIMARY KEY de la tabla para así devolver el 'id' y a tal fin revisa si existe un archivo de schema creado y sino lo encuentra intenta con 'id' como nombre para la PRIMARY KEY.


# update

Para la actualización en crudo de datos se dispone del método DB::update()

Ej:

	$affected_rows = DB::update('update `baz2` SET name = ?, cost = ? WHERE id_baz2 = ?', ['something', '99.99', 5000]);


# delete

Similarmente se dispone del método DB::delete()

Ej:

	$affected_rows = DB::delete('DELETE FROM `baz2` WHERE id_baz2 = ?', [5000]);


# statement

Finalmente existe un método genérico para ejecutar "raw" statements o sea, comandos SQL que no son de tipo consulta o sea distintos de select.

Ej:

	$affected_rows = DB::statement('DELETE FROM `baz2` WHERE id_baz2 = ?', [5000]);


Nota: 

Las funciones "raw" de la clase DB admiten un parámetro para el tenant_id y en caso de tener que cambiar la conexión al finalizar la conexión original es restaurada.

Ej:

	dd(DB::getCurrentConnectionId());

	$res = DB::select('SELECT * FROM my_table', [], null, 'conn_2');

	dd(DB::getCurrentConnectionId());


# Procedimientos almacenados

Para la ejecución de procedimientos almacenados se puede sacar ventaja de los métodos "raw" de la clase DB, en particular:

DB::statement()         para ejecución de sentencias que no devuelven resultado
DB::select()            para la ejecución de sentencias que devuelven resultado

En los siguientes ejemplos se usará la keyword "CALL" presente en MySQL pero se entiende que deba usarse la equivalente según el RDBMS donde en SQLSRV por ejemplo es "EXEC".

Ej:

    DB::statement("CALL insertEvent('?')", ['2012.01.01 12:12:12']);

Y para el caso de un DB::select()

Ej:

    $price = DB::select('CALL productpricing()');

O si contuviera algún parámetro como por ejemplo el id de categoría:

Ej:

    $price = DB::select('CALL productpricing(?)', [34]);

Además es posible especificar el "modo" en el que se traen los resultados ("ASSOC", "NUM", ...) que se corresponden a los de PDO:

Finalmente tanto DB::statement() como DB::select() permiten pasar el id de la conexión en el último parámetro


# Transacciones

La forma básica de crear una transacción con su "roll back" en caso de fallo tiene la siguiente estructura:

	DB::beginTransaction();

	try {

		// ...
		// ...
		
		DB::commit(); 

	}catch(\Exception $e){
		DB::rollback();

		dd($e->getMessage(), "Error en transacción");
	}	

Ej:

	DB::beginTransaction();

	try {
		$name = '';
		for ($i=0;$i<20;$i++)
			$name .= chr(rand(97,122));

		$id = DB::table('products')->create([ 
			'name' => $name, 
			'description' => 'bla bla bla', 
			'size' => rand(1,5).'L',
			'cost' => rand(0,500),
			'belongs_to' => 90
		]);   

		//throw new \Exception("AAA"); 

		DB::commit();

	} catch (\Exception $e) {
		DB::rollback();
		throw $e;
	} catch (\Throwable $e) {
		DB::rollback();            
	}            

Cabe notar que se olvidara colocar el DB::beginTransaction() se producirá el error "There is no is_active transaction".

Una forma más conveniente de realizar transacciones es usando una función anómima con transaction()

	DB::transaction(function(){
		// operación sobre la base de datos   
		// operación sobre la base de datos 
		// operación sobre la base de datos 
	}); 

Ej:

	DB::transaction(function(){
		$name = '';
		for ($i=0;$i<20;$i++)
			$name .= chr(rand(97,122));

		$id = DB::table('products')->create([ 
			'name' => $name, 
			'description' => 'Esto es una prueba', 
			'size' => rand(1,5).'L',
			'cost' => rand(0,500),
			'belongs_to' => 90
		]);   
	});     


Output mutators

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->get();

Transformers 

	$t = new UsersTransformer();

	$rows = DB::table('users')
	->registerTransformer($t, $this)
	->get();

otro ejemplo:

	$t = new \simplerest\transformers\ProductsTransformer();

	$rows = DB::table('products')
	->where(['size'=>'2L'])
	// ...
	->registerTransformer($t)
	->get();

Son combinables transformers con output mutators:

	$t = new \simplerest\transformers\UsersTransformer();

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->registerTransformer($t)
	->get();



# Fetch modes 

Los modos de obtención de datos pueden setearse  en cualquera de los casos mediante el método setFetchMode() antes de llamar a un método final como get(), first(), min(), avg(), etc 

Ej:

	dd((new BarModel())
	->connect()
	->setFetchMode('ASSOC')
	->get());


# Debuguear una query (desde el controlador)

Hay varios métodos para hacer un debug de una query comenzando por DB::dd() que ocupa el lugar del método get()

Ejemplo:

	$res = DB::table('products')
		->groupBy(['name'])
		->having(['c', 3, '>='])
		->select(['name'])
		->selectRaw('COUNT(name) as c')
		->get());

var_dump($res);

Reemplazando ->get() por ->dd()

	$res = DB::table('products')
		->groupBy(['name'])
		->having(['c', 3, '>='])
		->select(['name'])
		->selectRaw('COUNT(name) as c')
		->dd());

var_dump($res);

Resultado:

	SELECT AVG(cost), size FROM products WHERE deleted_at IS NULL GROUP BY size HAVING AVG(cost) >= 150

El problema del método dd() es que no funciona si en su lugar hay una función get() parametrizada -en vez de usar select()- o bien una función agregativa comon min(), max(), count(), sum() y avg() 

Otra función de debug, disponible cuando se usa DB::table() es DB::getLog()

Ejemplo:

	$c = DB::table('products')
		->where([ 'belongs_to'=> 90] )
		->count('*', 'count');

	dd(DB::getLog());


Nota:

Para que DB::getLog() arroje la query estaba debe haber sido "armada" algo que sucede cuando se "compila" al ejecutar funciones como get(), first(), pluck() .... o dd()

	$m = DB::table('products')
	->where(['size', ['0.5L', '3L'], 'NOT IN']);

	// Nada
	dd(DB::getLog());

Sin embargo lo siguiente *SI* devuelve la query:

	$m = DB::table('products')
	->where(['size', ['0.5L', '3L'], 'NOT IN']);

	$m->dd();
	dd(DB::getLog());
    
Lo siguiente también sirve:

	DB::table('products')
	->where(['size', ['0.5L', '3L'], 'NOT IN'])
	->dontExec()
	->dontBind()
	->get();

	dd(DB::getLog());
	

# Obtención de la query pre-compilada

Una función de debug que puede utilizarse es getLastPrecompiledQuery(), la cual devuelve el último query antes de ser bindeado con los parámetros -aunque per se no evita el binding-.

Ejemplo:

	$uno = DB::table('products')->deleted()
	->select(['id', 'name', 'description', 'belongs_to'])
	->where(['belongs_to', 90]);

	$m2  = DB::table('products')->deleted();
	$dos = $m2
	->select(['id', 'name', 'description', 'belongs_to'])
	->where(['belongs_to', 4])
	->where(['cost', 200, '>='])
	->union($uno)
	->orderBy(['id' => 'ASC'])
	->get();

	dd($m2->getLastPrecompiledQuery());

En cualquier caso es posible realizar un debug *sin* ejecutar la consulta con el método dontExec() y mediante el método dontBind() evitar el "bindeo" de parámetros. Esto podría ser útil para armar una sub-query.

Ejemplo:

	$res = DB::table('products')
	->dontBind()   // <--- here 
	->dontExec()   // <--- here 
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->select(['size'])
	->selectRaw('AVG(cost)')
	->get();

	dd(DB::getLog());

También podemos evitar se cree una conexión a la base de datos pasando false como tercer parámetro a DB::table() y finalmente si nuestro interés es obtener la consulta pre-compilada o sea armada pero aún con los parámetros sin bindear podemos llamar a toSql().

Ej:

	$m = DB::table('products', null, false)
	->where(['belongs_to', null])
	->group(function($q){
		$q->where(['size', null])
		->orWhere([
			['cost', null, '<='],
			['cost', null, '>=']
		]);
	})
	->whereRaw('cost < IF(size = "1L", ?, 100) AND size = ?', [null, null])
	->orderBy(['cost' => 'ASC']);

	$sql = $m
	->dontBind()
	->toSql();
	
	dd($sql);

Si desea realizar pruebas de performance remítase en la documentación a Time::exec()


# Parámetros para binding

Los parámetros a ser bindeados pueden recuperarse también con getLastBindingParamters()

Ej:

	$m = DB::table('products');

	$m->where(['size', ['0.5L', '3L'], 'NOT IN'])
	->dontExec()
	->dontBind()
	->get();
	
	$q = $m->toSQL();
	$params = $m->getLastBindingParamters();

	d($q);
	d($params);


Como si fueran pocas funciones de debug existe el método Model::getLog()

	$model = new \simplerest\core\Model($conn);
	$res = $model->create(['name' => 'Jhon', 'age' => 32]);
	dd($model->getLog());
	

# Debuguear una query (desde el propio modelo)

Es posible usar hooks sobre el modelo para debuguear una query. Por ejemplo si se desea debuguear un create ("INSERT INTO") sería así:

	class XXXXXModel extends Model
	{ 
		// ...

		function onCreated(array &$data, $last_inserted_id)
		{
			dd($this->dd());
		}
	}

Si la query falla entonces solo simule que se ejecuta usando el método dontExec() así: 

	class XXXXXModel extends Model
	{ 
		// ...

		function onCreating(array &$data)
		{
			$this->dontExec();
		}

		function onCreated(array &$data, $last_inserted_id)
		{
			dd($this->dd());
		}
	}


En el caso particular de los INSERTs es posible que Model::dd() no reemplace los parámetros y los deje como "preparados" obtieniendo algo como:

    INSERT INTO my_table (
      column1, column2
    ) 
    VALUES (
        :column1, :column2
    )

Entonces se puede obtener por separado los parámetros recibidos para el binding con Model::getLastBindingParamters()

Ej:

    function onCreating(array &$data)
    {
        $this->dontExec();  
    }

    function onCreated(array &$data, $last_inserted_id)
    {
        dd($this->dd(), 'SQL');
        dd($this->getLastBindingParamters(), 'PARAMETERS');
    }


# Formateo de las queries

Con fines de debugging se utiliza por defecto un paquete que formatea las queries SQL en la mayor parte de los casos aunque no es perfecto y puede querer desactivarse o parametrizarse de otra manera.

En MyModel podría hacerse:

	function __construct(bool $connect = false, $schema = null, bool $load_config = true){
        parent::__construct($connect, $schema, $load_config);

		static::$sql_formatter_callback = function(string $sql){
      		return MySqlFormatter($sql);
    	};
    }

O bien

	function __construct(bool $connect = false, $schema = null, bool $load_config = true){
        parent::__construct($connect, $schema, $load_config);
	
		$this->setSqlFormatter(function(string $sql){
			return MySqlFormatter($sql);
		});
	}

Donde si simplemente quisiera anularse por completo el sql formater bien podría hacerse:

	function __construct(bool $connect = false, $schema = null, bool $load_config = true){
        parent::__construct($connect, $schema, $load_config);

		static::$sql_formatter_callback = null;
    }	


Además es posible activar o des-activar el formateo de queries con los métodos Model::sqlFormaterOn(), Model::sqlFormaterOff() o bien pasándole un boolean a dd()

Producen el mismo resultado:

	echo $m->sqlFormaterOn()->dd();
	echo $m->dd(true);


Algunos ejemplos:

 	/*
        Sql formater habilitado via Model::sqlFormaterOn()
    */

	$m = DB::table('products')
	->deleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		$m
		->sqlFormaterOn()   /* habilito */
		->dd()
	);


    /*
        Sql formater des-habilitado (por defecto)
    */
   
	$m = DB::table('products')
	->deleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd($m->dd());
    

    /*
        Sql formater habilitado via Model::dd()
    */

	$m = DB::table('products')
	->deleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		$m
		->dd(true)
	);


Como Model::sqlFormatter() es un método público y convenientemente estático fácilmente se puede usar fuera del ámbito de la clase. El método es parametrizable y los parámetros pasan directamente al formateador.
    

    /*
        Sql formateador es aplicado en un segundo paso
        y se parametriza para colorizar 
    */

	$m = DB::table('products')
	->deleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		Model::sqlFormatter($m->dd(), true)
	);
    

Se provee de la función helper sql_formater() que es un atajo de Model::sqlFormatter()

    /*
        Sql formateador es aplicado en un segundo paso
        y se parametriza para colorizar pero usando el helper sql_formater 
    */

	$m = DB::table('products')
	->deleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		sql_formater($m->dd(), true)
	);    


#### Campos manejados por el framework

Hay una cantidad de campos (que si están presentes en la tabla y declarados en el schema del modelo) que son manejados directamente por el framework. Consideremos la siguiente tabla:

id 				int(11)		
name			varchar(60)				
is_active		tinyint(4)
belongs_to		int(11)			*	
created_at		datetime		*			
created_by		int(11)			*	
updated_at		datetime		*	
updated_by		int(11)			*	
deleted_at 		datetime		*
deleted_by		tinyint(4)		*
is_locked		tinyint(4)		*

belongs_to		apunta directamente al user_id de quien crea el registro. Si el usuario tiene el permiso especial 'transfer' puede cambiar ese valor y hacer que apunte a otro usuario. Un caso especial son los registros creados dentro de un 'folder'.

created_by 		apunta indefectiblemente al user_id quien creó el registro.
update_by		apunta indefectiblemente al user_id del último usuario que modificó un registro. 
deleted_by		apunta indefectiblemente al user_id que hizo un borrado suave un registro.
created_at 		apunta indefectiblemente a la fecha-hora en que se creó un registro.
updated_at 		apunta indefectiblemente a la fecha-hora en que se modificó por última vez un registro.
deleted_at 		apunta indefectiblemente a la fecha-hora en que se creó un registro.
is_locked 			cuando un registro es mofificado por un usuario con permiso de 'lock' automáticamente se guarda un 1.


Los campos created_by, update_at y deleted_at son rellenados por Model pero al modelo no le compete si hay un sistema de autenticación y que usuario está haciendo el query así que los campos created_by, update_by, deleted_by y belongs_to son manejados a nivel de la API por ApiController al igual que el campo is_locked.

Nota: no olvides que los campos que necesites deben estar en las tablas y en el schema del modelo correspondiente. 


### Mutators

Se presentan casos donde es necesario hacer una transformación de los datos ya sea antes de enviarlos la query o bien antes de guardarlos en base de datos. 

El caso emblemático es cuando se requiere hacer un "hash" del password antes de guardarse ya sea en la creación o edición de un registro. Entonces usaremos un "input mutator".

Ejemplo

class UsersModel extends Model
{ 
	// ...

    function __construct($db = NULL){
		$this->registerInputMutator('password', function($pass){ 
			return password_hash($pass, PASSWORD_DEFAULT); 
		}, function($op, $dato){
			return ($dato !== null);
		});

        parent::__construct($db);
    }
}

El método registerInputMutator() acepta 3 parámetros:

- El campo cuyo contenido se quiere mutar (condicionalmente)
- Un callback que transforma el dato de entrada 
- Un callback (opcional) que determina en que caso se debe aplicar la función de entrada y que es alimentada con el tipo de operación ('UPDATE' o 'CREATE') y el dato de entrada. En caso de omitirse aplica siempre el mutator para ese campo.

El procedimiento es registrar los mutators para cada campo del modelo que los requiera. Otro uso de input mutators es para utilizar UUIDs donde dentro de un Trait podemos tener la funcionalidad de generar el uuid:

	namespace simplerest\traits;

	trait Uuids
	{
		protected function boot()
		{
			parent::boot();

			$this->registerInputMutator('uuid', function($id){ 
				return uuid_create(UUID_TYPE_RANDOM); 
			}, function($op, $dato){
				return ($op == 'CREATE');
			}); 
		}    
	}

<-- Como sería un efecto indeseado que se auto-generara un UUID reemplazando el actual al hacer un UPDATE, entonces ponemos como condición que se aplique solo en el CREATE.	

En el modelo donde queremos implementar el uuid, debemos declar el campo como string, importamos y hacemos el "use" del Trait:

	<?php
	namespace simplerest\models;

	use simplerest\core\Model;
	use simplerest\traits\Uuids;

	class BarModel extends Model 
	{ 
		use Uuids;
		
		function __construct($db = NULL){
			parent::__construct($db);
		}
	}

Recordar actualizar el Schema donde el campo uuid debe ser un string y pertenecer a los nullables.

Output Mutators 

Además de los Input Mutators, tenemos también los *Output Mutators* que permiten aplicar una función sobre la salida de la ejecución de una query. En otros lenguajes / frameworks son conocidos como "accessors".

Ejemplo:

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->get();

Lógicamente un Output Mutator sobre un campo no es compatible con declarar a ese mismo campo como "hidden". 

Los mutators de salida pueden aplicarse incluso cuando hay funciones agregativas y las cláusulas GROUP BY y HAVING. 

Ejemplo:

	rows = DB::table('products')
	->registerOutputMutator('size', function($str){ return strtolower($str); })
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->select(['size'])
	->selectRaw('AVG(cost)')
	->get();


### Transformers

Los transformers se aplican a la salida de la ejecución de una query y en orden después de los "output mutators" si los hubiere.

Una transformación permite (a diferencia de un output mutator) no solo aplicar funciones sobre la salida de cada campo sino también crear campos virtuales, eliminar campos o cambiarles el nombre.

Ejemplo:

	class UsersTransformer 
	{
		public function transform(object $user, Controller $controller = NULL)
		{
			return [
				'id' => $user->id,
				'username' => $user->username,
				'is_active' => $user->is_active,
				'email' => $user->email,
				'confirmed_email' => $user->confirmed_email,
				'password' => $user->password,
				'firstname' => 'Mr. ' . $user->firstname,
				'lastname' => $user->lastname,
				'full_name' => "{$user->firstname} {$user->lastname}",
				'deleted_at' => $user->deleted_at,
				'belongs_to' => $user->belongs_to
			];
		} 
		
		//...

Si un campo del SCHEMA no está presente desaparece de la salida (en caso de estar presente) y si se asigna con otra key, su nombre será otro. Ejemplo:

	family_name' => $user->lastname
	
Es importante destacar que no funciona si hay funciones agregativas presentes en la query y tampoco sirve para cambiar datos accediendo por un campo virtual por ejemplo.

Al registrar un transformer cualquier campo oculto se vuelve visible aunque cabe recordar que sino está presente como key del array devuelto desaparece.

Es posible acceder a propiedades del controller que invocó al transformer, ejemplo:

	class UsersTransformer 
	{
		public function transform(object $user, $controller = NULL)
		{
			return [
				'id' => $user->id,
				//...
				'password' => $controller->is_admin ? $user->password : false,
			];
		}
	}

Y ahora en un Controller paso $this como segundo parámetro a registerTransformer() para brindar acceso a las propieades del controlador:

	$t = new \simplerest\transformers\UsersTransformer();

	$rows = DB::table('users')
	->registerTransformer($t, $this)
	->get();

	dd($rows);

En el ejemplo si el controller tiene un campo is_admin (como sucede con los resource controllers en SimpleRest) entonces según el valor mostrará o no el password.
 
Mutators y transformers pueden usarse juntos, ej:

	$t = new \simplerest\transformers\UsersTransformer();

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->registerTransformer($t)
	->get();

	dd($rows);

Nota: de momento los Transformers se han probado desde Controllers y no desde las APIs <-- quizás sea posible usarlos de alguna forma si surge una necesidad real.


### Campos fillables, no-fillables, nullables y ocultos

Se puede definir un array de campos "fillables" aunque por lo general se lo puede dejar en automático. También es posible definir por el contrario, campos a excluir como "no fillables".

	protected $fillable = [
							'email',
							'password',
							'firstname',
							'lastname',
							'deleted_at',
							'belongs_to'
	];

	// o ...
	protected $not_fillable = ['confirmed_email'];

Los campos no-nullables serian los requeridos para las validaciones y se definen de igual modo: 

	protected $nullable = ['id', 'firstname', 'lastname', 'deleted_at', 'belongs_to', 'confirmed_email'];

Por último tenemos los campos ocultos:

	protected $hidden   = [	'password' ];


# Hooks sobre el modelo

Se definen varios event hooks sobre el modelo que se disparan ante una operación CRUD

	protected function onReading() { }
	protected function onRead(int $count) { }

	protected function onCreating(Array &$data) {	}
	protected function onCreated(Array &$data, $last_inserted_id) { }

	protected function onUpdating(Array &$data) { }
	protected function onUpdated(Array &$data, ?int $count) { }

	protected function onDeleting(Array &$data) { }
	protected function onDeleted(Array &$data, ?int $count) { }

	protected function onRestoring(Array &$data) { }
	protected function onRestored(Array &$data, ?int $count) { }

Como regla general los nombres de eventos que terminan en -ing se envían antes de que se conserven los cambios en el modelo, mientras que los eventos que terminan en -ed se envían después de que se conserven los cambios en el modelo.

Un uso práctico de estos eventos es para des-confirmar un email cuando se ha cambiado. En este caso se hace uso de la función isDirty() que acepta como parámetro el campo que necesitamos saber si ha cambiado.

	protected function onUpdating($data) {
		if ($this->isDirty('email')) {
			$this->update(['confirmed_email' => 0]);
		}	
	}

La función isDirty() acepta un campo o un array de campos o incluso puede estar vacia en cuyo caso verifica si algún campo sería cambiado.

Otro uso práctico sería el uso del evento onReading() para hacer un (inner, left, right, natural, cross,...) JOIN automático para devolver el contenido de tablas relacionadas cada vez que se lea un registro de esa tabla. Así:

class MaestroModel extends Model
{ 
	// ...

	function onReading(){
		$this->leftJoin('detalle');
	}
}

Desde cualquier hook del modelo es posible acceder a propiedades (si son públicas) útiles como $w_vars y $w_vals -entre otras- con las que es posible reconstruir el where.


# Hooks en APIs

Al igual que los modelos, las APIs que extienden a ApiController también tienen varios event hooks

	protected function onGetting($id) { }
    protected function onGot($id, $count){ }

    protected function onDeleting($id){ }
    protected public function onDeleted($id, $affected){ }

    protected function onPosting($id, $data){ }
    protected function onPost($data, $id){ }

    protected function onPutting($id, $data){ }
    protected function onPut($id, $data, $affected){ }


Existen otros hooks en en ApiController relacionados con el acceso a folders.

Uso prácticos de los hooks sobre APIs:

Ej:

	Podríamos querer recibir cierto parámetro por GET o via body y evitar que tener problemas con las valicaciones que hace el framework en particular del ApiController.

	Si el parámetro viene via Body podríamos leer el valor de forma destructiva en el constructor de la clase ApiController derivada con shiftBodyParam() así:

	class Products extends MyApiController
	{ 
		static protected $soft_delete = true;
		static protected $connect_to = [
			'product_categories',
			'users',
			'product_tags',
			'valoraciones',
			'digital_products'
		];

		function __construct()
		{       
			parent::__construct();

			global $my_param;
			$my_param = request()->shiftBodyParam('my_param');
		}        
	} 

Ahora tenemos el parámetro recibido como variable "global" y podremos usarlo en un hook de la misma API como onPost()

Ej:

	protected function onPost($data, $id){
		// acá está disponible $my_param
	
		DB::statement("EXEC sp_zyz()", [$id, $my_param]);
	}

Una derivación del ejemplo anterior es cuando necesitamos recibir el valor en el modelo ya sea de la entidad de la API o de un sub-recurso. Entonces podríamos dejar disponible el valor recibido usando la variable superglobal $GLOBALS o bien mediante alguna variable o propiedad estática.

Ej:

class Products extends MyApiController
	{ 
		static protected $soft_delete = true;
		static protected $connect_to = [
			'product_categories',
			'users',
			'product_tags',
			'valoraciones',
			'digital_products'
		];

		function __construct()
		{       
			parent::__construct();
			$GLOBALS['my_param'] = request()->shiftBodyParam('my_param');
		}        
	} 

y en el modelo:

	protected function onCreated(Array $data, ?int $count) {

		// acá está disponible $GLOBALS['my_param]
	
		DB::statement("EXEC sp_zyz()", [$id, $GLOBALS['my_param']]);
	}

De igual forma si el parámetro viniera por GET entonces puede leerse de forma destructiva con Request::shiftQuery()

Ej:

	$my_param = request()->shiftQuery('my_param');


# Hooks sobre el módulo de autenticación

La clase AuthController provee varios hooks que pueden usarse en MyAuthController

	function onRegister($data){ }
    function onRegistered($data, $uid, $is_active, $roles){ }
    function onRemember($data){}
    function onRemembered($data, $link_url){}
    function onLogin($data){}
    function onLogged($data, $uid, $is_active, $roles, $perms){}
    function onImpersonated($data, $uid, $is_active, $roles, $perms, $impersonated_by){}	
    function onChecked($uid, $is_active, $roles, $perms, $auth_method){}
    function onConfirmedEmail($uid, $roles, $perms){}
    function onChangedPassword($uid, $roles, $perms){}

    function getDbAccess($uid) : Array { return []; }


# Cómo recuperar datos de usuario

Es posible que Ud. necesite recuperar los datos del usuario (nombre, username, etc) en el hook onRemembered() y esto puede hacerse más o menos así:

	function onRemembered($data, $link)
    {
        $u = get_user_model_name();
        $m = new $u();

		/*
			User data
		*/
        $userdata = ($m)
        ->where([$u::$email => $data['email'] ])
        ->first();

		// ...
	}

En otros casos (no este), Ud. podría querer recuperar información del usuario en base a su UID.

Ej:

	// Solo válido para un usuario autenticado
	$uid = Acl::getCurrentUid();

	DB::getDefaultConnection();

	$u = get_user_model_name();
	$m = new $u();

	$uid_field = $m->getSchema()['id_name'];

	/*
		User data
	*/
	$userdata = ($m)
	->where([$uid_field => $uid ])
	->first();

	d($userdata);

O incluso mucho más fácil, usando el método find()

	// Solo válido para un usuario autenticado
	$uid = Acl::getCurrentUid();

	DB::getDefaultConnection();

	$u = get_user_model_name();
	$m = new $u();

	$uid_field = $m->getSchema()['id_name'];

	/*
		User data
	*/
	$userdata = ($m)
	->find($uid)
	->first();

	d($userdata);


# Comunicación "realtime" via eventos 

SimpleRest implementa comunicación en tiempo real via dos mecanismos:

	Server -> Front:  via Server-Sent Events (SSE) via librería SSE.
	Server -> Server: via WebHooks

### Webhooks

Las APIs reversas o webhooks son un mecanismo que evita tener que andar preguntando a un endpoint si un registro fue creado o actualizado. SimpleRest permite crearlos de forma muy sencilla.

Los webhooks se crean via POST como cualquier otro recurso:

	POST /api/v1/hooks 

	{
		"name": "musk-cryptos", <nullable>
		"entity": "twitts",
		"op": "create"			
		"conditions": "account=eleonmusk&body[containsWord]=BTC,bitcoin,doge,crypto"
		"callback": "http://hexagon-alerts.lan/feed-reaction"
	} 

Existen 5 tipos de eventos u "operaciones" a las que reacciona un webhook: "create", "show", "list", "update" y "delete"

Las condiciones son opcionales pero sino las hay entonces se disparará el evento de forma incondicional cada vez que se cree, muestre, liste, actualice o borre un registro.

El webhook se ejecuta *después* de la operación u evento así que si el registro fue borrado físicamente (no hay softdelete) no habrá forma de chequear la condición si se hubiera especificado y tampoco de devolver el registro. 

Para el evento de listado no se chequea por condiciones ya que implicaría revisar cada registro y sería muy costoso.

Los valores que se buscan en las condiciones para el caso de un update son los actualizados así por ejemplo si se acutalizó un campo "categoría" se reaccionará al nuevo valor y no al viejo que pudiera contener.


El callback apunta a donde es procesador el request (también un POST ya que lleva body) y éste puede ser tan sencillo como:

	    if ($_SERVER['REQUEST_METHOD'] != 'POST'){
            exit;
        }

        $body = Factory::request()->getBody(false);
        Files::logger($body);
    
Notar que no tendría sentido hacer un volcado hacia la salida estándar ya que el procesamiento ocurre en background.

Los operadores implementados son los mismos que para el ApiController más alguno adicional:

	'eq', 'gt', 'gteq', 'lteq', 'lt', 'neq', 'in', 'notIn', 'contains', 'notContains', 'startsWith', 'notStartsWith', 'endsWith', 'notEndsWith', 'containsWord', 'notContainsWord', 'between', 'notBetween'

El operador "in" es opcional siendo equivalentes:

	categoria[in]=7,8,22 
y
	categoria=7,8,22

Del mismo modo, 'contains', 'notContains' y 'containsWord', 'notContainsWord' aceptan varios valores delimitados por coma. El operador implícito es un OR.


### Validaciones

El framework incluye un validador que está integrado a nivel de la API Rest y puede también incluirse a nivel de los modelos o bien usarse de forma aislada.

Para mostrar el funcionamiento de la clase Validator consideremos el siguiente ejemplo donde usamos directamente la clase validator para procesar errores de un formulario por ejemplo:

	$data = [
				'nombre'=>'Pablo1',
				'apellido'=>'Bz',
				'segundo_apellido'=>'San Martín',
				'usuario'=>'',
				'celular'=>'321530', 
				'correo'=>'a@b',
				'calle'=>'0',
				'numero_de_casa'=>'',
				'observaciones'=>'la vida es complicada y bla bla bla bla bla bla bla',
				'fecha'=>'32-09-2019',
				'hora'=>'24:00:17',
				'rol'=>'',
				'fuerza'=>'100.xxx',
				'estrato'=>'3',
				'felicidad'=>'0.25',
				'energia'=>'.25',
				'hora_almuerzo'=>'13:30:00',
				'hora_cena'=>'18:00:00',
				'fecha_nac'=>'10-12-1902',
				'frutas_favoritas'=>['bananas','manzanas']  // podria provenir de un grupo de checkboxes
				
	];

	$rules = [
				'nombre' 			=> ['type'=>'alpha','required'=>true],
				'apellido' 			=> ['type'=>'alpha','required'=>true,'min'=>3,'max'=>30],
				'segundo_apellido'	=> ['type'=>'alpha','required'=>true,'min'=>3,'max'=>30],
				'usuario' 			=> ['required'=>true,'min'=>2,'max'=>15],
				'celular' 			=> ['type'=>'regex:/^[0-9]{10}$/','required'=>true],
				'correo' 			=> ['type'=>'email','required'=>true], 
				'calle' 			=> ['type'=>'int','required'=>false, 'min'=>1],
				'numero_de_casa'    => ['type'=>'numeric','required'=>false],
				'observaciones' 	=> ['type'=>'string','max'=>40],
				'fecha' 			=> ['type'=>'date'], 
				'hora' 				=> ['type'=>'time'], 
				'rol' 				=> ['type'=>'int','required'=>false], 
				'fuerza' 			=> ['type'=>'decimal','required'=>false],
				'estrato' 			=> ['type'=>'int','required'=>false, 'min'=>1, 'max'=>6],
				'felicidad' 		=> ['type'=>'int','required'=>false, 'min'=>0, 'max'=>100],
				'energia' 			=> ['type'=>'decimal','required'=>false, 'min'=>0, 'max'=>100],
				'hora_almuerzo' 	=> ['type'=>'time','min'=>'11:00:00','max'=>'10:15:00'],
				'hora_cena' 		=> ['type'=>'time','min'=>'19:00:00','max'=>'22:30:00'],
				'fecha_nac' 		=> ['type'=>'date','min'=>'01-01-1980','max'=>'12-12-2018'],
				'frutas_favoritas' 	=> ['type'=>'array','min'=>3]
				
	];

	$validado = (new Validator())->validate($rules,$data);

	if ($validado !== true)
		var_dump($validado);

La salida en caso de fracaso es un array conteniendo las reglas rotas para cada campo:

	array(14) {
	["nombre"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(10) "Sebastian1"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(11) "no es alpha"
		}
	}
	["usuario"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(0) ""
		["error"]=>
		string(8) "required"
		["error_msg"]=>
		string(20) "usuario es requerido"
		}
	}
	...	
	["frutas_favoritas"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		array(2) {
			[0]=>
			string(7) "bananas"
			[1]=>
			string(8) "manzanas"
		}
		["error"]=>
		string(3) "min"
		["error_msg"]=>
		string(18) "mínimo 3 opciones"
		}
	}
	}

### Tipos

Los tipos (type) admitidos son:

bool
int
float
number
decimal(n,m)
string
alpha
notnum
email
date
datetime (compatible con DATETIME de SQL)
time
array
regex:/expresión/

El tipo 'time' es 'H:i:s' y el 'date' es 'd-m-Y' aunque siempre es posible crear un tipo personalizado con una expresión regular que se ajuste a las necesidades.


### Validaciones en los modelos

Para efectuar la validación sobre las operaciones CRUD con los modelos es tan simple como incluir una instancia de la clase Validator:

	$u = DB::table('products')->setValidator(new Validator());
	$rows = $u->where(['cost' => '100X', 'belongs_to' => 90])->get();

El validador es alimentado con los tipos del $schema y es complementado con un array $rules que puede estar presente opcionalmente en cada modelo.

La clase Validator implementa la interfaz IValidator proveyendo un método validate() que recibe un array de reglas a validar, un array asociativo con los datos y opcionalmente un array de campos sobre los que se deben saltear las validaciones.

	mixed : validate(array $rules, array $data, array $ignored_fields = null, bool $as_string = false)

El método validate() devuelve TRUE si no detectó reglas rotas y caso contrario devolverá un array con los errores como vimos previamente.

Es posible desactivar el chequeo de campos requeridos para todos los campos llamando al método setRequired(false).

Ejemplo:

	$data  = [ ..., ... , ...];
	$rules = [ ..., ... , ...];

	$validado = (new Validator())->setRequired(false)
	->validate($rules,$data);


### Constraints

La clase Validator admite las siguientes restricciones:

required 	# el campo es requerido
type 		# por tipo incluidos nuevos tipos creados con expresiones regulares
min 		# valor mínimo o longitud mínima para un string
max			# valor máximo o longitud máxima para un string
in 			# el valor debe estar dentro de un array de valores
between		# el valor debe estar entre dos valores; es un rango que incluye ambos extremos


### Mensajes personalizados

Para cualquier restricción es posible crear un mensaje personalizable (traducible con i18n) para el error en caso de que falle. 

Los mensajes se crean para cualquier restricción como required, type, min, max, in o between

Ejemplo:

	protected $rules = [
		'id 			=> ['type' => 'int', 'required' => true]
        'name' 			=> ['min'=>3, 'max'=>40],
		'description' 	=> ['max'=>50],
		'size' 			=> ['max'=>20],
		'workspace'		=> ['max'=>20],
		'is_active'		=> ['type' => 'bool', 'messages' => [ 'type' => 'Value should be 0 or 1'] ]
	];

Es posible utiliza una sintaxis mucho más amigable importando la librería ValidationRules. Así en un modelo podríamos tener el constructor:

	$this->addRules((new ValidationRules())
		->field('id')->type('int')->required()
		->field('name')->type('str')->max(40)->min(3)
		->field('description')->type('str')->max(50)
		->field('size')->type('str')->max(20)
		->field('workspace')->type('str')->max(20)
		->field('is_active')->type('bool', 'Value should be 0 or 1')
	);


### El helper db

El helper db (.php) ofrece una cantidad de funciones interesantes relacionadas con base de datos:


# User table & model helpers

get_users_table()

	Returns the table for users which is specified in config.php

get_user_model_name()

	Gets namespace-qualified model name corresponding to the users table specified in config.php


# Model helpers

table()				

	Similar to DB::table() but it does not load the schema for the model so there are no validations.

get_model_name()

	Gets namespace-qualified model name for a given table


# Schema helpers

get_schema_name()

	Gets namespace-qualified schema name for a given table

get_schema()

	Returns the schema for a given table. Result is cached.

in_schema()

	Returns if the given array of properties are in some schema.

get_pivot()	

	Returns an array for a pivot table given two tables in the pivot one.

get_primary_key()

	Returns the primary key for a given table name. If the primary key is compound then it returns the AUTOINCREMENT column. 

get_fks(string $t1, string $t2, ?string $tenant_id = null)

	Returns FK(s) on $t1 pointing to $t2. If there is more than one relationship between tables, then can be more than one FK.


# Relationship analysis helpers

get_rels()

	Returns array with relations for a pair of given tables of an specified type of relation ('1:1', '1:n' or 'n:m'). If the asked relation is not the right one then result can be false or an empty array. Specifically returns false when there is no direct relationship between the tables (case n:m) and it asks if the relationship is 1:1 or 1:n

    If the relation is found, then the returned array has a different structure depending on whether it is a relation n: m or 1:1/1:n. 

get_rel_type()

	Get the type of relationship between two tables.

Ex:

	--[ table valoraciones ]--
	n:m

	--[ table product_categories ]--
	n:1

	--[ table product_tags ]--
	1:n

Please note SimpleRest make a distinction between 1:n and n:1


is_1_1()

	Returns if the relation between two given tables is 1:1

is_1_n()

	Returns if the relation between two given tables is 1:n


is_n_1()

	Returns if the relation between two given tables is n:1

is_n_m()

	Returns if the relation between two given tables is n:m

is_mul_rel()

	Returns if the relation between two given tables can gives multiple rows or not. If rel type is 1:1 or FK is on $t1 (left side) => false


### ACL

La implementación del ACL incluye "roles" y permisos individuales (llamados también "scopes") para cada usuario sobre cada tabla expuesta a través de la API.

# Declaración de roles y sus permisos

Se implentó un ACL centralizado que se configurará en /config/acl.php y requiere ajustar permisos de lectura y escritura sobre el directorio app/security. 

Los siguientes métodos proveen la funcionalidad de declaración:

addRole(string $role_name, $role_id = null)
addRoles(Array $roles)
addInherit(string $role_name, $to_role = null
addResourcePermissions()
addSpecialPermissions(Array $sp_permissions, $to_role = null)
setAsGuest()
setAsRegistered(string $name)

Nota:

Los métodos setAsGuest() y setAsRegistered() se utilizan para definir qué rol tendrá la funcionalidad de "guest" y la de usuario registrado respectivamente. En el caso de setAsGuest() es opcional si el nombre del rol se dejara como "guest".

La estrucuración en la declaración de roles y permisos es muy flexible.

Ej:

	$acl = new Acl();

	$acl->addRole('guest', -1)
	->addResourcePermissions('products', ['read'])

	->addRole('vendedor', 1)
	->addInherit('guest')
	->addResourcePermissions('products', ['write'])
	->addResourcePermissions('foo', ['create', 'list'])

	->addRole('admin', 100)
	->addInherit('guest')
	->addSpecialPermissions(['read_all', 'write_all'])

	->addRole('superadmin', 500)
	->addInherit('admin')
	->addSpecialPermissions(['lock', 'fill_all']);


Y equivale a:

	$acl->addRoles([
		'guest' => -1,
		'vendedor' => 1,
		'admin' => 100,
		'superadmin' => 500
	])	

	->addResourcePermissions('products', ['read'], 'guest')	

	->addInherit('guest', 'vendedor')
	->addResourcePermissions('products', ['write'])	
	->addResourcePermissions('foo', ['create', 'list'])	

	->addInherit('guest', 'admin')
	->addSpecialPermissions(['read_all', 'write_all'])


	->addInherit('admin', 'superadmin')
	->addSpecialPermissions(['lock', 'fill_all']);
	

Cabe notar que los addInherit() deben ir *siempre* antes de los permisos que se quieran agregar al rol heredado. 

El rol de 'guest' debe estar definido con ese nombre o con otro. En caso de que se decida cambiar el nombre del rol guest de 'guest' a otro se debe llamar al método estático setGuest() con el nombre alternativo:

	Acl::setGuest('unregistered');

Además de setear el nombre alternativo es su responsabilidad crear el rol correspondiente con el método addRole()

El Acl genera una representación interna similar a:

	array(4) {
	["guest"]=>
	array(3) {
		["role_id"]=>
		int(-1)
		["sp_permissions"]=>
		array(0) {
		}
		["tb_permissions"]=>
		array(1) {
		["products"]=>
		array(1) {
			[0]=>
			string(4) "read"
		}
		}
	}
	["vendedor"]=>
	array(3) {
		["role_id"]=>
			int(1)
		["sp_permissions"]=>
			array(0) {
			}
		["tb_permissions"]=>
			array(2) {
			["products"]=>
			array(2) {
				[0]=>
				string(4) "read"
				[1]=>
				string(5) "write"
			}
			["foo"]=>
			array(2) {
				[0]=>
				string(6) "create"
				[1]=>
				string(4) "list"
			}
		}
	}
	["admin"]=>
	array(3) {
		["role_id"]=>
		int(100)
		["sp_permissions"]=>
		array(2) {
		[0]=>
		string(8) "read_all"
		[1]=>
		string(9) "write_all"
		}
		["tb_permissions"]=>
		array(1) {
		["products"]=>
		array(1) {
			[0]=>
			string(4) "read"
		}
		}
	}
	["superadmin"]=>
	array(3) {
		["role_id"]=>
		int(500)
		["sp_permissions"]=>
		array(2) {
		[0]=>
		string(8) "read_all"
		[1]=>
		string(9) "write_all"
		}
		["tb_permissions"]=>
		array(2) {
		["products"]=>
		array(1) {
			[0]=>
			string(4) "read"
		}
		["permissions"]=>
		array(2) {
			[0]=>
			string(4) "read"
			[1]=>
			string(5) "write"
		}
		}
	}
	}

Existen dos tipos de permisos que se pueden asignar a los roles:  "resource permissions" y "special permissions".

Los "resource permissions" se aplican sobre las tablas especificadas mientras que los "special permissions" son de caracter más general y definen la posibilidad de realizar ciertas acciones administrativas típicas de un "admin".

Además sobre "resource permissions" existen ciertos permisos "especiales" -no confundir con "special permissions"- que habilitan a leer registros que no le pertenecen al tenedor del rol:  

    show_all	- lee los registros propios y ajenos sobre ese recurso
    list_all	- lista los registros propios y ajenos sobre ese recurso
    read_all	- lista y lee los registros propios y ajenos sobre ese recurso

Estos permisos típicamente se deberían dar a un "guest" para que pueda por ejemplo leer todas las entradas de un blog o las publicaciones de un sitio de ventas. Si por el contrario a un "guest" se le diera un permiso "read" -en vez de "read_all"- entonces podría darse el caso contradictorio de que un "guest" pueda ver las publicaciones de un vendedor y ese mismo vendedor solo pueda ver las suyas propias y no las de otros vendedores.

Por lo anterior se aconseja no dar un permiso "read" a un "guest" sino en todo caso un "read_all" y hacer que directa o interectamente todos los roles deriven de "guest". 

Estos permisos especiales sobre "resource permissions" pueden tener otros usos interesantes como permitirle a un supervisor ver todos los registros de los usuarios y publicaciones de una tienda:

    ->addRole('supervisor', 502)  
    ->addInherit('registered')
    ->addResourcePermissions('users', ['read_all'])  // <--
    ->addResourcePermissions('products', ['read_all'])  // <--


### Permisos

Los permisos sobre los endpoints son en general del tipo CRUD + permiso para listar los recursos: ['show', 'list', 'create', 'update',  'delete']


### Rol de Admin

En lugar de definir de forma monolítica los alcances de un "admin" éste se puede construir a partir de combinaciones de los siguientes permisos especiales asignables a cualquier rol

Ejemplos:

- "lock" - bloquear /besbloquear un registro 
- "lock" - modificar un registro bloqueado
- "lock" - borrar un registro bloqueado. Requiere también de "write_all_trashcan"
- "lock" - borrar definitivamente un registro bloqueado
- "lock" - restaurar (undelete) un registro bloqueado
- "read_all" - acceder a registros de otros usuarios (no incluye los protegidos en folders)
- "read_all" - listar registros de otros usuarios (no incluye los protegidos en folders pero si colecciones)
- "read_all_folders" - acceder a registros en folders que no se nos han compartido 
- "read_all_folders" - listar registros en folders que no se nos han compartido
- "read_all_trashcan" - acceder a  registros de otros en papelera
- "read_all_trashcan" - listar registros de otros en papelera
- "write_all" - modificar / borrar registros de otros usuarios (sin alterar su ownership)
- "write_all_folders" - modificar / borrar registros de otros usuarios en folders (sin alterar su ownership)
- "write_all_trashcan" - borrar definitivamente / restaurar registros de otros usuarios
- "write_all_collections" - escribir los registros de las colecciones de otros usuarios. 
- "transfer" - tranferir un registro o sea cambiar la propiedad (ownership) de un registro (campo belongs_to)
- "fill_all" - modificar la fecha de creación 
- "fill_all" - llenar cualquier campo incluso los no-fillables
- "grant" - conceder roles y permisos

Como colorario es posible tener muchos roles con caracteristicas de un admin o superadmin.


### Permisos a nivel de usuario

Los roles son permisos que se asignan masivamente (por igual) a todos los usuarios que poseen ese rol. Los roles se puden "sumar" obteniendo la suma de los permisos de cada rol.

Si se desea que un usuario particular tenga permisos distintos para una entidad particular que sean distintos de los del rol al que pertenece se pueden especificar "permisos indivuduales" creando un registro para ese usuario y esa tabla referida en la tabla "permissions". Solo puede haber una entrada en "permissions" para cada par (usuario, tabla).

Los cambios en los permisos a nivel de usuario al igual que los roles solo se aplican cuando el usuario "inicia sessión" o sea.. cuando obtiene los tokens y también cuando los tokens son renovados.

Hay distintas tablas y por tanto distintos endpoints para manejar distintos aspectos de los permisos:

    tabla permisions: 
        - show, list, create, update, delete 
        - Son permisos dados por un Admin sobre las tablas para usuarios específicos.

    tabla folder_permissions:
        - read, write
        - Son dados por los usuarios a ciertos usuarios sobre cierto folder de cierta tabla/

    folder_other_permissions:
        - read, write
        - Son dados por los usuarios a otros usuarios (sin especificar su id)
        - Puede especificarse el otorgamiento de permisos a usuarios no-registrados (guest)


# Como agregar / cambiar permisos a nivel de usuario 

Los permisos que "decoran" al o los roles que pueda poseer un usuario se pueden ser para un recurso (tabla) en particular ("resource permissions") o "especiales" (típicamente de roles tipo-admin)

Los permisos sobre recursos se pueden agregar o cambiar desde el endpoint

	/api/{version}/user_tb_permissions

Al listar se vería algo como:

	"data": {
        "user_tb_permissions": [
            {
                "id": 1,
                "tb": "my_table1",
                "can_list_all": null,
                "can_show_all": null,
                "can_list": 1,
                "can_show": null,
                "can_create": null,
                "can_update": null,
                "can_delete": null,
                "user_id": 119,
                "created_by": 119,
                "created_at": "2021-11-19 17:49:40",
                "updated_by": null,
                "updated_at": null
            },
			{
				"id": 5,
                // ...
			},
			// ..
        ]
    },

Para definir permisos sobre una tabla sería como en el siguiente ejemplo.  

Ej:

	{
		"tb": "table_xyz",
		"user_id": 119,
		"can_list": true
	}

Cabe destacar que siempre habrá un solo registro por tabla y que los permisos no se agregan individualmente sino todos los que se deseen setear a la vez y si se repitiera el proceso se sobre-escribiría lo que antes había.

Ej:

Si ahora se hiciera un POST nuevamente sobre /api/{version}/user_tb_permissions	

	{
		"tb": "table_xyz",
		"user_id": 119,
		"can_update": true,
		"can_show": true
	}

El resultado sería que para el "user_id" = 119 y la tabla "table_xyz" se tendrán solamente los permisos reciéntemente definidos para esa tabla y usuario.


Para conocer todos los campos (con distintos tipos de permisos) que se pueden enviar:

	GET /api/{version}/user_tb_permissions?_rules=1


Los permisos "especiales" se trabajan sobre el endpoint

	/api/{version}/user_sp_permissions

Básicamente debe enviar:

	user_id
	sp_permission_id

Ej:

	POST /api/v1/user_sp_permissions

	{
		"user_id": 119,
		"sp_permission_id": 8
	}

Donde para conocer el "sp_permission_id" puede consultar el endpoint:

	/api/v1/sp_permissions


# Posible FrontEnd para los roles y permisos

A un Administrador se le odría presentarse la información sobre roles y permisos así:

Para un usuario:

	roles

		superadmin

	Special permissions

		read_all				[del]
		write_all				[del]	
		read_all_collections	[del]
		write_all_collections	[del]
		read_all_trashcan		[del]
		write_all_trashcan		[del]
		transfer				[del]
		lock					[del]
		impersonate				[del]
		
	[add]
		
	<-- los permisos especiales tienen como base los de su rol o roles y pueden ser decorados via tabla `user_sp_permissions`. Esto significa que lo que "se ve" no es la tabla `user_sp_permissions` sino el resultado de aplicar los permisos combinados de distintos roles y a eso los permisos presentes en la tabla `user_sp_permissions` si los hubiere.	

Para otro usuario:

	roles

		accounting
		supervisor

	Special permissions

		impersonate				[del]
		read_all				[del]	
		
	[add]	

	tb: users					[del]	

	[X]	list_all
	[X]	show_all
	[ ]	list
	[ ]	show
	[ ]	create
	[ ]	update
	[ ]	delete

	tb: sells					[del]

	[X]	list_all
	[X]	show_all
	[ ]	list
	[ ]	show
	[ ]	create
	[ ]	update
	[ ]	delete

	<-- estos permisos sobre-escriben los permisos propios de su rol o roles del usuario y tienen prioridad por sobre los permisos especiales.


# Scopes

En OAuth se habla de "scopes" como simil a permisos en un sentido más abstracto pero se puede hacer corresponder a los permisos individuales de la siguiente forma:
	
	["tb_permissions"]=> {
		["products"]=> [
			"read",
			"write"
		],
		["foo"]=> [
			"read"
		]
	}

equivale a 

	products.read
	products.write
	foo.read


SimpleRest *no* sigue el estándar de scopes de OAuth donde:

    - Los permisos se presentan de forma simple con la notación recurso.operación

    - La granulidad de los permisos suele expresarse para operaciones genéricas como "read", "write" y pueden definirse "alias" para ciertas operaciones como "emails.send" para "emails.create"

    - El desarrollador no "ve" -puede listar- permisos especiales (lo que no significa que no existan) 

https://www.freecodecamp.org/news/best-practices-for-building-api-keys-97c26eabfea9/


# Métodos para indagar sobre permisos y roles

El Acl provee un conjunto de métodos básicos para conocer el rol o los permisos del usuario y puede extender a partir de "paquetes" (service providers).

getEveryPosibleRole()                   Devuelve todos los roles registrados en el ACL.
roleExists($rol)                        Existe el rol?
getRolePermissions($rol)                Devuelve todos los permisos para un determinado rol.
getAncestry($rol)                       Roles de los ancestros de un usuario.
isHigherRole($rol1, $rol2)              Tiene el rol$1 mayor nivel de acceso que $rol2? (2)

isGuest()                               Es un visitante no registrado?
isRegistered()                          Es un usuario que ha entregado credenciales?    
getRoles()                              Rol o roles de usuario.

hasRole($rol)                           El usuario posee ese rol? (no considera herencia)
hasAnyRole([$rol1, ...])                El usuario posee alguno de esos roles? (no considera herencia)   
hasRoleOrHigher($rol)                   Se tiene el rol o uno "superior" (2)
hasAnyRoleOrHigher([$rol1, ...])        Se tiene un rol o uno "superior" (2)

getTbPermissions($table = null)			Retorna permisos sobre recursos (tablas) (1)
getSpPermissions($table = null)			Retorna permisos "especiales" (1)
getFreshTbPermissions($table = null)	Retorna permisos sobre recursos (tablas)
getFreshSpPermissions()					Retorna permisos "especiales"
hasResourcePermission($perm, $tabla)    El usuario tiene permisos explícitos sobre esa tabla?
hasSpecialPermission($permiso)          El usuario tiene ese permiso especial?


Notas:

getTbPermissions() y getSpPermissions() no ofrecen resultados necesariamente actualizados (a diferencia de acceder a los endpoints correspondientes). Si el usuario entregó credenciales via Web Tokens, estos permisos muy probablemente serán derivados del payload del web token.

Para el caso del paquete boctulus\grained_acl se implementan adicionalmente getFreshTbPermissions() y getFreshSpPermissions() que garantizan resultados "frescos" porque acceden directamente a la base de datos.


Actualmente isHigherRole() y hasRoleOrHigher() están implementados en base a el árbol genealógico de roles y no compara permisos lo cual ofrece uh resultado que puede no ser exacto y solo lo será si existe una sola rama sin derivaciones en el árbol genealógico entre los roles a comparar.

Sin embargo, hasAnyRoleOrHigher() ofrece obtener el resultado más preciso a pesar de que no compara permisos sino roles ya que permite comparar no con un rol sino con varios y por ende considerar derivaciones en el árbol genealógico.

Ej:

+
|
----- guest
		|
		|
	registered
		|  |
		|  |
		|  usuario
		|        |
	supervisor   |
	    |        usuario_plus
		|              |
	 superadmin     moderador


Supongamos que en un escenario en particular (ResourceController o API) necesito un rol >= {supervisor o usuario} entonces podría usar hasAnyRoleOrHigher() para chequear esta condición:

	$pass = acl()->hasAnyRoleOrHigher(['supervisor', 'usuario_plus']);

Sin embargo podría querer saber si el usuario tiene los mínimos permisos que otorga un rol, entonces hasAnyRoleOrHigher() no ofrecerá exactamente lo que se necesita.

Entonces se *implementará* hasRolePermissionsOrHigher() y esta función podrá considerar derivaciones en el árbol genealógico.

La función Acl::hasRolePermissionsOrHigher() *deberá* tener en consideración todos los tipos de permisos, ya sea sobre recursos (tablas) y los considerados permisos "especiales". También deberá considerar los permisos que "decoran" los de los roles para un usuario en particular (!)


# Implementación de "paquetes" para el Acl

Es importante resaltar que dado que la clase Acl se serializa por motivos de performance la mayor parte de las propiedades y métodos no pueden ser estáticos ya que propiedades estáticas no pueden ser serializadas y al des-serializar no estarán disponibles llevando a muchos dolores de cabeza. Igualmente por concistencia se desaconseja el uso de métodos estáticos.

Al implementar un service provider para el ACL se debe cumplir de mínima con la interfaz IAcl.


# Controladores tipo "resource"

Una API se crea típicamente extendiendo la clase ApiController y esta clase a su vez extiende de otra llamada ResourceController que es la que tiene acceso a los autenticación via web tokens y por ende tiene disponible también los métodos para indagar permisos y roles.

Es imporante notar que dado que el *AuthController* o sea el componente responsable de verificar que el usuario haya entregado credenciales (autenticación) y sean correctas (autorización) está versionado entonces es necesario explicitar la versión de api a fin de que encuentre la clase.

Ej:

    class DumbAuthController extends ResourceController
    {
        function __construct()
        {
            global $api_version;
            $api_version = 'v1';

            parent::__construct();

            if (!acl()->hasAnyRole(['supervisor', 'admin'])){
                response()->sendError('Unauthorized!!!', 401);
            }
        }

        // ...

    }


### Folders

Sobre cada recurso se pueden crear espacios virtuales separados llamados "folders" a los cuales se les pueden establecer permisos para que otros usuarios los visualicen. 

Los folders no tienen nada que ver con el sistema de archivos sino que representan un conjunto de registros de una entidad particular sobre los que se pueden establecer permisos de forma unificada. 

Cada folder existe como un registro distinto en la tabla "folders" y se asocia con una determinada entidad (productos, usuarios, etc) y con un campo en esa entidad conteniendo un valor específico. Para cada endpoint se define el nombre del campo que se asocia al folder, ejemplo:


	class Products extends MyApiController
	{ 
	    protected $folder_field = 'workspace';

	    function __construct()
	    {       
	        parent::__construct();
	    }	        
	} 

El campo $folder_field almacena el nombre del campo que en el ejemplo es "workspace".

Para acceder a un folder se especifica el id del folder y otros usuarios pueden entonces listar o visualizar recursos que se le hayan compartido.

	GET /api/v1/v1/products?folder=1

Por supuesto pueden aplicarse otros filtros:

	GET /api/v1/products?folder=1&cost=200

Y puede visualizarse un registro en particular (ej: 124) para el que no tendríamos permiso si no especificamos el folder:

	GET /api/v1/products/124?folder=1		

<-- si el folder se nos ha "compartido" por medio de permisos y no se especifica entonces el registro no se hallará devolviendo 404 (Not Found).

Un usuario con rol de administrador en principio obtendrá todos los registros para un endpoint incluidos los que pertenecen a folders privados de otros usuarios:

	GET /api/v1/products

<-- obtiene todos los registros indiscriminadamente

Sin embargo también puede filtrar a un folder en particular:

	GET /api/v1/products?folder=57

Los permisos para los folders se conceden creando entradas en la tabla folder_permissions y es importante notar que debe darse explícitamente permiso al owner (así como a los otros usuarios) para que éste ver registros dentro de ese folder.

Obviamente cada usuario puede listar, editar o borrar sus folders usando el endpoint /api/v1/folders

Igualmente cada usuario puede hacer CRUD sobre los permisos de "grupo" y para "otros" a través de sus respectivos endpoints /api/v1/FolderPermissions y /api/v1/FolderOtherPermissions respectivamente de modo de permitir a otros miembros acceso de lectura y/o escritura de sus registros.

Para crear un registro en un folder del que se ha concedido permiso de escritura se incluye como campo el id del "folder". Ej:

	POST /api/v1/products

	{
		"name": "Supreme jugo",
	    "description": "de manzanas exprimidas",
	    "size": "1L",
	    "cost": "250",
	    "folder": "8"
	}

O bien se especifica en el "campo clave" que hace identifica al folder, en nuestro caso llamado "workspace" con el valor que corresponda para el folder:

	{
		"name": "Supreme jugo",
	    "description": "de manzanas exprimidas",
	    "size": "1L",
	    "cost": "250",
	    "workspace": "lista10"
	}

En el primer caso, si se especifica un folder pero no tenemos acceso recibiremos un mensaje de error como:

	{
	    "error": "You have not permission for the folder 8"
	}

En el segundo caso donde especificamos "workspace": "lista10" en vez de "folder": "8", si el folder no existe no habrá advertencia alguna pues solo estamos creando un registro con esa combinación de campos y distintos usuarios pueden tener folders con el mismo nombre así que no hay problema.

Es importante entender que cuando creamos un registro dentro de un folder que no nos pertenece (porque se nos da permiso de escritura), el registro tampoco será de nuestra propiedad aunque podremos leerlo y escribirlo siempre que tengamos los permisos para ello.

Igualmente para modificar un registro de otro usuario que nos ha compartido su folder especificamos el id del folder:

	PUT /api/v1/products/136

	{
	    "name": "Vodka venezolano",
	    "description": "de Vzla",
	    "size": "1L",
	    "cost": "15",
	    "folder": "1"
	}

Mismo para borrar un registro perteneciente a un folder es necesario estar "dentro" haciendo referencia al folder en cuestión:

	DELETE /api/v1/products/136

	{
    	"folder": "1"
	}


Nota: el acceso a los folders se chequea en base de datos cada vez que se hace un request especificando que el recurso se halla en un folder. No es necesario esperar a que se renueven los tokens para tener acceso a un folder al cual se nos ha concedido permisos. <-- podría cambiarse para incrementar la performance !!!

Similarmente a lo que sucede con Model, la clase ApiController también aporta event hooks en particular para los folders los siguientes:


    public function onGettingFolderBeforeCheck($id, $folder){ } 
    public function onGettingFolderAfterCheck($id, $folder){ }
    public function onGotFolder($id, $total, $folder){ }

    public function onDeletingFolderBeforeCheck($id, $folder){ }
    public function onDeletingFolderAfterCheck($id, $folder){ }
    public function onDeletedFolder($id, $affected, $folder)

    public function onPostingFolderBeforeCheck($id, $data, $folder){ }
    public function onPostingFolderAfterCheck($id, $data, $folder){ }
    public function onPostFolder($id, $data, $folder){ }

    public function onPuttingFolderBeforeCheck($id, $data, $folder){ }
    public function onPuttingFolderAfterCheck($id, $data, $folder){ }
    public function onPutFolder($id, $data, $folder, $affected){ }
       

Desde cualquiera de esos métodos es obviamente posible acceder a métodos y propiedades de visibilidad por lo menos protected de la clase Model y en particular a folder y id (del registro). Ej:

	function onGettingFolderBeforeCheck($id, $folder) {
        echo "Reading folder {$folder} with id={$id}";
    }

Un uso práctico de estos hooks sería con onGettingFolderBeforeCheck() implementar la funcionalidad de conceder acceso a un folder siguiendo un enlace que como parámetro puede tener un token. Si el token es válido se concede el acceso al usuario que sigue el enlace insertando el permiso correspondiente en la tabla folder_permissions.

Ej: <pseudocódigo>

	function onGettingFolderBeforeCheck() {

        if ($this->isGuest()){
            // Informar que debe estar "logueado"
            return;
        }

        if ($this->isAdmin()){
            return;
        }

        $token = \simplerest\libs\Factory::request()->getQuery('token');
    
        // decodificar token y si es válido proseguir
        
        $uid = $this->auth['uid'];

        // insertar en la tabla folder_permissions el permiso para el usuario con id $uid`
        // y el folder  $folder
    }


### Soft delete y la papelera

En cada endpoint se puede definir si se habilita el "soft" delete mediante la propiedad $soft_delete en la api. Ejemplo:

class Products extends MyApiController
{ 
	// solo hard delete
    protected $soft_delete = false;

    // ...


La única forma de visualizar registros borrados de forma "suave" así como recuperarlos o borrarlos definitivamente es mediante la papelera con la ventaja de que ésta tiene sus propios permisos.


### La Papelera

Cuando un registro es marcado como borrado aparece en trash_can, la papelera de reciclaje, que brinda la posibilidad de gestionar todas las operaciones sobre elementos eliminados.

Para ver elementos en la papelera

	GET /api/v1/trash_can?entity=products
	GET /api/v1/trash_can/157?entity=products


Para hacer un "undelete" de un recurso se hace un PATCH o PUT sobre el trash_can

	PATCH /api/v1/trash_can/157	

	{
		"entity": "Products",
		"trashed": false
	}

* por concistencia, se admite que 'entity' sea especificado en headers, en la query de la url o bien en el body en cualquier caso.

Para eliminar *permanentemente* un recurso se realiza un DELETE sobre el elemento en la papelera:

	DELETE /api/v1/trash_can/157

	{
    	"entity": "Products"
	}

La papelera acepta los mismos filtros y los resultados se pueden ordenar igual que con cualquier entidad:

	GET GET /api/v1/trash_can?entity=Products&orderBy[deleted_at]=DESC


### Colecciones

Para realizar acciones masivas se recomienda crear colecciones. Por ejemplo si quisiera afectar 3 registros:

	POST /api/v1/collections

	{
		"entity": "products",
		"refs": [198,199,200]
	}

Luego si por ejemplo quiero realizar una edición masiva de un campo "enabled" poniéndolo en 1 en toda la colección 

	PATCH /api/v1/collections/2

	{
		"cost": "99"
	}

Para borrar masivamente

	DELETE /api/v1/collections/9

Cabe destacar que las operaciones PATCH y DELETE se efectuan sobre los registros contenidos en la colección de sus respectiva entidad o dicho de otro modo un DELETE sobre una colección no borra solo el registro de la colección sino los registros asociados + el registro de la colección.

Por lo anterior en un PATCH sobre una colección no es posible modificar "refs" ni el "id" de la colección via endpoint.

Son seguras las colecciones?

  - NO debería poder crear una colección de registros que no me pertenecen sino soy "admin" o tengo los permisos correspondientes ? -> no importa porque la verificación se hace al mommento de intentar afectar los registros de la colección.
  - No debería evitarse poder crear colecciones sobre registros inexistentes ? -> no importa porque al momento de hacer el PATCH o el DELETE sobre la colección solo se afectarán los registros existentes.   
  - No deberían poder crearse dos colecciones iguales (mismos registros, misma tabla) -> no importa porque tanto PATCH como DELETE son idempotentes.
  - El permiso write_all no se queda corto si las colecciones se llegaran a crear sobre roles, user_roles, sp_permissions, tb_permissions, folders, folder_permissions, other_folder_permissions, etc ? SI! y por eso se restringe y no se dejan crear colecciones sobre esas tablas.


Filtrar colecciones

	GET /api/v1/collections?entity=documents


### Convención de nombres 

Recomendamos separar las palabras con guión bajo (_) en los nombres de las entidades. Ejemplo:

/api/v1/super_cool_table
/api/v1/trash_can?entity=super_cool_table
etc.

En vez de usar:

/api/v1/SuperCoolTable
/api/v1/TrashCan?entity=SuperCoolTable
etc


### Registros bloqueados

El admin puede colocar un "lock" sobre registros impidiendo que:

- Puedan ser modificados por el propietario. Le arrojará un código 403. 
- No puedan ser borrados. Le arrojará un código 403. 
- No puedan ser vistos en la papelera por el propietario. Le arrojará un codigo 403. 
- No puedan ser recuperados por el propietario. Le arrojará un código 403. 
- No puedan ser borrados permanentemente por el propietario cuando se hayan en la papelera. 

Cuando un registro es borrado por el Admin éste es bloqueado para el usuario propietario evitando así que pueda modificarlo, recuperarlo o borrarlo permanentemente.

Implementación:

Una entidad correspondiente a un endpoint si contiene un campo 'is_locked' de tipo "bool" (TINYINT para Mysql) entonces queda habilitada para el mecanismo de "bloqueo".


### Seguridad 

Es muy importante tener buen criterio al momento de entregar permisos ya que es potencialmente posible lograr escalarlos manipulando las tablas de permisos, etc.


# APIs Restful

Por cada entidad (normalmente una tabla en la DB) existe un único endpoint de la forma /api/{version}/nombre_entidad sobre el que se puede hacer un get, post, put, patch y delete donde v1 es la versión de la API pero podría ser otra.

Adicionalmente para los usuarios existe un endpoint adicional /api/{version}/me que permite obtener información útil y realizar operaciones que en determinadas circunstancias no es posible sobre una url como /api/v1/users/:id

Los endpoints se sirven mediante clases que extienden a ApiController, un tipo de ResourceController.

Un usuario (sin ser Admin pero con los permisos correctos) podría crear otros usuarios y éstos le pertencerán así que podrá visualizarlos o modificarlos a su gusto pero como consecuencia de la implementan del ACL, el campo belongs_to apuntará al "creador" y como consecuencia el propio usuario podría no tener permisos suficientes para mpdificar sus propios datos personales. Este problema se soluciona al utilizar el endpoint /api/v1/me

Otro endpoint adicional es /api/v1/trash_can que corresponde a una papelera de registros y se explica en la sección correspondiente. 


# Funcionalidad out-the-box de la API

## GET <READ>

    GET /api/v1/products
    GET /api/v1/products/83

### Search    

    GET /api/v1/products?name=Vodka
    GET /api/v1/products?name=Vodka&size=1L

IN / NOT IN

    GET /api/v1/products?name=Vodka,Wisky,Tekila
    GET /api/v1/products?name[in]=Vodka,Wisky,Tekila
    GET /api/v1/products?name[notIn]=CocaCola,7up

### String comparisons   

    contains 
    notContains 
    startsWith  
    notStartsWith
    endsWith   
    notEndsWith
    
Example

    GET /api/v1/products?name[contains]=jugo 

### Other comparators

    =    eq
    !=   neq
    >    gt
    <    lt
    >=   gteq
    <=   lteq

Example:  
    
    GET /api/v1/products?cost[gteq]=25&cost[lteq]=100

### BETWEEN

    GET /api/v1/products?orderBy[cost]=ASC&cost[between]=200,300
    GET /api/v1/products?created_at[between]=2019-10-15 00:00:00,2019-09-01 23:59:59

### List of fields to include

    GET /api/v1/products?fields=id,name,cost
    GET /api/v1/products/83?fields=id,name,cost
    GET /api/v1/products?fields=id,cost&name=Vodka

### Exclude fields

    GET /api/v1/users?exclude=firstname,lastname

### Select null or not null values

    GET /api/v1/products?description=NULL
    GET /api/v1/products?description[neq]=NULL

# Pagination

### ORDER BY

    GET /api/v1/products?orderBy[cost]=DESC
    GET /api/v1/products?orderBy[cost]=DESC&order[name]=ASC
    GET /api/v1/products?orderBy[cost]=ASC&order[id]=DESC

### LIMIT

    GET /api/v1/products?limit=10
    GET /api/v1/products?offset=40&limit=10
    GET /api/v1/products?limit=10&order[name]=ASC&order[cost]=DESC&size=2L

Pagination can be done with page and pageSize

    GET /api/v1/products?page=3
    GET /api/v1/products?pageSize=20&page=2

Response is an array of rows that include a paginator with navigation information:

{
    "data": [
        {
            "id": "126",
            "name": "Uvas fermentadas",
            "description": "Espectacular",
            ...
        },
        {
            "id": "131",
            "name": "Vodka",
            "description": "de Estados Unidos!",
            ...
        },
        ...
    ],
    "error": "",
    "error_detail": "",
    "paginator": {
        "pages": 7,
        "nextUrl": "http://simplerest.lan/api/v1/products?pageSize=10&page=2"
    }
}
    
# Aggregate Functions – Average, Count, Sum, Max and Min

Examples:

	GET /api/v1/products?props=min(cost)
	GET /api/v1/products?size=1L&props=avg(cost)

Response is something like:

{
    "data": {
        "AVG(cost)": "191.0714"
    },
    "error": "",
    "error_detail": ""
}

Note that if the field on which you want to calculate is not specified, it is not performed and no error is throw. In the case of count() function if you don't want to specify a field you must pass * as a parameter:

	GET /api/v1/products?props=count(*) as cant
	

Or with an alias

	GET /api/v1/products?size=1L&props=avg(cost) as media

# Grouping

	GET /api/v1/products?props=count(*) as cant&groupBy=size&fields=size

Example of Response:

{
    "data": [
        {
            "size": "",
            "cant": "21"
        },
        {
            "size": "0.5L",
            "cant": "2"
        },
        ...
    ],
    "error": "",
    "error_detail": ""
}

Note: when groupBy is used, you should specify the fields to be selected. 

With having

	GET /api/v1/products?groupBy=size&fields=size&props=avg(cost)&having=avg(cost)>=150

Having with alias 

	GET /api/v1/products?groupBy=size&fields=size&props=avg(cost) as average&having=average>=150

### Pretty print 

    GET /api/v1/products?pretty

By default pretty print can be enabled or disabled in config/config.php    


## POST <CREATE>

    POST /api/v1/products

    {
        "name": "Vodka",
        "description": "from Bielorussia",
        "size": "2L",
        "cost": "200"
    }

## DELETE

    DELETE /api/v1/products/100

A record can be effectly deleted in one shot from database or if soft-delete is enabled then be marked as deleted in which case it will be seen as deleted as well.

When a record is softly deleted then it can be seen at trash_can where is posible to delete it permanently or to be recovered.


## PUT  <UPDATE>

    PUT /api/v1/products/84

    {
        "name": "Vodka",
        "description": "from Russia",
        "size": "2L",
        "cost": "200"
    }


## PATCH <PARTIAL UPDATE>

    PUT /api/v1/products/84

    {
        "description": "from Mongolia",
        "cost": "230"
    }

# El endpoint /me

The simple way to perform CRUD operations on the current user is using /api/v1/me endpoint.

    GET /api/v1/me

    {
        "data": {
            "id": "4",
            "username": "pbozzolo",
            "email": "pbozzolo@gmail.com",
            "confirmed_email": "1",
            "firstname": "Paulinoxxxy",
            "lastname": "Bozzoxxxy",
            "deleted_at": null,
            "belongs_to": "0"
        },
        "error": "",
        "error_detail": ""
    }

Si se hace un DELETE sobre /me el usuario sufre un borrado (lógico) pero si se quiere des-activar la cuenta puede usarse PATCH:

Desactivar cuenta

	PATCH /api/v1/me

	{
		"is_active": 0
	}

Ahora al intentar renovar el token o loguearse, se informará que la cuenta está "pendiente de activación".


### Las respuestas de la API

Una respuesta exitosa a un GET presenta un campo 'data' en la respuesta:

{
    "data": {
        "id": "185",
        "name": "ABC",
        "description": "",
        "size": "",
        "cost": "0",
        "created_at": "2019-11-03 23:55:18",
        "updated_at": null,
        "deleted_at": null,
        "is_locked": "0",
        "workspace": null,
        "belongs_to": "132"
    },
    "error": "",
    "error_detail": ""
}

En cambio una respuesta que contiene un error, puede o no poseer cuerpo pudiendo ser solo el código de estaus http o bien incluir también un cuerpo con los campos "error" y "error_detail"

{
    "error": "Not found",
    "error_detail": "Register for id=1850 doesn't exist"
}

### created_by=me, update_by=me o belongs_to=me

Puede darse el caso de que un usuario sea el owner de ciertos registros pero que no hayan sido creados por él sino por otro usuario con permisos (por ejemplo un Admin).

Es posible filtrar facilmente los registros creados, actualizados o pertenecientes al usuario que hace el request colocando 'me' en lugar del id del propio usuario. 

Ejemplos:

GET /api/v1/products?created_by=me
GET /api/v1/products?created_by[neq]=me
GET /api/v1/products?belongs_to[neq]=me
GET /api/v1/products?belongs_to=90,me,1  
GET /api/v1/products?belongs_to[notIn]=90,me,1
...
GET /api/v1/userRoles?belongs_to=me
...


# Method override

Si en el servidor estuvieran desactivados PUT, PATCH o DELETE aún es posible utilizarlos haciendo un "method override".

If your REST client does not support certain requests, you can use the X-HTTP-Method-Override header:

PUT = POST + X-HTTP-Method-Override: PUT
PATCH = POST + X-HTTP-Method-Override: PUT
DELETE = GET + X-HTTP-Method-Override: DELETE

Alternatively, you can also override the HTTP method by using the _method query string parameter.

GET /api/v1/products/126?_method=patch
GET /api/v1/products/126?_method=put
GET /api/v1/products/126?_method=delete


#  Funciones agregativas

Es posible calcular directamente en la base de datos las funciones min(), max(), avg() y sum() sobre el campo especificado.

Ejemplos:

GET /api/v1/products?props=count(*)
GET /api/v1/products?props=count(description)
GET /api/v1/products?props=sum(cost)
GET /api/v1/products?size=2L&props=avg(cost)
GET /api/v1/products?size=2L&props=avg(cost) as prom
GET /api/v1/products?size=2L&props=sum(cost) as suma
etc.


# Archivos

Se pueden subir archivos al servidor:

POST /api/v1/files 

<-- como "form-data". Admite múltiples archivos en el mismo request.

Resultando en

{
    "data": {
        "uploaded": [
            {
                "filename": "65394374_10158090117128840_7189038881361100800_o.jpg",
                "id": "240",
                "link": "/download/get/240"
            },
            {
                "filename": "78372400_3426368247403784_5430079366526664704_n.jpg",
                "id": "241",
                "link": "/download/get/241"
            }
        ],
        "failures": []
    },
    "status_code": 201,
    "error": "",
    "error_detail": ""
}

Los archivos se pueden filtrar por múltiples criterios, por ejemplo: extensión

GET /api/v1/files?file_ext=jpg

{
    "data": [
        {
            "id": "240",
            "filename": "65394374_10158090117128840_7189038881361100800_o.jpg",
            "file_ext": "jpg",
            "filename_as_stored": "90-5f5bb828cb06c3.52751786.jpg",
            "belongs_to": "90",
            "guest_access": "0",
            "is_locked": "0",
            "created_at": "2020-09-11 14:47:20",
            "deleted_at": null
        },
        {
            "id": "241",
            "filename": "78372400_3426368247403784_5430079366526664704_n.jpg",
            "file_ext": "jpg",
            "filename_as_stored": "90-5f5bb828e85fe4.62412332.jpg",
            "belongs_to": "90",
            "guest_access": "0",
            "is_locked": "0",
            "created_at": "2020-09-11 14:47:21",
            "deleted_at": null
        }
    ],
    "status_code": 200,
    "error": "",
    "error_detail": "",
    "paginator": {
        "total": 2,
        "count": 2,
        "currentPage": 1,
        "totalPages": 1,
        "pageSize": 10,
        "nextUrl": "null"
    }
}

Borrar un archivo 

	DELETE /api/v1/files/{uuid}


# Extender a Files

Files es un tipo de ApiController -versionado- y se puede "extender" fácilmente: 

	<?php

	namespace simplerest\controllers\api;

	global $api_version;

	/*
		Agregue según se vayan creando versiones
	*/

	if ($api_version == 'v1'){
		class Files extends \simplerest\core\api\v1\Files { }
		return;
	};

Se puede crear así una "API" para otro tipo de archivos como por ejemplo "updates" sin tener que duplicar toda la funcionalidad.


# Descarga de archivos

Se provee de un endpoint "download" que extiende el ResourceController "Download".

	GET /download/get/{id}

Crear un endpoint especializado en la descarga de otro tipo de archivos (de otra tabla distinta a "files" por ejemplo) es muy fácil:

	<?php

	namespace simplerest\controllers;

	// Estoy usando siempre la misma versión de las APIs
	use simplerest\core\api\v1\Download;

	class DownloadController extends Download
	{
		function updates($id){
			$this->table_name = 'updates';
			return $this->get($id);
		}
	}

También podríamos querer usar un "alias" para "get" específicamente para la descarga de archivos de una tabla "files".

	<?php

	namespace simplerest\controllers;

	// Estoy usando siempre la misma versión de las APIs
	use simplerest\core\api\v1\Download;

	class DownloadController extends Download
	{
		function files  ($id){
			return $this->get($id);  
		}

		function updates($id){
			$this->table_name = 'updates';
			return $this->get($id);
		}
	}

En este caso no se especifica la propiedad $table_name por la simple razón de que por defecto "Download" hace referencia a esa tabla.

Los acceso quedarían así:

	{url_base}/download/files/{id}
	{url_base}/download/updates/{id}


# Modelos y esquemas (schemas)

Modelos y schemas se mantienen separado en distintos archivos. El comando 'make' crea modelos y schemas mientras que el comando 'migrate' impacta en la DB reflejando cambios en los schema.

 
   								   Api Rest   
	  	  [make]                      |
	DB ------------> Schema           |
							<------ Model (Query Model) <---- ORM
	 	  migration		
	   <------------           


make migration --table=books
make schema books
make model books

	
# Make 

Para generar modelos, controladores y apis se utiliza el comando make de la siguiente forma: 

	php com make schema SuperAwesome [-f | --force]
    php com make schema super_awesome  [-f | --force] [ --from:db_connection ]

    php com make model SuperAwesomeModel  [-f | --force]
    php com make model SuperAwesome [-f | --force]
    php com make model super_awesome  [-f | --force] [ --from:db_connection ]

    php com make controller SuperAwesome  [-f | --force]

    php com make api SuperAwesome  [-f | --force]
    php com make api super_awesome  [-f | --force]

    php com make any SuperAwesome  [-s | --schema ] 
                            [-m | --model] 
                            [-c | --controller ] 
                            [-a | --api ] 
                            [-f | --force]

	php com make constants

	php com make pivot_scan


Notas:

- Al crear todos los esquemas con la opción "all" implícitamente se correrá el comando que crea el esquema para las tablas puente Pivots.php 

- La creación de "constantes" está relacionada con los mensajes de error del sistema y su Internacionalización.

- Para la creación de modelos se añadió --no-check y --no-verify que evitan corroborar que exista una tabla en la base de datos que se corresponda con el nombre del modelo. Esto podría ser útil para cambiar el tipo de DataSource


# Ayuda 

El comando "make" tiene una ayuda que es invocada cuando no se pasan parámetros:

	$ php com make


Ejemplos:
    
    php com make any baz -s -m -a -f

Lo anterior es equivalente a:

	php com make any baz -samf

Solo existen (hasta ahora) los atajos -sam y -samf pero Ud. puede hacer las combinaciones que quiera con "any"

	php com make any baz -s -m -a -f
	php com make any baz -s -m
	php com make any baz -m -s
	php com make any baz -a -f
	php com make any baz -a -s
	...

# Especificar la ruta de un controlador 

Para controladores es posible especificar una ruta interior a apps\controllers

Ej:

	php index.php make controller sub1\a\this

El comando anterior creará ThisController dentro de pps\controller\sub1\a\

# Especificar la conexión de base de datos para un Modelo

Para generar schemas o models de una DB que no es la default se debe especificar la conexión. Ej:

	php com make schema cotizaciones --from:db3
	php com make model cotizaciones --from:db3


# No sobre-escribir archivos

Es posible ignorar archivos para evitar sean sobre-escritos colocando el nombre del controlador, api resful controller, modelo o esquema en el siguiente archivo en /apps:

	.make_ignore

Ejemplo:

	models\UsersModel.php
	models\FilesModel.php
	\schemas\FooSchema.php
	# models\CollectionsModel.php
	models\ProductsModel.php
	controllers\UsersController.php
	controllers\sub1\a\OpsController.php
	ProductsController.php

Puede observarse que:

	- Se pueden especificar rutas relativas a /app
	- Se pueden especificar solo los nombres de los archivos -sin ruta-
	- Se pueden anular los ignore comentando la línea con una #almohadilla 
	

Nota: no se recomienda ignorar los schemas ya que si bien se puede hacer un "unignore" con la opción --unignore o --retry puede ser muy complicado de descubrir la fuente del error.

Ej:

	Fatal error: Uncaught Error: Class '\simplerest\\schemas\main\FilesSchema' not found
 

# Migrations

Los archivos de migraciones son creados con el comando "make migrate" o "migrations make":

	$ php com migrations make create_cables
o
	$ php com make migration create_cables

Es posible especificar el directorio donde se quiere crear la migración con la opción --dir=

	$ php com make migration create_cables --dir=my_folder

Ej:

	$ php com make migration create_cables --dir=my_folder/sub

Notar que en sistemas UNIX / Linux, la "\" escapa caracteres así que si se quisiera usar la el directory separator de Windows (/) tendría que entre-comillarse:

	$ php com make migration create_cables --dir='my_folder\sub'


Es opcional especificar el "name" como primer parámetro en "make migration" o "migrations make" si se especifica la tabla o la clase.

Es válido:

	php com make migration books [ otros parámetros ]
	php com make migration --dir=test --name=books
	php com make migration --class_name=Books
	php com make migration --table=books
	php com make migration --class_name=BooksRenameColumn --table=books
	etc.

# Directorios

Es posible crear migraciones en directorios y sub-sub-directorios.

Ej:

	php com make migration  --dir=test/sub/sub2 --name=books


# Estructura de los archivos de migraciones

Los archivos creados por "make migration" implementan la interface IMigration y en si poseen dos métodos que pueden considerarse "hooks": up y down

	public function up()
    {   
		// ...
	}

	public function down()
    {   
		// ...
	}

Lo que se coloque en up() es corrido durante la migración mientras que el código en down() es ejecutado al hace un "rollback".

Es importante notar que la migración se ejecutará sobre la conexión de base de datos activa la cual se puede setear desde la misma migración ya sea en el constructor o bien en los métodos up() y down()

	public function up()
    {   
        DB::getConection('some_conn_id');

		// ..
	}

Puede que exista un escenario donde se prefiera no hacer el seteo de la conexión dentro de la migración. 

Al momento de crear la migración (con "make migration") hay parámetros que se pueden pasar:

--to=   (conexión a la db)
--table= 
--class_name=
etc

Si se especifica --to={some_conn_id}  entonces se agregará automáticamente el seteo a la conexión en el método up()

public function up()
{   
	DB::getConnection({some_conn_id});

	// ..
}


# Schema Builder 

Básicamente hay dos grandes funcionalidades que residen en la clase Schema: crear tablas y alterarlas.

	Schema::create() 		realiza un CREATE TABLE
	Schema::change()		realiza un ALTER TABLE

Además Schema::alter() es un alias de Schema::change() por lo que pueden usarse indistintamente,

Ej:

Un "CREATE TABLE" dentro de una migración:

	function up()
	{
		sc = (new Schema('facturas'))

        ->setEngine('InnoDB')
        ->setCharset('utf8')
        ->setCollation('utf8_general_ci')

        ->integer('id')->auto()->unsigned()->pri()
        ->int('edad')->unsigned()
        ->varchar('firstname')
        ->varchar('lastname')->nullable()->charset('utf8')->collation('utf8_unicode_ci')
        ->varchar('username')->unique()
        ->varchar('password', 128)
        ->char('password_char')->nullable()
        ->varbinary('texto_vb', 300)

        // BLOB and TEXT columns cannot have DEFAULT values.
        ->text('texto')
        ->tinytext('texto_tiny')
        ->mediumtext('texto_md')
        ->longtext('texto_long')
        ->blob('codigo')
        ->tinyblob('blob_tiny')
        ->mediumblob('blob_md')
        ->longblob('blob_long')
        ->binary('bb', 255)
        ->json('json_str')

        
        ->int('karma')->default(100)
        ->int('code')->zeroFill()
        ->bigint('big_num')
        ->bigint('ubig')->unsigned()
        ->mediumint('medium')
        ->smallint('small')
        ->tinyint('tiny')
        ->decimal('saldo')
        ->float('flotante')
        ->double('doble_p')
        ->real('num_real')

        ->bit('some_bits', 3)->index()
        ->boolean('is_active')->default(1)
        ->boolean('paused')->default(true)

        ->set('flavors', ['strawberry', 'vanilla'])
        ->enum('role', ['admin', 'normal'])

        ->time('hora')
        ->year('birth_year')
        ->date('fecha')
        ->datetime('vencimiento')->nullable()->after('num_real') /* no está funcionando el AFTER */
        ->timestamp('ts')->currentTimestamp()->comment('some comment') // solo un first

        ->softDeletes() // agrega DATETIME deleted_at 
        ->datetimes()  // agrega DATETIME(s) no-nullables created_at y deleted_at

        ->varchar('correo')->unique()

        ->int('user_id')->index()
        ->foreign('user_id')->references('id')->on('users')->onDelete('cascade')
        ->foreign('user_id')->references('id')->on('users')->constraint('fk_uid')->onDelete('cascade')->onUpdate('restrict')
    
        $res = $sc->create();	
	}
	

De Laravel se hereda la sintaxis 

	->foreign()
	->references()
	->on()
	->constraint()
	->onDelete()
	->onUpdate()

Sin embargo a muchos les puede resultar confusa así que se han creado alias y de hecho se recomienda la siguiente sintaxis:

	->fromField()
	->toField()
	->onTable() 
	->constraint()
	->onDelete()
	->onUpdate()
o
	->fromField()
	->toField()
	->toTable() 
	->constraint()
	->onDelete()
	->onUpdate()

El uso de constraint() es opcional como así también onDelete() y onUpdate()

Es posible debuguear el SCHEMA a ser creado:

	d($sc->getSchema(), 'SCHEMA');
    d($sc->dd(true), 'SQL');

El método Schema::getSchema() devuelve la representación interna.

Ej:

Un "ALTER TABLE" dentro de una migración:
	
	function up(){
		$sc = new Schema('tbl_producto');
	
		$res = $sc
		->foreign('unm_intIdUnidadMedida')
		->references('unm_intId')
		->on('tbl_unidadmedida')
		->onDelete('cascade')
		->onUpdate('restrict')
		->change();
	}


# Debugging de Schema

Si se deseara "debuguear" y conocer el SQL resultante se puede usar el método dd() sobre la instancia del Schema
	
Ej:

	$sc = new Schema('boletas');

	$sc->field('f1')->primary();
	$sc->field('f2')->primary();
	$sc->alter();

	/*
		Debugging
	*/

	d($sc->getSchema(), 'SCHEMA');
	d($sc->dd(true), 'SQL');

Es posible *evitar* que se ejecute la migración llamando previamente a dontExec() 

Ej:

	$sc = new Schema('boletas');

	$sc->field('f1')->primary();
	$sc->field('f2')->primary();
	$sc->dontExec();  // <--- before alter() or create()
	$sc->alter();

	/*
		Debugging
	*/

	d($sc->getSchema(), 'SCHEMA');
	d($sc->dd(true), 'SQL');


# El comodín field()

Hay casos donde no tiene mucho sentido dar la definición si el objetivo es borrar ya sea el campo o un atributo de éste y en tal caso es más conveniente siemplemente hacer referencia al campo con field()

Ej:

	$sc = new Schema('boletas');
	$sc->varchar('lastname')->dropNullable();
	$sc->alter();


En vez de lo anterior, lo mejor sería hacer:

	$sc = new Schema('boletas');
	$sc->field('lastname')->dropNullable();
	$sc->alter();

Un ejemplo más completo de los casos útiles para field() sería:

	$sc = new Schema('bar');
	$sc->field('c1')->unsigned()->primary()->auto();
	$sc->field('c2')->primary();
	$sc->field('c3')->nullable();
	$sc->field('c4')->dropNullable();
	$sc->field('c5')->zeroFill();
	$sc->field('c6')->binaryAttr();
	$sc->field('c7')->dropAttr();
	$sc->alter();

En ningún caso era necesario definir el campo para alterarlo.


# Transacciones dentro de migraciones

Cada migración debe ejecutarse en su totalidad pues debe poder revertirse con lo cual no puede quedar en un estado "intermedio" o parcial de operaciones.

Por tanto, si se va a efectuar más de una operación sobre la base de datos, deben usarse transacciones.

Ej:

	DB::transaction(function(){
		$table = ('tbl_estado');
		$nom = 'est';

		$sc = (new Schema($table))

		->setEngine('InnoDB')
		->setCharset('utf8')
		->setCollation('utf8_general_ci')

		->integer($nom.'_intId')->auto()->pri()
		->varchar($nom.'_varNombre', 100)->comment('hashed')
		->varchar($nom.'_varIcono', 150)->comment('hashed')
		->varchar($nom.'_varColor', 150)->comment('hashed')
		->datetime($nom.'_dtimFechaCreacion')->default('current_timestamp')
		->datetime($nom.'_dtimFechaActualizacion')->default('current_timestamp');

		$res = $sc->create();

		table($table)
		->insert([
			array('est_varNombre'=>'Activo', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),             
			array('est_varNombre'=>'Inactivo', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),              
			array('est_varNombre'=>'Rechazado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                 
			array('est_varNombre'=>'Pendiente', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                 
			array('est_varNombre'=>'Terminado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                 
			array('est_varNombre'=>'En Proceso', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                  
			array('est_varNombre'=>'Anulado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                   
			array('est_varNombre'=>'Revision', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                   
			array('est_varNombre'=>'Aprobado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA')
		]); 
	});


# Ejecutar sentencias SQL en "raw" 

Ej:

	DB::statement("ALTER TABLE tbl_bodega ADD CONSTRAINT FK_bod_idActualizador FOREIGN KEY (usu_intIdActualizador)  REFERENCES tbl_usuario (usu_intId);");


# CREATE TABLE IF NOT EXISTS

Al momento de llamar al método Schema::create() es posible pasar un boolean que indica si la tabla debe crearse solo si existe y también existe el alias Schema::createIfNotExists()  


# El método fromDB()

La clase Schema al momento de instanciarse ejecuta un método fromDB() pero con qué objetivo? 

	function __construct(string $tb_name){
		$this->tables = self::getTables();
		$this->tb_name = $tb_name;
		$this->fromDB();
	}

El método fromDB() analiza y almacena el schema al momento de la instanciación a fin de tenerlo como punto de partida para poder ejecutar comandos del tipo ALTER TABLE que en algunos casos requiere conocer el estado previo: la definición del campo se está agregando o alternado?

Es posible utilizar el método para compactar migraciones o correrlas en reversa sin el método down().


# Ejecutar migraciones

Para ejecutar las migraciones pendiente es con "migrations migrate"

	$ php com migrations migrate

	Migrating '2020_10_28_161483_create_cables.php'
	Migrated  '2020_10_28_161483_create_cables.php' --ok
	Migrating '2020_10_28_161757_create_cable_categories.php'
	Migrated  '2020_10_28_161757_create_cable_categories.php' --ok

Es posible especificar el archivo concreto y/o directorio para un "migrations migrate" y un "migrations rollback"

Ej:
	php com migrations migrate --dir=test --file=2021_12_06_35047920_boletas.php --to:my_db_conn

o

	php com migrations migrate --file=test/2021_12_06_35047920_boletas.php --to:my_db_conn


Los parámetros --dir= y --file= se pueden usar separados, juntos o puede haber casos donde no sean necesarios (ej: sino hay directorio o se quiere ejecutar todo el directorio completo). 


# Ejecutar migraciones por pasos

Es posible ejecutar migraciones, una a una o solo unas pocas por ejemplo para debuguearlas con --step=

Ej:

	$ php com migrations migrate --dir=compania --to=db_153 -step=1

# Saltar migraciones

Puede haber un caso excepcional en que necesitemos saltearnos una migración o varias y para ello contamos con --skip=

Ej:

	$ php com migrations migrate --dir=compania --to=db_153 --skip=1

En principio, --step= y --skip= serían combinables.


# Simular migraciones

Las migraciones se pueden "simular" agregando el parámetro --simulate

Ej:

	$ php com migrations migrate --file=users/0000_00_00_00000001_users.php --simulate


# Volver para atrás 

Para volver para atrás migraciones es con el comando "migrations rollback" pero debe existir el método down() y éste debe habere sido escrito de forma tal que revierta el cambio en la base de datos (es responsabilidad del usuario por ahora)

	$ php com migrations rollback [--step==N | --all]

	Rolling back '2020_10_28_161483_create_cables.php'
	Rolled back  '2020_10_28_161483_create_cables.php' --ok
	Rolling back '2020_10_28_161757_create_cable_categories.php'
	Rolled back  '2020_10_28_161757_create_cable_categories.php' --ok

<-- por defecto solo regresa una migración hacia atrás

Por defecto se ejecutan todas las migraciones pendientes (registradas en la tabla `migrations`) en órden cronológico (que en realidad es órden alfabético para los nombres de los archivos). 


# Especificar archivo de migración 

Es posible dar el archivo concreto de migración a ejecutar:

	$ php com migrations migrate --file=2021_09_13_27908784_user_roles.php

En el dado caso solo se ejecutará esa transacción.

Si en --file se incluye una ruta se ejecutará desde esa ruta (absoluta o relativa). Ej:

	$ php com migrations migrate --file=users/0000_00_00_00000001_users.php


# Especificar el directorio de las migraciones

Se puede brindar el directorio (de momento relativo a la carpeta migraciones) desde el cual se correrán todas las migraciones con el parámetro --dir=

Ej:

	php com migrations migrate --dir=compania_new --to=db_flor


Es posible combinar --dir= con --file=

Ej:

	php com migrations migrate --dir=compania --file=2021_09_28_29110773_0001_tbl_estado_maestro.php --to=db_189 


# Reintentar o forzar migraciones

Si por alguna razón la migración hubiera sido anotada en la tabla "migrations", esta no volverá a correr pero es posible "re-intentar" que la corra con la opción --retry o --force

Ej:

	php com migrations migrate --dir=compania --file=2021_09_28_29110773_0001_tbl_estado_maestro.php --to=db_189 --retry


# Especificar hacia que base de datos iran las migraciones

En el archivo de migración suele incluirse una referencia la conexion a DB a usar pero es posible omitir especificarla y luego correr la migración sobre la base de datos que se requiera pasando el nombre de la conexión a la base de datos con el parámetro --to=

Ej:
	php com migrations migrate --file=compania/2021_09_25_28831244_0001_tbl_estado_maestro.php --to=db_flor |less


# Hacer migraciones "inline"

Se extendió el comando "make migration" para que simplificar el agregado o remoción de campos:

make migration foo --dropColumn=algun_campo
make migration foo --renameColumn=viejo_nombre,nuevo_nombre
make migration foo --renameTable=viejo_nombre,nuevo_nombre
make migration foo --nullable=campo
make migration foo --dropNullable=campo
make migration foo --primary=campo
make migration foo --dropPrimary=campo
make migration foo --unsigned=campo
make migration foo --zeroFill=campo
make migration foo --binaryAttr=campo
make migration foo --dropAttributes=campo
make migration foo --addUnique=campo
make migration foo --dropUnique=campo
make migration foo --addSpatial=campo
make migration foo --dropSpatial=campo
make migration foo --dropForeign=campo
make migration foo --addIndex=campo
make migration foo --dropIndex=campo
make migration foo --trucateTable=campo
make migration foo --comment=campo

En principio no se daría soporte a --addColumn= desde la propia línea de comandos porque la definción de un campo puede incluir varios atributos y sería algo complejo hacerlo inline.


Para construcción de claves foráneas:
        
	--fromField | --fk= | --foreign= 
	--toField= | --references=  | --reference=
	--toTable= | --onTable | --on=
	--onDelete={cascade|restrict|setNull|noAction|setDefault} 
	--onUpdate={cascade|restrict|setNull|noAction|setDefault}
	--constraint=


En si, --fromField=, --fk= y --foreign= son alias como sucede en los demás casos.

Ej:

	make migration foo --fromField=user_id --toField=id --toTable=users --onDelete=cascade --onUpdate=setNull


Además,...

make migration foo --include-defaults (*)
make migration all --include-defaults
make migration all --include-defaults --exclude=belongs_to

* El parámetro --include-defaults crearía o agregaría los campos manejados automáticamente por el framework a excepción de los que se listen bajo --exclude=

Los campos agregados con --include-default serían los definidos en MyModel que por defecto son:

created_at
created_by
...
...
..,


Otra opción es implementar .defaults.php en migrations como constante con --include-defaults algo como:

	///foreign --- references Tabla tbl_estado
    ->foreign('est_intIdEstado')
    ->references('est_intId')
    ->on('tbl_estado')    
    ///foreign --- references Tabla tbl_usuario usu_intIdCreador
    ->foreign('usu_intIdCreador')
    ->references('usu_intId')
    ->on('tbl_usuario')
   ///foreign --- references Tabla tbl_usuario usu_intIdActualizador
   ->foreign('usu_intIdActualizador')
   ->references('usu_intId')
   ->on('tbl_usuario');


Adicional podría estar la opción --include-model-defaults que crearia / agregaría todos los campos presentes en MyModel.php 

Se planea extender las migraciones inline a la creación de tablas con la siguiente sintaxis:

	--field={nombre},clave:valor,clave:valor,....

Ej:

	--field=id,primary,auto,attr:unsigned
	--field=lastname,varchar:60,collation:latin1_general_ci
	etc

# Debugging de migraciones inline

La idea de las migraciones inline es evitar tener que buscar el archivo de migraciones, abrirlo y modificarlo pero sería cuestión de confiar en la migración generada.

Ej:

	php com make migration --table=bar --dir=some_dir --dropColumn=abc --renameColumn=xxx,zzz --nullable=ppp --dropNullable=kkk

Es posible sin embargo, debuguear el archivo generado de migración con los siguientes parámetros:

	--cat					muestra por pantalla (en la terminal) el archivo generado 
	--no-save | --dont		no escribe el archivo

Se habilita la creación de "migraciones inline" para simplificar la creación de migraciones en principio de ALTER TABLEs.

Ej:

	php com make migration --dir=test --table=bar --addPrimary=id 

genera:

	<?php

	use simplerest\core\interfaces\IMigration;
	use simplerest\libs\Factory;
	use simplerest\libs\Schema;
	use simplerest\core\Model;
	use simplerest\libs\DB;

	class Bar implements IMigration
	{
		/**
		* Run migration.
		*
		* @return void
		*/
		public function up()
		{
			$sc = new Schema('bar');
			$sc->field('id')->primary();
			$sc->alter();			
		}
	}

Nuevos parámetros disponibles -generalmente combinables- son:

	--dropColumn=
	--renameColumn=	
	--nullable=
	--dropNullable=
	--primary=
	--dropPrimary=
	--auto=
	--dropAuto
	--unsigned=
	--zeroFill=
	--binary=
	--dropAttr=
	--addUnique=
	--dropUnique=
	--dropSpatial=
	--addIndex=
	--dropIndex=
	--dropForeign=
	--renameTable=
	--truncate	
	--cat
	--no-save

Ej:

	php com make migration --name=nombre_tabla --pri=campo9,campo10 --auto=campo9 --dropColumn=campo1 --renameColumn=campo2,campo2b --removeColumn=campo3 --addUnique=campo2,campo3,campo5 --removeUnique=campo8 --renameTable=nuevo_nombre_tabla --nullable=campo4 --nullable=campo7 --dropNullable=campo8 -unsigned=campo5 --zeroFill=campo5 --nullable=campo15 --dropNullable=campo20,campo21 --dropColumn=campo18,campo30 --cat --no-save

"genera":

	<?php

	use simplerest\core\interfaces\IMigration;
	use simplerest\libs\Factory;
	use simplerest\libs\Schema;
	use simplerest\core\Model;
	use simplerest\libs\DB;

	class NombreTabla implements IMigration
	{
		/**
		* Run migration.
		*
		* @return void
		*/
		public function up()
		{
			$sc->renameTableTo('nuevo_nombre_tabla');
			$sc->dropColumn('campo1');
			$sc->dropColumn('campo3');
			$sc->dropColumn('campo18');
			$sc->dropColumn('campo30');
			$sc->renameColumn('campo2', 'campo2b');
			$sc->field('campo4')->nullable();
			$sc->field('campo7')->nullable();
			$sc->field('campo15')->nullable();
			$sc->field('campo8')->dropNullable();
			$sc->field('campo20')->dropNullable();
			$sc->field('campo21')->dropNullable();
			$sc->field('campo9')->primary();
			$sc->field('campo10')->primary();
			$sc->field('campo9')->addAuto();
			$sc->field('campo5')->zeroFill();
			$sc->unique('campo2','campo3','campo5');
			$sc->dropUnique('campo8');
			$sc->alter();			
		}
	}

Es posible especificar varios campos separados por coma en algunos casos.

Ej:
	--dropNullable=campo20
	--dropNullable=campo21

Equivale a:

	--dropNullable=campo20,campo21

Sin embargo se ha restringido esta opción para no generar confusiones ya que:

	--dropUnique=xxx,yyy,zzz

*no* sería borrar la clave única formada por xxx, yyy, zzz sino por esas tres "constaints" y por ese motivo *no* está disponible ni para --dropIndex= ni --dropUnique= entre otros. 

Actualmente las migraciones "inline" alcanza a los ALTER TABLE. Se planea eventualmente habilitar la creación de tablas via migraciones inline en un futuro.


# Crear migraciones programáticamente

Es posible crear migraciones de forma "programática" instanciando la clase MakeController o MakeControllerBase haciendo uso de la opción  --from_script=  para especificar el cuerpo del script.

La única restricción en caso de querer usarse "make migration" con la opción --from_script= es que el script no puede contener comillas dobles. 

Ej:

		$mgr = new MakeControllerBase();

        $script = "
        ALTER TABLE tbl_preferencias 
            ADD CONSTRAINT FK_tpf_IdEstado FOREIGN KEY (est_intIdEstado)
                REFERENCES tbl_estado(est_intId);";

        $name   = "tbl_preferencias-maestro";

        $folder = "company";

        $mgr->migration("$name", "--dir=$folder", "--from_script=\"$script\"")


También puede ser necesario forzar el nombre de la clase de php dentro del archivo de migración para lo cual se dispone de la opción --class_name=

Ej:

	mgr = new MakeControllerBase();
	// ...

	$mgr->migration("$name", "--dir=$folder", "--from_script=\"$script\"", "--class_name={$row['scr_varNombre']}")


Otra opción para crear un archivo de migración programáticamente sería leyendo el "molde" de una migración que se encuentra en /core/templates/Migration.php y haciendo un reemplazo de substring tal y como lo hace el comando make en MakeControllerBase:

	Strings::replace('### UP', $up_rep, $file);


En teoría sería posible,.....

	/*
		Creo la DB
	*/

	DB::getDefaultConnection();

	$db_name = $data['dba_varNombre'];
	
	$ok = Model::statement("CREATE DATABASE $db_name;");
	

	/*
		Creo las tablas
	*/

	$mgr = new MigrationsController();

	$folder = 'compania'; 
	$tenant = $db_name;

	$mgr->migrate("--dir=$folder", "--to=$tenant");

	/*
		Creo schemas y modelos
	*/

	$mk = new MakeControllerBase();
	$mk->any("all", "-s", "-m", "-f", "--from:$tenant");


# Ayuda 

El comando "migrations" tiene una ayuda que es invocada cuando no se pasan parámetros:

	$ php com migrations


# Multitenant

El framework tiene implementación de multitenencia a varios niveles: tablas, bases de datos y "grupos" de bases de datos.

El método DB::getConnection() permite especificar opcionalmente el identificador de la conexión a base de datos a la que nos queremos conectar y la clase Model acepta una conexión así que es posible hacer lo siguiente:

Ej:

	$conn = DB::getConnection('db2');

	$m = (new Model())
		->setConn($conn)
		->table('cables');
		
	dd($m->get());

Ej:

	DB::getConnection('db2');

	$m = (new Model(true))
		->table('cables');
		
	dd($m->get());

o

	DB::getConnection('db2');

	$m = (new CablesModel())
	->connect();

	dd($m->get());

<-- require de la clase CablesModel y del schema CablesSchema

o 

	DB::getConnection('db2');

	$m = DB::table('cables');
	dd($m->get());

Ej. con migraciones:

	DB::getConnection('db2');

	$sc = new Schema('cables');

	$sc
	->int('id')->unsigned()->auto()->pri()
	->varchar('nombre', 40)
	->float('calibre')

	->create();

Para generar el archivo de migración anterior (las primeras dos líneas) se puede usar --to combinado con --table:

	php com make migration creacion_tabla_cables_bla_bla --to=db2 --table=cables


Nota:

Es importante notar que al hacer uso de config() se accede a una versión en caché del archivo config.php y éste helper es usado internamente por SimpleRest por lo cual lo siguiente *no* funcionará:

	config()['db_connection_default'] = 'db2';
	DB::getDefaultConnection();

De hecho si se hiciera un dd() o var_dump() de config() antes y después de intentar el cambio se verá que nada ha cambiado.

/*
	Incorrecto
*/

	config()['db_connection_default'] = 'db2';
	DB::getDefaultConnection();

	// no se verá reflejado cambio alguno
	dd(DB::getCurrentConnectionId());  

/*
	Correcto
*/

	DB::setConnection('db2');
	dd(DB::getCurrentConnectionId());


# fresh

Con "fresh" podemos hacer un "borrón y cuenta nueva" para migraciones sobre una base de datos en particular:

	php com migrations fresh --from=db_b --force

Cabe notar que comienza haciendo un DROP TABLE sobre cada tabla en la base de datos (esté o no en la tabla de migraciones) por lo cual este comando usado de este modo debe usarse con precaución.

También es posible hacer un "fresh" sobre una migración en particular:

	php com migrations fresh --file=2021_09_14_27910581_files.php --to:main --force

equivale a hacer:

	php com migrations rollback --file=2021_09_14_27910581_files.php --to:main
	php com migrations migrate --file=2021_09_14_27910581_files.php

También es posible hacer un "fresh" sobre migraciones en un directorio. 

Ej:

	php com migrations fresh --file=2021_09_14_27910581_files.php --to:main --force

En principio --file y --dir son combinables de igual forma que con "migrate"


# redo

El comando "migrations fresh" cuando se combina con --file y/o --dir produce el mismo efecto que "migrations redo".

Ej:

	php com migrations redo  --file=2021_09_14_27910581_files.php --to:main
y
	php com migrations fresh --file=2021_09_14_27910581_files.php --to:main

son equivalentes


# Tenancy a nivel de API Rest

Permitir elegir la DB (en realidad la conexión a dicha DB) desde los endpoints para sistemas donde cada cliente tenga su propia base de datos.

El tenant-id permitir que se pueda especificar no solo desde la url y del header sino dentro del payload del access_token 

  ?tenantid=<id>
o
  X-TENANT-ID (header)

Las bases de datos admitidas para un usuario en particular para el caso de autenticación via tokens JWT estaá incluida en el payload como "db_access"

  {
    "sub": "1234567890",
    "name": "<user-name>",
    "iat": 1516239022,
    "userid": "<user-id>",
    "db_access": [
		"<db-connection1>",
		"<db-connection1>",
		..
	]
  }

Cuando un usuario se loguea obtiene las conexiones a las DB(s) que ese usuario puede utilizar como un arreglo llamado "db_access" y estas son devueltas en la respuesta para que esa información pueda incluirse via parámetro ?tenantid=  en cada request para acceder a esas DB(s)

El arreglo "db_access" se arma via hook en el AuthController que es extendido por MyAuthController y es donde se define el método getDbAccess aunque también podría definirse en un Trait.  Ver trait DbAccess

	function getDbAccess($user_id) : Array {}

Un ejemplo de este método sería:

	function getDbAccess($user_id) : Array {
        // casting o validación por seguridad
        $user_id = (int) $user_id;

        $dbs = Model::query("SELECT dba_varNombre FROM `tbl_usuarios_x_base_datos` as uxb
        INNER JOIN tbl_usuario_empresa as u ON u.use_intId = uxb.usu_intIdUsuario 
        INNER JOIN tbl_base_datos as db ON db.dba_intId = bas_intIdBasedatos
        WHERE uxb.`usu_intIdUsuario` = $user_id",  \PDO::FETCH_NUM);

        return array_column($dbs, 0);
    }

https://stackoverflow.com/questions/13761336/rest-api-with-multi-tenant-database-separated-by-client/13764490#13764490
https://medium.com/@vivekmadurai/multi-tenancy-in-rest-api-a570d728620c
https://dzone.com/articles/multi-tenancy-in-the-api-world-made-easy


Ventajas del multi-tenant implementado con múltiples DB(s) ->

  - Ofrecen seguridad extrema (al sistema) si cada usuario solo puede operar sobre una DB en particular. 
  
  Para que tenga sentido habría que crear un usuario del motor de DB (mysql, etc) para manejar cada DB con permisos restringidos a esa DB.

  - Si las DB están distribuidas en distintos servidores (accesibles via API por ejemplo) se puede distrubuir la carga de un servidor creando nuevos usuarios (ej: vendedores) en otro servidor cuando ese esté saturado.


Además del multitenant via DB se pueden tener varios usuarios compartiendo tablas y el sistema es capaz de garantizar el aislamiento de los recursos (registros) de cada usuario gracias al uso del ACL.

Para que la separación de recursos por usuario dentro del ámbito de las tablas de una misma base de datos sea posible es necesario que esté definido el campo 'belongs_to' o equivalente via la propiedad $belongsTo en el modelo de la tabla correspondiente y esté presente en la tabla como tal.  

El campo 'belongs_to' es de manejo automático del framework y se saca provecho definiendo permisos como "read" y "read_all" para las tablas que lo implementan.

Ver sección de configuración de "tentant groups"


# Sub-recursos en las APIs

Se implementan subrecursos permitiendo definir relaciones con otras entidades (que deben tener su correlato en llaves foráneas) en endpoints.

Por ejemplo si se quisiera que se hiciera un "JOIN" entre productos y sus categorías:

	class Products extends MyApiController
	{ 
		static protected $soft_delete = true;

		static protected $connect_to = [
			'product_categories'
		];

		function __construct()
		{       
			parent::__construct();
		}        
	} 

Con el parámetro "_related=1" (por defecto), la salida será algo como:

	{
		"data": {
			"products": {
				"id": 100,
				"name": "Vodka",
				"description": null,
				"size": "2 1/4 L",
				"cost": 201,
				"created_at": "2019-07-04 00:00:00",
				"created_by": null,
				"updated_at": "2019-11-24 22:46:44",
				"updated_by": null,
				"deleted_at": null,
				"deleted_by": null,
				"is_active": 1,
				"is_locked": 1,
				"workspace": "",
				"belongs_to": 90,
				"category": 3
			},
			"product_categories": [
				{
					"id_catego": 3,
					"name_catego": "miscelaneos"
				}
			]
		},
		"status_code": 200,
		"error": "",
		"error_detail": ""
	}


Además es posible "filtrar" cuales de todas las relaciones especificadas en el ApiController correspondiente en la propiedad $connect_to se quiere traer con include=

Ejemplos:

	http://simplerest.lan/api/v1/products?tenantid=az&include=product_categories
	http://simplerest.lan/api/v1/products/145?tenantid=az&_related=true&include=users

Si se especifica el parámetro "include" se asume que se quiere traer las relaciones como si "_related=1"


Es posible formatear el JSON de la respuesta con opciones dentro del config.php 

	'include_enity_name' => true,
	'nest_sub_resources' => false,


Notar que Ud. no debe suprimir el campo con el que se arme la relación entre las tablas. Ej:

	http://simplerest.lan/api/v1/products?tenantid=az&fields=id,name,cost,category&_related=true


    "data": {
        "products": [
            {
                "id": 100,
                "name": "Vodka",
                "cost": 201,
                "category": 3,
                "product_categories": {
                    "id_catego": 3,
                    "name_catego": "miscelaneos"
                }
            },
            {
                "id": 197,
                "name": "Guanabanas",
                "cost": 51,
                "category": 2,
                "product_categories": {
                    "id_catego": 2,
                    "name_catego": "frutas"
                }
            },

Pero si Ud. suprimiera "category" fallará:

	http://simplerest.lan/api/v1/products?tenantid=az&fields=id,name,cost&_related=true

<-- con "fields" especifico campos pero omito category"

Nota: Es importante notar que la propiedad $connect_to es parte de la API y no del Modelo y es obligatorio pasar el parámetro "_related=1" (con guión bajo delante) para habilitar los sub-recursos tanto para el listar como para el ver un recurso individual


# Query hacia sub-recursos

Para referenciar campos en otras tablas (en la misma base de datos) se usa la notatación {tabla}.{campo}

Ej:

	/api/v1/products?valoraciones.texto=bueno
	&product_categories.name_catego=frutas

Inclusive soporta operadores

Ej:

	/api/v1/products?valoraciones.texto=bueno
	&product_categories.name_catego[startsWith]=f#


# Select de campos con HATEOAS

Siempre es posible aplicar filtros y seleccionar que campos se van a mostrar pero el "id" del recurso principal no puede omitirse si se desea traer sub-recursos ya que con él se arman las relaciones.

Ej:

	/api/v1/products?tenantid=az&fields=id,cost

<-- válido

Pero,...

	/api/v1/products?tenantid=az&fields=cost

<-- no traerá subrecursos relacionados


# Creación de recursos con sub-recursos

POST

{
    "data": {
        "products": {
            "name": "Juguito Fruticon",
            "description": "XXXXXXXXX",
            "size": "1L",
            "cost": 351
        },
        "product_categories": [
            {
                "id_catego": 1
            },
            {
                "id_catego": 3
            }
        ]
    }
}


POST

{
    "data": {
        "products": {
            "name": "Juguito Fruticon",
            "description": "XXXXXXXXX",
            "size": "1L",
            "cost": 351
        },
        "product_categories": [
            {
                "id_catego": 1
            },
            {
                "name_catego": "saludable"
            },
            {
                "name_catego": "en_promo"
            }
        ]
    }
}

<-- si existe el registro relacionado que lo relacione y sino que lo cree y lo relacione.

Para no meter todo dentro "data" la forma sería anidar recursos:

POST

{
    "products": {
        "name": "Juguito Fruticon",
        "description": "XXXXXXXXX",
        "size": "1L",
        "cost": 351,

        "product_categories": [
            {
                "id_catego": 1
            },
            {
                "id_catego": 3
            }
        ]
    }    
}

E inclusive podría no incluirse el nombre de la entidad principal quedando simplificado a:

POST

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "product_categories": [
        {
            "id_catego": 1
        },
        {
            "id_catego": 3
        }
    ]
}    

<-- forma elegida y actualmente la única soportada.

Por supuesto podría haber más relaciones, por ejemplo con un usuario:

POST

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "users": {
        "id": 1
    },

    "product_categories": [
        {
            "id_catego": 1           	 <-- solo tiene sentido pasar el ID si es una relación de muchos a muchos
        },
        {
            "id_catego": 3
        },
		{
			"name_catego": "saludable"  <-- puede ser una relación de 1 a muchos o muchos a muchos
		},
		{
			"name_catego": "en_promo"
		}
	]
}   

La relación *debería* poder hacerse no solo por el nombre de la tabla relacionada sino por el campo que es FK, lo cual tiene la ventaja de poder manejar más de una relación entre dos tablas:

POST

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "belongs_to": {							<---    FK
        "id": 1
    },

    "category": [							<---	FK
        {
            "id_catego": 1
        },
        {
            "id_catego": 3
        },
		{
			"name_catego": "saludable"
		},
		{
			"name_catego": "en_promo"
		}
	]
}   

Aclarando dudas,......

Si existe una única relación entre una tabla y otra "users" via la FK "belongs_to" entonces:

POST

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "users": {
        "id": 2
    }
}    

Es equivalente a ....	

POST

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "belongs_to": 2
}    


# Relación de muchos a muchos (M:N)

Si se desea que el framework maneje de forma automática la relación con una tabla, ésta debe agregarse al array $connect_to en la API, sea ésta una tabla directamente relacionada o bien esté del otro lado de una "tabla puente" (referida aquí de forma indistinta como "pivot").

Supongamos que "tbl_categoria_persona" es una tabla relacionada a través de "tbl_categoria_persona_persona", entonces:

Ej:

	class TblPersona extends MyApiController
	{ 
		static protected $soft_delete = true;
		static protected $connect_to = [
			"tbl_estado",
			//  ...
			"tbl_categoria_persona" 
		];	
	} 

Y se puede enviar un JSON como:

POST

	{
		"per_varIdentificacion" : "1152472014",
		"per_varDV" : "0",
		"per_varRazonSocial" : "xyz",
		// ..

		"tbl_categoria_persona": [
			{
				"cap_intId": "10",
				"tbl_categoria_persona_persona.nota": "Esto es una nota"
			},
			{
				"cap_intId": "14"
			} 
		]
	}

Como puede verse es posible enviar campos de la tabla puente si están debidamente cualificados con notación tabla.campo

Veamos otro caso:

Supongamos que existe una relación N:M entre "products" y "tags". Pues bien podría enviarse el ID de cada tag dentro de products:

POST

	{
		"name": "Juguito Fruticon!!",
		"description": "XXXXXXXXX",
		"size": "1L",
		"cost": 351,

		"tags": [
			{ 
				"id_tag": 1
			},
			{ 
				"id_tag": 4
			}
		]
	}    
  
También es posible aunque algo menos performante enviar los campos de los de la tabla relacionada así:

	{
		"name": "Juguito Fruticon!!",
		"description": "XXXXXXXXX",
		"size": "1L",
		"cost": 351,

		"tags": [
			{ 
				"texto": "saludable",
                // ...
			},
			{ 
				"texto": "en promoción",
                // ...
			}
		]
	}   

La única condición para esta última forma es que el conjunto de valores que enviemos determine unívocamente un registro porque sino no se sabría a cual enlazar desde la tabla puente. Caso contrario vería un mensaje de error como el siguiente:

	{
		"status": 400,
		"error": {
			"type": null,
			"code": null,
			"message": "There are more than one rows in tags matching with sent data",
			"detail": null
		}
	}


Notas:  

1) No es necesario agregar la tabla puente al array $connect_to en ningún caso.

2) Si crearan una tabla puente deberán correr el comando:

	php com make pivot_scan --from:una_db_del_tenant

o....

	php com make schema all --from:una_db_del_tenan -f


# Endpoints para tablas puente

También es posible generar endpoints para tablas puente e incluir las relaciones hacia las tablas inmediatamente relacionadas con $connect_to en la api. 


# Actualizar con sub-recursos

En esta versión es posible únicamente actualizar *las relaciones* de la entidad con sus sub-recursos (tablas relacionadas) pero no datos de los sub-recursos (ver más adelante).

Una forma general de hacer un UPDATE que actualice relaciones con sub-recursos sería enviar algo como:  <por implementar>

	PATCH api/v1/products/145?tenantid=az

	{
		"product_categories": {
            "id_catego": 3
		},

		"product_tags": [
            {  
                "id_tag": 293
            }
        ],

    	"valoraciones": [
            {
                "id_val": 1
            },
            {
                "id_val": 3
            },
            {
                "id_val": 5
            }
		]
	}

Esto permitiría enviar varios campos en caso de tratarse de una PRIMARY KEY compuesta sin un campo AUTOINCREMENT o UUID.

Sin embargo, cuando la PRIMARY KEY sea "simple" o exista un campo AUTOINCREMENT o un UUID podria enviarse un array:

	{
		"valoraciones": [1,3,5],
		"product_categories": 3,
		"product_tags": [293]
	}

<-- único formato utilizado de momento (!)

El comportamiento por defecto es *reemplazar* los registros en caso de relaciones "a muchos" pero este comportamiento se puede cambiar para agregar registros sin borrar los previos concatenando en la url el parámetro "_append=true"

Ej:

	PATCH /api/v1/products/145?tenantid=az&_append=true

	{
		"valoraciones": [1,3,5],
		"product_categories": 3,
		"product_tags": [293]
	}


Por supuesto pueden actualizarse campos que son propios de la entidad en cuestión.

Ej:

	PATCH /api/v1/products/145?tenantid=az

	{
		"description": "xyz", 
		"cost": 200,  
		"size": "1.15L",

		"valoraciones": [1,3,5],
		"product_categories": 3,
		"product_tags": [293]
	}


# Generalización de las posibilidades de un PATCH 

Habría 3 casos en general:

a) Recibir solo el ID de un registro. En este caso se haría la relación con ese registro. 

	PATCH api/v1/products/145?tenantid=az

	{
		"description": "xyzz", 
		"cost": 200,  
		"size": "1.15L",
		
		"product_categories": {        
			"id_catego": 3
		},

		 "product_tags": [
			{ "id_tag": 124 }, 

			{ "id_tag": 127 }
		],

		"valoraciones": [
			{
				"valoracion_id": 1
			},
			{
				"valoracion_id": 4

			}
    	]
	}

<-- ya funcional

b) Recibir solo campos distintos del "id". 

	PATCH api/v1/products/145?tenantid=az

	{
    	"valoraciones": [
            {
				"texto": "supremo"   // <-- podría no existir
            },
			{
				"texto": "regular"
            }
		]
	}

Aquí el comportamiento sería:

Para 1:n) -- ok

	Sino existen asociados al registro de la tabla principal => se crearía y asociaría el subrecurso.

Para n:m)

	_append=false (modo edición)

		Se asociarían.

	_append=true

		Se crearían en caso de no existir. Sino ser asociarían.


c) En caso de recibir el "ID" del registro + otros campos 

	PATCH api/v1/products/145?tenantid=az

	{
    	"valoraciones": [
            {
				"id_val": 5,
				"texto": "supremo"   // <-- acá el valor era otro. Se editará  (caso C)
            },
			{
				"texto": "regular" // (caso B)
            }
		]
	}

Idea general: SI el registro del sub-recurso con ese ID existe pero no con esa combinación de valores de campos => se procedería a "editar" el registro del subrecurso.


En general, resumiendo los casos A, B y C:

	- Solo ID (del subrecurso) => asociar
	- Solo otros campos => buscar de asociar o crear y asociar 
	- ID + otros campos => EDITAR  



ACTUALIZACIÓN AL 22-DIC-2021 ****

Ya es posible hacer esto:

	PATCH /api/v1/products/145?tenantid=az&_append=false

	{
    "description": "xyz", 
    "cost": 200,  
    "size": "1.15L",
    
    "product_categories": {
        "category": 1
	},

    "users": [
        {
            "created_by": 173,
            "belongs_to": 142
        }
    ],

    "product_tags": [
        { "id_tag": 95 }, 
        { "id_tag": 100 }
    ],

    "valoraciones": [3, 2]
}


Y para relaciones muchos a muchos (N:M),...

PATCH /v1/products/145?tenantid=az

Ej:
	{
		"valoraciones": [
			{
				"id_val": 5  <-- PK de la tabla del sub-recurso ("valoraciones")
			},
			{
				"id_val": 3
			}
		]
	}

También es válido lo siguiente:

PATCH /v1/products/145?tenantid=az

	{
		"valoraciones": [
			{
				"id_val": 5   <-- PK de la tabla del sub-recurso ("valoraciones")
			},
			{
				"valoracion_id": 3   <-- FK en la tabla puente
			},       
		]
	}


En este caso "valoraciones" es la tabla del otro lado del puente y "valoracion_id" es la FK que apunta hacia la tabla "valoraciones" 

Notas: 

En relaciónes 1:n o n:m si "_append=false" (modo de "edición") hay "eliminación" de registros que ya no cumplan con la relación. Podrían quedar apuntado a NULL pero solo si la FK es nullable y como no siempre será el caso de momento no se implementa así.

Cuando la relación es "a uno" o sea 1:1 o n:1, no aplica el parámetro "_append" (true o false da lo mismo)


ACTUALIZACIÓN AL 26-DIC-2021 ****

Casos (b) y (c) ya funcionales para relaciones '1:1' y 'n:1'  (al 26-dic)

Ej:

PATCH

	{
		"description": "xyzz", 
		"cost": 200,  
		"size": "1.15L",
		
		"product_categories": {        
			"id_catego": 1,
			"otro_campo": "XXX"
		},

		"users": [
        {
            "created_by": 1,
            "belongs_to": 5
        }
    ]
	}


ACTUALIZACIÓN AL 27-DIC-2022

Ya es posible para relaciones 1:n, crear sub-recursos sino existen.

PATCH

	{
		"description": "xyzz", 
		"cost": 200,  
		"size": "1.15L",
		
		"product_tags": [
			{ 
				"name": "N3",
				"comment": "P305"
			},
			{ 
				"id_tag": 103
			}
		]
	}


ACTUALIZACIÓN AL 28-DIC-20202

Para relaciones 1:n ya es posible recibir registros de sub-recursos con ID + otros campos  (caso C)

Ej:

	PATCH http://simplerest.lan:8082/api/v1/products/145?tenantid=az&_append=false

	{
		"description": "xyzz", 
		"cost": 228,  
		"size": "1.15L",
		
		"product_tags": [  
			{
				"name": "NNNMMM",
				"comment": "bla bla"
			},      
			{ 
				"id_tag": 523,         <---- nuevo 
				"name": "N33.0",
				"comment": "P333"
			},
			{ "id_tag": 128 },
			{ "id_tag": 103 }
		]
	}


Se ignora el "append mode" (se considera false) pero podría implementarse así:

Para "append mode" en false:

	Si no existe el subrecurso con ese ID => 404 Not found. 
	En caso de existir el subrecurso, se *edita* reemplazando los campos por los aportados.

Para "append mode" en true:

	Si no existe el subrecurso con ese ID => podría crearse con ese ID.
	En caso de existir el subrecurso, se *edita* reemplazando los campos por los aportados.


ACTUALIZACIÓN AL 30 de DICIEMBRE de 2021

Ya funcionan los PATCH con ID + otros campos

Ej:

    PATCH /api/v1/products/145?tenantid=az&_append=true

	{
		"valoraciones": [
			{
				"id_val": 1,
				"texto": "maluco"
			},
			{
				"valoracion_id": 2,
				"texto": "regularcito!"
			}       
		]
	}


Notas:

- Puede entregarse la PK del subrecurso o bien la FK hacia el mismo.


# Schema y las reglas de validación via endpoint

Pasando los parámetros _schema=true o _rules=true en cualquier endpoint se obtienen el schema completo y las reglas de validación en particular respectivamente.

Ej: 

	GET http://simplerest.lan/api/v1/products?tenantid=az&_rules=1

Rta:

	{
		"rules": {
			"id": {
				"type": "int"
			},
			"name": {
				"type": "str",
				"max": 50,
				"required": true
			},
			"description": {
				"type": "str",
				"max": 240
			},
			"size": {
				"type": "str",
				"max": 30,
				"required": true
			},
			"cost": {
				"type": "int",
				"required": true
			},
			"created_at": {
				"type": "datetime"
			},
			"created_by": {
				"type": "int"
			},
			"updated_at": {
				"type": "datetime"
			},
			"updated_by": {
				"type": "int"
			},
			"deleted_at": {
				"type": "datetime"
			},
			"deleted_by": {
				"type": "int"
			},
			"is_active": {
				"type": "bool"
			},
			"is_locked": {
				"type": "bool"
			},
			"workspace": {
				"type": "str",
				"max": 40
			},
			"belongs_to": {
				"type": "int"
			},
			"category": {
				"type": "int"
			}
		}
	}


# UUIDs

El framework reconoce a un campo como tipo "uuid" cuando el nombre es justamente "uuid" o "guid" de tipo compatible con un string y tiene el atributo de PRIMARY KEY. 

Cuando las condiciones mencionadas se cumple, se incluye de forma automática el trait para manejo de Uuids y el framework se encarga de gestionar esta funcionalidad.


# Librerías

	Se pueden crear cuantas librerías se requiera. Éstas deben ser clases y usar namespaces correctamente por lo cual se sugiere crearlas via comando make:

		php com make lib mi_libreria

	o ...

		php com make lib folder/mi_libreria

	y si fuera necesario forzar la creación del archivo use -f o --foce

		php com make lib folder/mi_libreria -f

Incluso dentro de app/core

Ej:

	php com make lib HtmlBuilder/admin_lte --core


# Helpers

	Un helper es un conjunto de funciones por fuera del ámbito de una clase y su propósito es hacer más fácil la utilización de funcionalidades de uso recurrente.

	Para crear un helper:

		php com make helper mi_helper

	o ...

		php com make helper folder/mi_helper

	Los helpers tienen su "autoload" por lo cual cualquier archivo helper será cargado automáticamente y por lo mismo no debe abusarse de esta característica para no degradar la performance.

	El autoload de helpers está disponible en controladores, modelos y vistas pero no el config.php ni el index.php 


# Service Providers

El framework provee una forma de "plugins" o "paquetes" inspirada en la de Laravel. Los paquetes pueden alojarse en cualquier parte pero en /packages hay un paquete de demostración.

El primer paso es crear la ruta donde alojaremos el paquete y por convención (inspirada en Laravel) será dentro de /packages. Cada paquete tiene un nombre conformado por dos partes: [VENDOR or CREATOR] / [PACKAGE NAME]

Luego debemos inicializar Composer dentro del directorio creado lo que generará el archivo composer.json

	composer init

Los paquetes deben registrarse en config.php agregándose a $providers[] 

	/*
		Service Providers
	*/

	'providers' => [
		devdojo\calculator\CalculatorServiceProvider::class,
		// ...
    ],


Además debe registrarse en Composer (composer.json a nivel de root) agregando el bloque:

	"autoload": {
		"classmap": [
			"database"
		],
		"psr-4": {
			"App\\": "app/",
			"Devdojo\\Calculator\\": "packages/devdojo/calculator/src"
		}
	},

y correr el comando

	composer dump-autoload
	

Actualmente el soporte solo cubre la rutas con funciones anónimas y controladores. Falta agregar soporte para migraciones, traducciones, vistas, etc.

Los paquetes funcionan *solamente* con rutas y *no* con el FrontController.

Un Service Provider debe extender la clase ServiceProvider y de mínima implementar el método boot() al inicio de la aplicación.

	/**
     * Bootstrap the application services.
     *
     * @return void
     */
    public function boot()
    {
        
    }

    /**
     * Register the application services.
     *
     * @return void
     */
    public function register()
    {
       
    }     


Leer 
https://devdojo.com/devdojo/how-to-create-a-laravel-package


# Como servir vistas en el FrontEnd

Si bien SimpleRest es un framework RAD se pensó para crear APIs, implementa la arquitectura Modelo-Vista-Controlador (MVC) y por ende es capaz de servie vistas.

Las vistas son servidas desde los controladores así que como priemr paso necesita es tener un controlador o crearlo:

	php com make controller mi_controlador

Luego dentro debe tener un método que servirá la vista llamando a $this->view('nombre-vista')

	function mi_metodo_de_controlador(){
		// ...

		$this->view('mi_archivo_vista.php');
	}
	
La vista puede requerir de datos y éstos son proporcionados por el controlador como un array con el nombre de las variables y sus valores. Ej:

	$this->view('mi_archivo_vista.php', [
		'nombre' => 'Pablo',
		'apellido' => 'Bozzolo'
	]);

O bien se puede utilizar el helper view()

	view('mi_archivo_vista.php', [
		'nombre' => 'Pablo',
		'apellido' => 'Bozzolo'
	]);

Y ya dentro de la vista, se crearan las variables $nombre y $apellido así:

<!-- Vista mi_archivo_vista.php -->
<?php

	var_dump($nombre); // Pablo
	var_dump($apellido);  // Bozzolo
?>

Por supuesto que pueden pasarse arrays. Ej:

	view('agenda.php', [
			'citas' => [
				[ 'name' => 'Visitar al cliente X', 'datetime' => '21-Set 15:00:00' ],
				[ 'name' => 'Completar proyecto Z', 'date' => '23-Set 00:00:00' ]
			],
	]);

Por defecto la variable $title en la vista deriva del nombre del controlador (ej: para el HomeController será "Home") pero se puede pasar el "title" a la vista:

	view('agenda.php', [
			'citas' => [
				[ 'name' => 'Visitar al cliente X', 'datetime' => '21-Set 15:00:00' ],
				[ 'name' => 'Completar proyecto Z', 'date' => '23-Set 00:00:00' ]
			],
			'title' => 'Agenda de citas'
	]);

Lógicamente el template debe manejar la varible $title para que se vea reflejado en el navegador:

	<head>
		<title><?= $title ?? ''; ?></title>
	</head>

Las vistas pueden contener HTML, PHP, CSS y JavaScript. Para los assets se cuenta con el helper asset()

Ej:

	<?= asset('img/logo.png') ?>" style="height: 100px;" />

Los assets se encuentran dentro de la carpeta public/assets y dentro la estructura es libre o sea puede organizarse de muchas formas:

	a)

	public/assets/
					css
					images
					js

	b)

	public/assets/
					módulo/
							css
							images
							js


Inclusión de css en vistas y widgets

Si el css es puntual y no justificara crear un archivo .css podría usarse el helper css()

	css('
		.card-primary.card-outline {
			border-top: 3px solid #007bff;
		}
	');

Ej:

	static function card(mixed $content = null, Array $attributes = [], ...$args){
        css('
            .card-primary.card-outline {
                border-top: 3px solid #007bff;
            }
        ');

		// ...
	}

Pero en caso de ser un css de varias líneas de código, se recomienda utilizar include_css()

Ej:

	static function searchTool(mixed $content = 'Search', Array $attributes = [], ...$args)
    {
        include_css(WIDGETS_PATH . __FUNCTION__ . '/' . __FUNCTION__ . '.css');

		// ..
	}

O en una vista:

	<?php
		include_css(WIDGETS_PATH . 'login/login.css');
	?>

O usando include_widget_css() como atajo.

Ej:

	static function carousel(mixed $content = [], Array $attributes = [], ...$args){
        include_widget_css(__FUNCTION__);

		// ...
	}



# Templates

Por defecto se carga el template "app_layout.php" pero se pueden usar cuantos templates se desee y éste es especificado como tercer parámetro del método view()


# Vistas parciales

Se pueden incluir "secciones" por medio del helper section() y éstas pueden mostrarse de forma condicional:

Ej:

	<!DOCTYPE html>
	<html lang="es">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<title><?= $title ?? ''; ?></title>

		<base href="<?php echo $base_url; ?>">

		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">   
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	</head>
	<body>
		<?php
			if (!isset($hidenav) || !$hidenav){
				section('navbar.php'); 
			}            
		?>
		
		<div class="container">
			<main>
			<?php echo $content; ?>
			</main>
		</div>
	</body>
	</html>


En el template y en las vistas está disponible la variable $ctrl que alamcena el nombre del controlador actual tal y como aparece en la url. Ej: /home o /home/algo vale "home"


# Pasaje de variables hacia sub-vistas

Las variables pueden pasar del controlador a las vistas y el mismo truco puede usarse para pasar nuevamente variables desde por ejemplo el layout a una "section" así o de una vista a una subvista (section) o de una section a otra (sub-section)

	<?php
		section('navbar.php', [
			'my_var' => $my_var
		]);
    ?>


# Cache

Es posible cachear las vistas especificando el tiempo de expiración expresado en segundos como cuarto parámetro de view() y en caso de pasar -1 no expirá nunca hasta que el archivo no sea borrado.

Ej:

	$this->view('login.php', null, null, -1);

Para borrar la cache correspondiente a una vista se debe pasar la misma ruta que se envió a view() a View::destroyCache()

Ej:

	View::destroyCache('login.php');

A futuro se implementará un comando para la limpieza de la cache de la siguiente manera:

	php com cache clear [ --view={view_path} ]

El comando podrá borrar otro tipo de caches como la del Acl.


Hooks 

	function onCacheExpired(string $view_path)
    function onCacheWritten(string $view_path)

Los hooks están presentes en la clase MyView.


# Hookear la clase View

La clase View es extendida convenientemente como MyView a fin de poder agregar funcionalidad sin tener que tocar la clase View directamente que es parte del Core y sería sobreescrita al actualizar SimpleRest.

Ej:

	class MyView extends View 
	{
		function __construct(string $view_path, array $vars_to_be_passed  = null, string $layout = 'app_layout.php', int $expiration_time = 0)
		{
			/*
				Agregado
			*/
			
			$vars_to_be_passed['my_var'] = 'Hello World!';

			parent::__construct($view_path, $vars_to_be_passed, $layout, $expiration_time);
		}
	}


# Internacionalización

Para las traducciones se utiliza i18n y estas se alojan en el directorio app\locale y las mismas deben ser compiladas. Para Windows existe un .bat de ejemplo que realiza el proceso: compile_i18n.bat

La función de traducción es _() y esta se ha utilizado en la clase Validator y está pendiente de ser utilizada para el resto de clases provistas por SimpleRest.

El cambio de lenguaje lo maneja automáticamente SimpleRest ya sea via el parámetro GET "lang" (tiene prioridad o bien mediante el header "Accept-Language". Internamente se utliza la función helper setLang()

Los países están codificados en dos dígitos según la ISO-3166.

Ej:  

	/api/v1/mi_tabla?tenantid=db_xyz&lang=es_CO

También es posible hacer referencia solo al lenguaje y no al país:

Ej:  
	/api/v1/mi_tabla?tenantid=db_xyz&lang=es
 

Los textos a ser traducidos se encuentran config/messages.php y son compilados a config/msg_const.php mediante el comando:

	php com make system_constants

El comando genera el archivo app/core/libs/SystemConstants.php y *debería* también generar un array para el dominio "system" que sería compilado a .po


Conversión de arrays a archivos .po y .mo

El helper exportLangDef() exporta a .po todos arrays de traducciones (de cada dominio) al subfolder LC_MESSAGES dentro de cada folder de lenguaje.

El pre-requisito es tener los archivos de cada dominio con el nombre {dominio}.php en:

	app/locale/xx_XX

Ej:

	<?php

	# app/locale/pt_BR/import-quoter.php

	$intl = [
		'quotation' => 'cotação',
		'shipping quotation' => 'cotação de transporte',
		'quote' => 'citação',
		'item' => 'item',
		'value' => 'valor',
		'currency' => 'moeda',
		'purchase value in dollars' => 'valor de compra em dólares',
		'taxa a ser cobrada por ?' => 'tarifa a cobrar por ?',
		'gross weight' => 'peso bruto',
		'air freight (?-?)' => 'frete aéreo (?-?)',
		'insurance (?%)' => 'seguro (?%)',
		// ...
	];

Al ejecutar exportLangDef() la salida sería algo como:

	Generating /home/www/simplerest/app/locale/it_IT/LC_MESSAGES/all.po
	Compiling to /home/www/simplerest/app/locale/it_IT/LC_MESSAGES/all.mo
	Compilation to /home/www/simplerest/app/locale/it_IT/LC_MESSAGES/all.mo -- ok

	Generating /home/www/simplerest/app/locale/pt_BR/LC_MESSAGES/all.po
	Compiling to /home/www/simplerest/app/locale/pt_BR/LC_MESSAGES/all.mo
	Compilation to /home/www/simplerest/app/locale/pt_BR/LC_MESSAGES/all.mo -- ok

	Generating /home/www/simplerest/app/locale/es_AR/LC_MESSAGES/all.po
	Compiling to /home/www/simplerest/app/locale/es_AR/LC_MESSAGES/all.mo
	Compilation to /home/www/simplerest/app/locale/es_AR/LC_MESSAGES/all.mo -- ok

Para que la generación sea "silenciosa" usé previamente:

	StdOut::hideResponse();


Desde la línea de comandos:

	php com make trans
o
	php com make trans --po --mo

Para solo archivos .po

	php com make trans --po


Exportar y compilar en otra ruta

Ej:

	php com make trans --dir='/home/www/woo1/wp-content/plugins/import-quoter-cl/locale'


Forma de uso

Ej:
	setLang('es_AR');
        
	// i18n
	bindtextdomain('validator', LOCALE_PATH);
	textdomain('validator');

	// No se recibieron datos
	dd(_('No data'));

O

	setLang('es');
        
	// i18n
	bindtextdomain('validator', LOCALE_PATH);
	textdomain('validator');

	// No se recibieron datos
	dd(_('No data'));


Notas:

Para que funcione setlocale() debe instalarse cada lenguaje:

Ej:

	sudo locale-gen de_DE.UTF-8
        
setlocale() puede llevar a tener problemas con MySQL y otros motores.

setlocale() debería solo correrse con un PHP compilado como "mono-hilo" ya que
"If you are running PHP on a multithreaded server API , 
you may experience sudden changes in locale settings while a script is running, 
though the script itself never called setlocale(). 
This happens due to other scripts running in different threads of the same process at the same time, 
changing the process-wide locale using setlocale(). 
On Windows, locale information is maintained per thread as of PHP 7.0.5."


# Compresión la respuesta

Si en header Accept-Encoding se envia gzip, se hará la compresión.

Si se desea cambiar el algoritmo también puede hacerse enviando como parámetro accept_encodig. 

Ej:

	GET api/v1/baz?tenantid=az&accept_encodig=identity


Solamente se está manejando gzip e identity (sin compresión).

Nota: NO es necesario usar la compresión en Apache ya que se hace directamente con PHP usando gzcompress()

Ver
http://www.webcodingtech.com/php/gzip-compression.php
https://betterexplained.com/articles/how-to-optimize-your-site-with-gzip-compression/


Verificar que la compresión funcione!
http://www.gidnetwork.com/tools/gzip-test.php


# NGINX web server

Agregar en el bloque lo siguiente:

	location /{
		rewrite ^([^.]*[^/])$ $1/ permanent;
		try_files $uri $uri/ /index.php?q=$uri&$args;
	}


# Envio de correos

Mediante Mails::sendMail() es posible enviar correos de forma muy sencilla.

Ej:

	dd(
		Mails::sendMail('boctulus@gmail.com', 'Pablo', 'Pruebita 001JRB', 'Hola!<p/>Esto es una más <b>prueba</b> con el server de JuamMa<p/>Chau'
	)); 

Lógicamente es más sencillo con la sintaxis de PHP 8

	dd(
		Mails::sendMail(
			to_email:'boctulus@gmail.com', 
			subject:'Prueba B8',
			body:'HEY!!!!<p/>Esto es una más <b>prueba</b> con el SMTP de <i>Brimell</i><p/>Chau'
		)
	);  

Especificar el from (distinto al por defecto)

	dd(
		Mails::sendMail('mueblesultra@gmail.com', '', 'Prueba B3', 'HEY!<p/>Esto es una más <b>prueba</b> con el SMTP de <i>Brimell</i><p/>Chau', null, null, 'cotizacion@brimell.cl', 'Brimell', 'boctulus@gmail.com'
	)); 

Incluyendo "attachments" (archivos adjuntos)

Ej:

	$path = ETC_PATH . 'example.sql';

	dd(
		Mails::sendMail('mueblesultra@gmail.com', '', 'Prueba B3', 'HEY!<p/>Esto es una más <b>prueba</b> con el SMTP de <i>Brimell</i><p/>Chau', null, $path, 'cotizacion@brimell.cl', 'Brimell', 'boctulus@gmail.com'
	));   






# Consumo de APIs

El framework provee la función Url::consume_api() para el consumo de APIs. 

    consume_api(

        string $url, 
        string $http_verb, 
        $body = null, 
        ?Array $headers = null, 
        ?Array $options = null, 
        $decode = true
    )

En caso de éxito responde con algo como:

    Array
    (
        [data] => Array
            (
                [userId] => 1
                [title] => Some title
                [body] => Other long description
                [id] => 101
            )

        [http_code] => 201
        [error] => 
    )

En caso de fallo (http status code 3xx o 4xx o 5xx) algo como:

    Array
    (
        [data] => Array
            (
                [error] => Un error cualquiera
            )

        [http_code] => 400
        [error] => 
    )

Ej:

# Leer un recurso

	use simplerest\libs\Url;

	// ...

	$res = Url::consume_api('https://jsonplaceholder.typicode.com/albums', 'GET');
	dd($res);

Y bien podría haber una lógica de control de errores:

	if ($res['http_code'] != 200){
        // notificar error
		return;
	} else {
        $data   = $res['data'];
        
        //...   
    }

Por defecto se hace un "decode" de la respuesta o sea se la trata como un JSON pero se puede des-activar ese comportamiento de dos formas:

1) Pasando un Accept de tipo 'text/plain' o ...

	$res = Url::consume_api('http://xxxxxxxxxxxxx', 'GET', null, [
		'Accept' => 'text/plain'
	]);

2) Pasando como 6to parámetro false 

	$res = Url::consume_api('http://xxxxxxxxxxxxx', 'GET', null, null, null, false);
  
# Crear un recurso

	$data = '{
		"userId": 1,
		"title": "Some title",
		"body": "Some long description"
  	}';

	$res = Url::consume_api('https://jsonplaceholder.typicode.com/posts', 'POST', $data);
	dd($res);  

Ej:

# Body como array

	$data = [
            "userId" => 1,
            "title" => "Some title",
            "body" => "Other long description"
	];

	$res = Url::consume_api('https://jsonplaceholder.typicode.com/posts', 'POST', $data);
	dd($res);  

Ej: 

# Enviar un archivo

	$xml_file = file_get_contents(ETC_PATH . 'ad00148980970002000000067.xml');

	$response = Url::consume_api('http://localhost/pruebas/get_xml.php', 'POST', $xml_file, [
		"Content-type" => "text/xml"
	]);

donde get_xml.php puede ser algo como:

	<?php

	try {
		$postData = file_get_contents('php://input');
		$data = @file_put_contents("file.xml", $postData);

		if ($data == false){
			throw new Exception("Error trying to write file", 1);
		}

		echo json_encode(['data' => $data ]);
	} catch (\Exception $e) {
		echo json_encode(['error' => $e->getMessage()]);
	}


Todos los verbos http (GET, POST, PUT, PATCH,...) son soportados


# Headers

El envio headers se puede hacer como array asociativo o un simple array de strings (no-asociativo).

Ej:
	// (no-asociativo)

	$response = Url::consume_api("https://onesignal.com/api/v1/notifications", 'POST', ['x' => 'y'], 
		[             
			'Content-Type: application/json',
			'Authorization: Basic ' . 'xxxxxxxxxxxx'
		]
	);

o

Ej:
	// (asociativo)

	$response = Url::consume_api("https://onesignal.com/api/v1/notifications", 'POST', ['x' => 'y'], 
		[             
			'Content-Type' => 'application/json',
			'Authorization' => 'Basic ' . 'xxxxxxxxxxxx'
		]
	);


# Curl options

Es un array asociativo de opciones para la librería curl.

Ej:

	$response = Url::consume_api("https://onesignal.com/api/v1/notifications", 'POST', ['x' => 'y'], 
		[             
			'Content-Type: application/json',
			'Authorization: Basic ' . 'xxxxxxxxxxxx'
		],  
		
		[
			CURLOPT_RETURNTRANSFER => true,
			CURLOPT_HEADER => false
		]
	);


# Autorización 

Web tokens pueden ser enviados a la función consume_api() via el array de headers.

Ej:

    $response = Url::consume_api('http://xxxxxxxxx:8080/api/some_resource', 'GET', null, [
        "Authorization" => "Bearer xxxxxxxxxxxxxxxxxxxxxxxxxx"
    ]);


# Encodeo base 64

En caso de "encodear" el body del request se debe usar el Content-type correcto.

Ej:

    $encoded = base64_encode($file);

    $response = Url::consume_api('http://xxxxxxxxx:8080/api/some_resource', 'POST', $encoded, [
        "Content-type"  => "text/plain"
    ]);



### Componentes del core del framework

# Base de datos

Se consideran componentes del core de SimpleRest cualquier archivo dentro de /app/core y también las librerías y helpers que vienen con el framework ya que muy probablemente son dependencias del mismo.

Específicamente respecto de lo que es manejo de base de datos se pueden enumerar 4 clases y el helper db.php 

Model (.php)		Query Builder
Paginator (.php)	Paginador
DB (.php)			Administración de conexiones
Schema (.php)		Escritura y lectura sobre RDBMS 
db (.php) 			Helpers para bases de datos

Relación:

db -----> DB <------> Model --> Paginator

Schema es usado por las clases MakeControllerBase (comandos "make") y MigrationsController (migraciones).
No hay dependencias entre Schema y Model porque la segunda solo crea comandos pero no los ejecuta.

Actualmente Model soporta MySQL / MariaDB / SQLite y Postgres pero Schema es más limitada y se planea extender su funcionalidad para cubrir más RDBMS mediante traits. 


# Http

Relacionado con el tema de peticiones http podemos enumerar las siguientes clases y helpers:

Response 			Manejo de respuestas http		
Request				Procesamiento de peticiones http
FrontController		Front controller
Route				Enrutador
Url					Librería
ApiController 		Creación de APIs Restful

Hay más clases relacionadas pero se mencionaron las principales.


# Validaciones

Validator
ValidationRules


# Archivos

Files				Utilidades para el manejo de archivos
MultipleUploader	Manejador de uploads


# Seguridad

Acl
FoldersAclExtension


# Dumping de variables

VarDump				


# Manejo de errores

ExceptionHandler 	Trait 


# Manejo de cadenas

Strings 			Librería


# Envio de correos

Mails				Librería


### Strings

La clase Strings provee una batería de métodos para manejo conveniente de cadena de caracteres.

	tabulate(string $str, int $tabs, ?int $first = null, ?int $last = null)
	diff(string $s1, string $s2)
	rTrim(string $needle, string $haystack)
	trimFromLastOcurrence(string $substr, string $str)
	match(string $str, $pattern, $result_position = null)
	matchOrFail(string $str, string $pattern, string $error_msg = null)
	slice(string &$str, string $pattern, callable $output_fn = NULL)
	sliceAll(string &$str, string $pattern)
	matchParam(string $str, $param_name, ?string $arg_expr = '[a-z0-9A-Z_-]+')
	camelToSnake(string $name)
	snakeToCamel(string $name)
	endsWith(string $substr, string $text, bool $case_sensitive = true)
	contains(string $substr, string $text, bool $case_sensitive = true)
	containsAny(Array $substr, $text, $case_sensitive = true)
	containsWord(string $word, string $text, bool $case_sensitive = true)
	containsWords(Array $words, string $text, bool $case_sensitive = true)
	containsAnyWord(Array $words, string $text, bool $case_sensitive = true)
	equal($s1, $s2, $case_sensitive = true)
	replace($search, $replace, &$subject, $count = NULL, $case_sensitive = true)
	replaceNth(string $search, string $replace, string $subject, int $occurrence)
	removeMultipleSpaces($str)
	stringTochars($s)
	replaceFirst($from, $to, $subject)   ---revisar
	replaceLast($search, $replace, $subject) --revisar
	middle(string $str, int $ini, ?int $end = null) : string
	left(string $str, $to_pos)
	right(string $str, $from_pos)
	getClassName(string $file_str, bool $fully_qualified = true)
	getClassNameByFileName(string $filename, bool $fully_qualified = true)
	filter(Array $reg, Array $conditions)
	removeUnnecessarySlashes(string $path): string
	removeTrailingSlash(string $path): string
	addTrailingSlash(string $path): string


Strings::match() verifica si el string cumple con el patrón o alguno de los patrones proporcionados.

Ej:

	$o = '--name=xYz';
	d(Strings::match($o, '/^--name[=|:]([a-z][a-z0-9A-Z_]+)$/'));

Ej:

Se pueden evaluar varios patrones y ver si alguno cumple.

	$o = '--nama=xYz';
	d(Strings::match($o, [
		'/^--name[=|:]([a-z][a-z0-9A-Z_]+)$/',
		'/^--namae[=|:]([a-z][a-z0-9A-Z_]+)$/',
		'/^--nombre[=|:]([a-z][a-z0-9A-Z_]+)$/'
	]));


Strings::matchParam() parsea parámetros del tipo --nombre_param={valor}

Ej:

Un parámetro $o tiene el patrón --renameTable={algo} ?

	$_renameTable  = Strings::matchParam($o, 'renameTable');

Ej:

El parámetro $o tiene un parámetro --pri= o --primary= donde el argumento puede ser cualquier cosa (.*) ?

	$_primary  = Strings::matchParam($o, ['pri', 'primary'], '.*');

Ej:

El parámetro *no* lleva argumento y puede ser --dropPrimary o --delPrimary 

	$_dropPrimary  = Strings::matchParam($o, ['dropPrimary', 'delPrimary'], null);


### Variable dumping 

Para imprimir en pantalla o en la terminal de forma sencilla cualquier tipo de dato el framework provee las clases VarDump, StdOud y el helper dd()

El helper dd() y d() son solo atajos para VarDump::dd()

	dd($val, $msg = null, bool $additional_carriage_return = false)
	d($val, $msg = null);

Mientras que dd() por defecto no agrega retornos de carro adicionales, d() si lo hace.

Ej:

	dd([4,5, 7], "My Array");
	dd('hola!', null);
	dd(677.55, null);
	dd(true, 'My bool');

Salida:

	--[ My Array ]-- 
	Array
	(
		[0] => 4
		[1] => 5
		[2] => 7
	)

	hola!

	677.55
	--[ My bool ]-- 
	true


La clase StdOut está pensanda para simplificar el uso de la clase Debug en aplicaciones de consola (aunque su uso no es exclusivo) y permite "encender" o "apagar" la salida fácilmente sin necesidad de retener el buffer.

	static function hideResponse()
	static function showResponse()
	static function pprint($v, bool $additional_carriage_return = false))


### Perfilador del código

Para el perfilado de tiempos de ejecución SimpleRest provee la librería Time.

Lo primero es elegir el intervalo de medición (NANO, MICRO o MILI segundos). Se puede especificar cuántas intereaciones de van a realizar y suprimir la salida estándar con Time::noOutput().

Ej:

	Time::setUnit('MILI');
	Time::noOutput();

	$conn = DB::getConnection();

	$t = Time::exec(function() use ($conn){         
		$sql = "INSERT INTO `baz2` (`name`, `cost`) VALUES ('hhh', '789')";
		$conn->exec($sql);
	}, 1);  
	
	dd("Time: $t ms");  


### La clase Files: utilidades de archivos

La librería Files tiene gran cantidad de funcionalidades como de borrado y copiado recursivo de archivos y directorios. Backups, etc.

replace(string $filename, $search, $replace) 						similar a str_replace() pero sobre archivos
pregReplace(string $filename, $search, $replace)					similar a preg_replace() pero sobre archivos
isAbsolutePath(string $path)										devuelve si la ruta es absoluta
getAbsolutePath()													retorna rota absoluta a ROOT_PATH
recursiveGlob($pattern, $flags = 0)									similar a glob() pero recursivo
getDir(string $path)												extrae el directorio de un path.
setBackupDirectory(string $path)									setea un path para hacer backups
cp(string $ori, string $dst, $simulate = false, $overwrite = true)	copia de archivos individuales con opción de backup
copy(string $ori, string $dst, ?Array $files = null, $except = [])	copia recursiva de archivos con opción de backup (*)
delete(string $file)												borra un archivo individual
deleteOrFail(string $file)											borra un archivo individual y sino existe, lanza excepción
globDelete($dir, ?string $glob_pattern = '*.*', $recursive = false)	borra archivos aplicando un patrón glob. No toca los directorios.
delTree(string $dir, bool $include_self = false)					borra archivos y directorios recursivamante pero puede conservar el padre.
logger($data, $file = 'log.txt')									hace un log de la data enviada. Exporta con json_encode()
dump($object, $filename = 'dump.txt', $append = false)				similar a logger() pero exporta con var_export
mkDir($dir, int $permissions = 0777, $recursive = true)				make directory recusivo
mkDirOrFail($dir, int $permissions = 0777, $recursive = true)		crea directorio o si falla genera excepción.
zip(string $source, string $destination, ?Array $except = null)		zipea un archivo o directorio. Acepta ignorados

Nota:

Files::copy() permite especificar patrones glob tanto para incluir como excluir archivos pero en estos casos hacen referencia a ROOT_PATH y son recursivos (todas las ocurrencias).


### Copiar archivos

Ej:

Files::cp('updates/2021-12-12-0.5.0-alpha/files/app/controllers/ShopiController.php',
'app/controllers/ShopiController.php');


Ej:

Copiar un archivo a una ruta sin especificar el nombre en el destino

	Files::cp('updates/2021-12-12-0.5.0-alpha/files/app/controllers/ShopiController.php',
	'app/controllers');

Ej:

Crear un archivo y hacer un backup en caso de existir en el destino

	Files::setBackupDirectory(ROOT_PATH . 'backup'); 
	Files::cp('updates/2021-12-12-0.5.0-alpha/files/app/controllers/ShopiController.php',
	'app/controllers/ShopiController.php');

Ej:

Copiar recursivamente archivos de una ruta a otra 

	$ori = '/home/www/simplerest';
	$dst = '/home/feli/Desktop/UPDATE';

	Files::copy($ori, $dst, [
		'docs'
		'/home/www/simplerest/docs/dev/TODO Supra.txt'
	]);

Se puede especificando la ruta absoluta a un archivo como ClientInterface.php en el ejemplo.

Ej:

	$ori = '/home/www/simplerest';
	$dst = '/home/feli/Desktop/UPDATE';

	Files::copy($ori, $dst, [
		'docs',
		'/home/www/simplerest/vendor/psr/http-client/src/ClientInterface.php'
	]);

Ej:

Copiar recursivamente archivos de una ruta a otra a excepción de ciertos archvos o directorios.

	$ori = '/home/www/simplerest';
	$dst = '/home/feli/Desktop/UPDATE';

	Files::copy($ori, $dst, [
		'docs'
	], 
	[
		'docs/dev',
		'/home/www/simplerest/docs/dev/TODO Supra.txt',
		'docs/INSTALACION.txt'
	]);

Ej:

Especificando patrones de glob copiar recursivamente archivos y directorios de una ruta a otra a excepción de ciertos archivos.

Ej:
	
	$ori = '/home/www/simplerest';
	$dst = '/home/feli/Desktop/UPDATE';

	Files::copy($ori, $dst, ['glob:*.txt']);

Ej:

	$ori = '/home/www/simplerest';
	$dst = '/home/feli/Desktop/UPDATE';

	$str_files = <<<'FILES'
		config/constants.php
		app/core
		app/controllers/UpdateController.php     
		public/app.php
		glob:*.txt
	FILES;

	$files = explode(PHP_EOL, $str_files);

	$except =  [
		'db_dynamic_load.php',
		'PrepareUpdateController.php',
		'docs/dev',
		'glob:*.zip'
	];

	Files::copy($ori, $dst, $files, $except);


Advertencia

Si se omite el parámetro # 3 para especificar archivos se intentará un glob:* 

Ej:

	Files::copy($path_ori, $path_dst); 

equivale a:

	Files::copy($path_ori, $path_dst, [
		'glob:*' 
	]);

Sin embargo se puede ser más específico:

	Files::copy($path_ori, $path_dst, ['glob:*.php']); 


# Aplicar un callback sobre el contenido de cada archivo copiado

Ej:

	Files::setCallback(function(string $content, string $path){
		return Strings::removeMultiLineComments($content);
	});

	Files::copy($ori, $dst); 


### Compresión de archivos a ZIP

Zipea archivos de una carpeta de forma recursiva y admite especificar archivos y carpetas que serán ignorados.

Ej:

	$ori = '/home/www/html/pruebas/drag';	
	$dst = '/home/feli/Desktop/UPDATE/drag.zip';

		Files::zip($ori, $dst, [
		'file_to_be_ignored.txt',
		'jquery-ui-1.12.1.custom'
	]);


# Notas sobre modelos y apis

Al crear una "API", se genera una clase que hereda de ApiController y ésta por defecto está asociada a un modelo y una tabla en particular.

Es posible al momento de crear el archivo del modelo evitar que corrobore la existencia de la tabla subyacente para hacer un cambio de DataSource. De momento el ApiController si requiere de schemas aunque siempre es posible crear un ApiController "desde cero".

Lo interesante es que la clase para la API generada tiene dos propiedades públicas: 

	public $model_name;
    public $table_name

Si se modifica $model_name a por ejemplo "OtroModel" entonces los permisos sobre recursos del ACL -definidos en acl.php- aplicarán para la tabla "otro".


### Actualizaciones del framework

El escenario es que el framework evoluciona, se crean nuevas librerías, funciones cambian de nombre, etc. 

# Creación del update

	- Se crea un nuevo paquete de actualización nombrado con la fecha-hora corriente. 

	- Se introduce una descripción general del paquete que se irá actualizando.

	- A medida que se introducen cambios como el renombrado de una función o archivo o un cambio de ubicación se escribe una nueva "tarea" que en si indica qué cambios hacer. En si es como una migración pero sobre código en vez de sobre la base de datos. 

	Cada tarea lleva una descripción.

	Cabe notar que cambio es una nueva tarea. Éstas se ejecutarán de forma secuencial de forma cronológica.

	- Se copian los archivos nuevos en una ubicación especial.

	- Todo el paquete (archivos + tareas + descripción) es comprimido con el nombre del paquete.

	- El paquete ya comprimido es subido a un repositorio. 

	El repositorio es accesible via endpoint habilitando operaciones para el usuario final como:

		- listar
		- descargar

# Update <implementando>

El usuario mediante comandos podrá verificar cuántos updates tiene pendientes enviando las credenciales al endpoint correspondiente:

	GET {url_repository}/api/v1/updates?created_at[gt]={last_updated}&orderBy=created_at

Podría usar un folder pero tendría que dar permiso a cada usuario.

Voy a usar un permiso "read_all" para usuarios con el rol "update_subscriber".

También podría dejar que se suscriban via WebHooks a /api/v1/updates


Se recomienda:

- Usar "api keys" como método de autenticación sobre el endpoint /api/v1/updates  


# Extensión del framework

Al día de hoy es posible sumar nuevas funcionalidades via:

- librerías
- helpers
- traits
- middlewares
- service providers
- extendiendo controlador base (MyController)
- extendiendo modelo base (MyModel)
- extendiendo vista base (MyView)
- extendiendo el ACL (via service provider)
- extendiendo Make (Controller)
- extendiendo Migrations (Controller)
- extendiendo Api (MyApiController)
- hookeando apis
- hookeando modelos
- hookeando la clase Auth (Controller)
// ...

En particular extendiendo MakeController o MigrationsController es posible crear nuevos comandos.


# Contenedor de dependencias inversas (IoC)  <experimental>

El framework implementa un sencillo contenedor de dependencias inversas mediante la clase Container.

En su forma más simple se puede bindear un string que hace referencia a la clase y su namespace en caso de tenerlo.

Ej:

	Container::bind('foo', Foo::class);	

	$foo = Container::make('foo');
	print_r($foo->bar());

	$foo = Container::make('foo');
	print_r($foo->bar());


Para "enlazar" la referencia a una factory para clase:

	Container::bind('foo', function(){
		return new Foo();
	});

La ventaja de esta última forma es que si hubiere parámetros por defecto que se quisieran enviar es muy sencillo.

Ej:

	Supongamos que tenemos una clase Cake

	/*
		Example class
		@author Isaac Souza
	*/
	class Cake
	{
		private $ingredient1;
		private $ingredient2;
		private $cook_time; // minutes

		public function __construct(Ingredient1 $ingredient1, Ingredient2 $ingredient2, $cook_time)
		{
			$this->cook_timey  = $cook_time;
			$this->ingredient1 = $ingredient1;
			$this->ingredient2 = $ingredient2;
		}

		public function get()
		{
			return 'Cake 2 is ready.';
		}
	}

Entonces.. necesitamos especificar el tiempo de cocción para poder instanciar el pastel:

	Container::bind(Cake::class, function() {
      $ingredient1 = new Ingredient1();
      $ingredient2 = new Ingredient2();

      return new Cake($ingredient1, $ingredient2, 25);
  });

A posteriori se podrá crear la instancia simplemente llamando a make() con la referencia o key asociada previamente con bind.

	$cake = Container::make(Cake::class);
	print_r($cake->get());

	$cake = Container::make(Cake::class);
	print_r($cake->get());

Cabe notar que con cada llamada a make() en el ejemplo previo se creará una nueva instancia de Cake.

El contenedor permite crear instancias únicas de las clases mediante el método singleton()

	Container::singleton('foo', Foo::class);

	$foo = Container::make('foo');
	print_r($foo->bar());
	
	$foo = Container::make('foo');
	print_r($foo->bar());

En caso de que nuestra clase tenga parámetros y se los querramos pasar o sean requeridos podemos hacerlo usando el segundo parámetro de make() o makeWith()

	Container::bind('car', \simplerest\libs\Car::class);

	$o = Container::makeWith('car', ['color' => 'blue', 'max_speed' => 200]);
	print_r($o->run());
	print_r($o);


# Correr procesos en background

Puede utilizar System::runInBackground() desde la versión 0.7.0

	runInBackground(string $cmd, bool $capture_output = true)

Ej: 

	$cmd = 'php com dumb some_work';
	$pid = System::runInBackground($cmd, true);

En el caso de Linux, devuelve el PID del proceso ejecutado en background.


# CronJobs 

El framework dispone de tareas programadas o "cron jobs". Estos cronjobs se almacenan en /app/jobs/cronjobs

La estructura básica de un CronJob es:

	class {Name}Worker extends CronJob
	{
		static protected $month;
		static protected $monthday;
		static protected $weekday;
		static protected $hour; 
		static protected $minute;
		static protected $second;
		static protected $is_active = true;

		/*
			Number of retries in 24 Hs.
		*/
		static protected $retries = 3;
		static protected $retry_timeframe = 3600 * 24;


		function run(){
			// your logic here
		}
		
		/*
			@paran $error Exception object
			@param $times int number of fails
		*/
		function onFail(\Exception $error, int $times){
		}

		function onSuccess(){

		}
	}

Ej:

El siguiente cron job se ejecuta cada 5 segundos a las 21 Hs de cada día.

	class BumCronJob extends CronJob
	{
		static protected $month;
		static protected $monthday;
		static protected $weekday;
		static protected $hour = 21; 
		static protected $minute;
		static protected $second = 5;
		static protected $is_active = true;

		function run(){
			Files::logger("Bum bum bum");
		}
	}

Comandos 

El comando para crear un CronJon es "make cronjob {name}"

	php com make cronjob {name}

Para remover un cronJon con --remove

	php com make cronjob {name} --remove 

Para iniciar los cronjobs:

	Supervisor::start()

Para detener los cronJobs:

	Supervisor::stop()

<-- obviamente toca crear los comandos "cronjobs start" y "cronjobs stop" que llamen a Supervisor::start() y Supervisor::stop() respectivamente


# Cola de tareas

La cola de tareas es una forma eficiente de reducir los tiempos de respuesta de peticiones ya que la o las tareas se encolan, el script termina y en segundo plano se atenderá la cola.

Un caso de uso es el envio de correos:
	
	$queue->dispatch(\simplerest\jobs\tasks\SendWelcomeEmail::class, $user);

Estas tareas se almacenan en /app/jobs/tasks

Las tareas se crean mediante el comando:

	php com make task {name}

Las tareas deben extender de Task e implementar el método run() el cual puede recibir parámetros. Ej:

	class DosTask extends Task
	{ 
		static protected $priority = 10;
		static protected $exec_time_limit   ;
		static protected $memory_limit;
		static protected $dontOverlap = false;

		function run(string $name, int $age){
			// your logic here

			Files::logger("Hello $name. Are you $age years old?");
		}
	}

Luego, es posible "encolar" (despachar) las tareas a una cola que puede tener un nombre. Ej:

	$queue = new JobQueue("q1");
	$queue->dispatch(\simplerest\jobs\tasks\UnaTask::class);
	$queue->dispatch(\simplerest\jobs\tasks\OtraTask::class);

	/*
		Se pueden enviar parámetros a las tareas
	*/
	
	$queue->dispatch(\simplerest\jobs\tasks\DosTask::class, 'Felipito', 10);


Se pueden crear cuantas colas se necesiten diferenciándose por el nombre que llevan.

Las tareas (tasks) en cada cola corren de forma síncrona (una detrás de otra) donde la primera en entrar a la cola es la primera en salir (FIFO).

Para atender las colas se necesitan trabajadores (workers) y se pueden agregar uno o más. A más workers más rápido irá la cola pero más recursos consumirá.

	/*
		Declaro a la cola que deseo acceder
	*/
	$queue = new JobQueue("q1");

	/*
		Asigno tres workers a esa cola
	*/
    $queue->addWorkers(3);


La forma de detener la ejecución de tareas de una cola es mediante JobQueue::stop();

Ej:

	JobQueue::stop('my_queue');

En caso de querer detener la ejecución de todas las colas, no envie el nombre de la cola:

	JobQueue::stop()


<-- se implementará el comando "queue stop [ name ]"


# HTML & Form builder

El framework provee de las clases HTML, Form y Bt5Form para la construcción programática de HTML. 

Ej:

	echo Bt5Form::p(text:"Hola mundo cruel");
	echo Bt5Form::tag(type:'hr', style:'color:cyan');
	echo Bt5Form::inputColor(name:'my_color', text:'Color', id:'c1');

O usando el helper tag(),

    echo tag('p')->text("Hola mundo cruel");
	echo tag('hr')->style('color:cyan');
	echo tag('inputColor')->name('my_color')->text('Color')->id('c1');
	
Se puede ver que para renderizar el tag <hr> en el primer caso se usa una sintáxis un poco distinta y esto es porque se da el caso de que no existe el método correspondiente en la clase Bt5Form o las clases de las que hereda. En estos casos siempre que el tag no deba anidar otros se puede usar Form::tag() o en este caso Bt5Form::tag()

Lo anterior renderizará algo como:

	<p>Hola mundo cruel</p>
	<hr style="color:cyan">

	<input name="my_color" id="my_color" type="color" class="form-control form-control-color" colorpick-eyedropper-active="true">
	<label for="c1" class="form-label">Color</label>


# Anidamiento de etiquetas

Como cada etiqueta renderiza a un string, siempre podrá anidarlas pero además si utiliza Form::group() o los tags que lo implementan como Form:div y Form:picture entre otros, podrá enviar un Array en vez de un string. 

Ej:

	echo Bt5Form::group(content:[
        tag('span')->text('@')->id('basic-addon')->class('input-group-text'),
        tag('inputText')->name('nombre')->placeholder("Username")
    ],
		tag:"div"
        class:"input-group mb-3"
    );

o

	echo Bt5Form::group(content:
        tag('span')->text('@')->id('basic-addon')->class('input-group-text') .
        tag('inputText')->name('nombre')->placeholder("Username")
    ,
		tag:"div"
        class:"input-group mb-3"
    );

o

	echo Bt5Form::div(content:[
        tag('span')->text('@')->id('basic-addon')->class('input-group-text'),
        tag('inputText')->name('nombre')->placeholder("Username")
    ],
        class:"input-group mb-3"
    );

o

	echo tag('div')->content([
        tag('span')->text('@')->id('basic-addon')->class('input-group-text'),
        tag('inputText')->name('nombre')->placeholder("Username")
    ])->class("input-group mb-3")

o

	echo tag('inputGroup')->content([
        tag('span')->text('@')->id('basic-addon')->class('input-group-text'),
        tag('inputText')->name('nombre')->placeholder("Username")
    ])->class("mb-3")

o

	echo tag('inputGroup')->content(
        tag('span')->text('@')->id('basic-addon')->class('input-group-text') .
        tag('inputText')->name('nombre')->placeholder("Username")
    )->class("mb-3")


# Atributos válidos

Si un atributo en su nombre contiene un guión medio al momento de referenciarlo sino es dentro de $attributes entonces tendrá que hacerlo reemplazando los guiones medios (-) por guiones bajos (_).

Ej:

	text:static::button(
		class:"accordion-button collapsed",
		data_bs_toggle:"collapse",
		dataBsTarget:"#{$arr['id']}",
		aria_expanded:"false",
		aria_controls:$arr['id'],
		content:[ $arr['title'] ]
	)


# Select

Ej:

	echo Bt5Form::select(name:'size', options:[
		'L' => 'Large', 
		'S' => 'Small'
	], placeholder:'Pick a size...', default:'Large');	

o

	tag('select')->name('size')->options([
		'L' => 'Large', 
		'S' => 'Small'
	])->placeholder('Pick a size...')->default('Large');


Además acepta un agrupamiento de opciones enviando un array asociativo.

Ej:

	echo Bt5Form::select(name:'comidas', options:[
        'platos' => [
            'Pasta' => 'pasta',
            'Pizza' => 'pizza',
            'Asado' => 'asado' 
        ],
    
        'frutas' => [
            'Banana' => 'banana',
            'Frutilla' => 'frutilla'
        ]
    ],         
    placeholder:'Tu comida favorita',
	class:'my-3');

o

	echo tag('select')
    ->name('comidas')
    ->placeholder('Tu comida favorita') 
    ->options([
        'platos' => [
            'Pasta' => 'pasta',
            'Pizza' => 'pizza',
            'Asado' => 'asado' 
        ],

        'frutas' => [
            'Banana' => 'banana',
            'Frutilla' => 'frutilla'
        ]
    ])->class('my-3');


Para "select múltiple" solo agregue 

	->multiple('multiple')

o simplemente

	->multiple()


# El tag input

Hay distintos tipos de <input> y cada uno tiene su alias que corresponde al type donde por ejemplo <input type="password"> es password()

Ej:

	Bt5Form::password(id:'pass', placeholder:"Contraseña");

o

	tag('password')->id('pass')->placeholder('Contraseña');

Hay un algunas de exceptiones:

	type="text"				es inputText()
	type="button"			es inputButton()
	type="time" 			es inputTime() 
	type="datetime_local"	es datetimeLocal()
	type="color"		    es inputColor()

La razón de las excepciones son colisiones de nombres como sucede con button() ya que hace referencia a <button> y por tanto no puede usarse para <input type="button">

Igualmente "text" puede hacer referencia a un atributo de otra etiqueta así que <input type="text"> es inputText().


# File

El input file permite subir archivos ya sea solo uno o varios.

Ej:

	echo tag('file')->multiple();


Size

A los controles de tipo form-control se les puede cambiar el tamaño aplicándoles large() o size()

Se verificó su funcionamiento para el caso de los <input> aunque se implemetó también para los <select>


# Id o name

Se puede generar una copia del valor del atributo "name" en "id" para evitar repetir:

	Bt5Form::setIdAsName();


# Métodos genérico tag()

Hay muchísimos tags de HTML y si alguno no está contemplado siempre es posible usar el métodos tag() para conseguir el resultado deseado.

Ej:

	Bt5Form::tag('hr')

o

	tag('hr');


# Macros

La clase Html y Form soportan macros, es decir se pueden definir tags propios y estos son luego renderizados al llamar a un tag con ese nombre. 

Ej:

	Html::macro('salutor', function($name, $adj)
	{
		return "<span/>Hello $adj $name</span>";
	});

	echo Html::salutor("Isabel", "bella");

Inclusive puede aceptar atributos:

Ej:

	Html::macro('salutor', function ($name, $adj, Array $att = []) {
		$str_att = Bt5Form::attributes($att);
		return "<span $str_att>Hello $adj $name</span>";
	});

	echo Bt5Form::salutor("Isabel", "bella", ['class' => 'my-3 me-1', 'style' => 'color: red']); 


# La clase Tag

Es posible usar métodos encadenados para definir los atributos en vez de los parámetros de los métodos de las clases Html y derivadas (Form, Bt5Form, etc).

	echo tag('span')->text('some text')->style('color:red');

Renderiza algo como

	<span style="color:red">some text</span>


Lo que sigue son equivalentes:

	Bt5Form::range('edad', 0, 99, 10, ['class' => 'my-3'])

	Bt5Form:range(name:'edad', min:0, max:99, default:10, class:'my-3')

    tag('range')->name('edad')->min(0)->max(99)->default(10)->class('my-3')


Importante:

	Para poder hacer uso de la clase Tag se debe primero "registrar" la clase del Html Builder.

Ej:

	Tag::registerBuilder(\simplerest\core\libs\Bt5Form::class);

Nota:

	Las distintas formas de llamar al form builder se pueden combinar.

Ej:

	<?php

	use simplerest\core\libs\Bt5Form; 
	use simplerest\core\libs\Tag;
	?>

	<div class = "row mt-5">
		<div class = "col-6 offset-3">

		<?php 

		echo tag('h3')->text("Datos")->class('mb-3');

		echo Bt5Form::dataList(listName:'datalistOptions', id:'occupation', options:[
			'programador',
			'software engenierer'
		], placeholder:'Escriba aquí', label:'Ocupación');

		/*
			El tag 'hr' ni siquiera está definido en la clase Html
		*/
		echo tag('hr')->style('color:cyan');

		echo tag('p')->text("Hola mundo cruel");

		?>
		</div>
	</div>


# Atributos data-*

Los atributos data-* en caso de usarse como métodos encadenados con la clase Tag deben pasarse a camelCase.

Ej:

	tag('closeButton')->dataBsDismiss('modal')

Donde "dataBsDismiss" hace referencia al atributo data-bs-dismiss renderizando dataBsDismiss('modal') en data-bs-dismiss="modal"


# Text utilities

Silenciar un texto (aclarar el color de la fuente) es tan simple como llamar a textMuted() sobre un p(), div(), span(), etc.

Ej:

	echo tag('p')->text('Some paragraph')->class('mt-3')->textMuted();
    echo tag('div')->content('Some content')->class('mt-3')->textMuted();

En general se puede aplicar cualquier clase de css sobre si se define en $classes y tal es el caso para textMuted a la que se le aplica para Boostrap 5 la clase "text-muted".


# Buttons

A un botón se le puede setear el color muy fácil mediante métodos Form::{color}()

Ej:

	echo tag('button')->content(Notifications')->primary();

Que es lo mismo que:

	echo tag('button')->content(Notifications')->class('primary');

Colores y otras clases sobre botones 

Sobre colores y derivados (como dropdownButton) se pueden aplicar:

	info()
	warning()
	danger()
	etc

Y por compatibilidad con AdminLTE también default()

Ej:

	echo tag('inputButton')->id("comprar")->value('Comprar')->danger()->class('rounded-pill');
    echo tag('reset')->id("limpiar")->value("Limpiar")->warning()->class('mx-3');
    echo tag('submit')->id("enviar")->value("Enviar")->success();


Flat

Se puede conseguir botones planos (sin bordes redondeados) aplicando flat()

Ej:

	echo tag('button')->content('Un botón')->large()->bg('warning')->flat();

Outline

Se puede conseguir botones sin background aplicando outline() 

Ej:
	echo tag('button')->content('Botón rojo')->danger()->class('rounded-pill')->outline()

Nota: solo funciona con <button> y no <input type="button">

Tamaño 

Llamando a Form::small() o Form::large() se obtienen botones más grande o pequeños.

Ej:
	echo tag('inputButton')->value('Un botón')->info()->class('rounded-pill');
    echo tag('inputButton')->value('Otro botón')->warning()->class('rounded-pill')->large();
    echo tag('inputButton')->value('Peque')->info()->class('rounded-pill mx-3')->small();

En general cualquier control que implemente la clase form-control es suceptible de ser agrandado o achicado con large() y small()

Ej:

	echo tag('file')
	->class('mt-3 mb-5');

	echo tag('file')->large()
	->class('mt-3 mb-5');

	echo tag('file')->small()
	->class('mt-3 mb-5');

Deshabilitar botones

Solo agregue una llamada a Form::disabled()

	echo tag('submit')->id("enviar")->value("Enviar")->success()->disabled()


Botones de ancho completo

Aplicando block() se consigue que un button ocupe todo el ancho de su parent.

Ej:

	echo tag('button')->content(
		'<i class="fa fa-bell"></i> .btn-block'
	)
	->block(); 

Botones con íconos

Ej:

	echo tag('button')->content(
		'<i class="fa fa-bell"></i> .btn-block'
	)
	->block(); 

O si son fonts de FontAwesome,...

	echo tag('button')->content("btn-block")
	->block()
	->icon('bell'); 

O con outline

Ej:

	echo tag('button')->content("btn-block")
	->block()
	->icon('bell')
	->outline(); 


# App buttons

Admin LTE viene con App buttons (que recuerdan los íconos de Windows 3.1). Se respeta el nombre de "app buttons" que le da la plantilla aunque son links.

Ej:

	echo tag('appButton')
	->content("Edit")
	->icon('edit')
	->href('#edit'); 

Se puede setear una cantidad a ser mostrada como notificación en el márgen superior derecho como badge.

Ej:

	echo tag('appButton')
	->content("Edit")
	->icon('edit')
	->href('#edit')
	->badgeQty(5); 

Se puede colorear tanto el "botón" como el badge. 

Ej:

	echo tag('appButton')
	->content("Edit")
	->icon('edit')
	->href('#edit')
	->bg('danger')
	->badgeQty(5)
	->badgeColor('warning'); 

# Input Groups

Los tag input* como inputText, file (o inputFile), etc pueden contener otros elementos como botones o dropdowns tanto en el frente como en su parte final para lo que se utiliza prepend() y append() respectivamente.

Ej:

Delante

	echo tag('inputGroup')
	->content(
		tag('inputText')
	)
	->prepend(
		tag('button')->danger()->content('Action')
	)->class('mb-3');

Ej:

Detrás

	echo tag('inputGroup')
	->content(
		tag('inputText')
	)
	->append(
		tag('button')->info()->content('Go!')
	)->class('mb-3');

Ej:

Delante y detrás

	echo tag('inputGroup')
	->content(
		tag('inputText')
	)
	->prepend(
		tag('button')->danger()->content('Action')
	)
	->append(
		tag('button')->info()->content('Go!')
	)->class('mb-3');

Ej:

Varios elementos delante	

	echo tag('inputGroup')
	->content(
		tag('inputText')
	)
	->prepend([
		tag('button')->danger()->content('Action'),
		tag('button')->warning()->content('Other action') 
	])
	->append(
		tag('button')->info()->content('Go!')
	)->class('mb-3');


Así es muy fácil crear input con un ícono de búsqueda por ejemplo:

	echo tag('inputGroup')
	->content(
		tag('inputText')
		->placeholder('Search')
	)
	->append(
		tag('button')->info()->icon('search')
	);


# Button groups and button toolbars

Con buttonGroup() se puede "agrupar" botones.

Ej:

	echo tag('buttonGroup')->content([
		tag('button')->content('Left')->info(),
		tag('button')->content('Middle')->info(),
		tag('button')->content('Right')->info()
	])->class('my-3');

y vericalmente con vertical()

	echo tag('buttonGroup')->content([
		tag('button')->content('Top')->warning(),
		tag('button')->content('Middle')->warning(),
		tag('button')->content('Bottom')->warning()
	])->vertical();

Con buttonToolbar() se grupan conjuntos de botones o sea es un wrapper sobre varios "button groups". También puede agrupar de forma mezclada "button groups" con "input groups".

Ej:

	echo tag('buttonToolbar')->content([
        tag('buttonGroup')->content(
            tag('button')->content('Botón rojo')->danger()->class('rounded-pill')->outline() .
            tag('button')->content('Botón verde')->success()->class('rounded-pill')->outline()
        )->aria_label("Basic example")->class('mx-3'),
    
        tag('buttonGroup')->content(
            tag('button')->content('Botón azul')->info()->class('rounded-pill')->outline() .
            tag('button')->content('Botón amarillo')->warning()->class('rounded-pill')->outline()
        )->aria_label("Another group")->class('mx-3')
    ]);
	

Tamaño de botones en "button groups"

Se puede aplicar large() o small() a los grupos.

Ej:

	echo tag('buttonGroup')->content(
        tag('button')->content('E')->danger()->class('rounded-pill')->outline() .
        tag('button')->content('F')->success()->class('rounded-pill')->outline()
    )->aria_label("Basic example")->class('mx-3')->large();


Botones agrupados en vertical

Aplique Form::vertical() al button group para lograr el alineamiento vertical.

Ej:

	echo tag('buttonGroup')->content(
        tag('button')->content('E')->danger()->class('rounded-pill')->outline() .
        tag('button')->content('F')->success()->class('rounded-pill')->outline()
    )->aria_label("Basic example")->class('mx-3')->large()->vertical();


# Acordión

Ej:

 	echo tag('accordion')->items([
		[
			'id' => "flush-collapseOne",
			'title' => "Accordion Item #1",
			'body' => 'Placeholder content for this accordion, which is intended to ....'
		],
		[
			'id' => "flush-collapseTwo",
			'title' => "Accordion Item #2",
			'body' => 'Placeholder 2'
		],
		[
			'id' => "flush-collapseThree",
			'title' => "Accordion Item #3",
			'body' =>  'Placeholder 3'
		]
	])->id('accordionExample');

Para mantener abierta una sección cuando se abra otra, use always_open

Ej:

	echo tag('accordion')->items([
		[
			'id' => "flush-collapseOne",
			'title' => "Accordion Item #1",
			'body' => 'Placeholder content for this accordion, which is intended to demonstrate the <code>.accordion-flush</code> class. This is the first items accordion body.'
		],
		[
			'id' => "flush-collapseTwo",
			'title' => "Accordion Item #2",
			'body' => 'Placeholder 2'
		],
		[
			'id' => "flush-collapseThree",
			'title' => "Accordion Item #3",
			'body' =>  'Placeholder 3'
		]
	])
	->id('accordionExample')
	->always_open(true)
	->attributes(['class' => 'accordion-flush']);



Atributos deben pasarse como ->attributes($array)

Ej:

	echo tag('accordion')->items([
		/*
			Items
		*/
	])
	->id('accordionExample')
	->attributes(['class' => 'accordion-flush']);


# Input range

	echo tag('label')->name("exp")->text("Experiencia");
    echo tag('range')->name('exp')->min(0)->max(99)->default(30)->class('my-3');

Con Admin LTE se puede personalizar cambiando el color de la "bolita".

Ej:

	echo tag('label')->name("exp")->text("Experiencia");
    echo tag('range')->name('exp')->min(0)->max(99)->default(30)->class('my-3')->color('teal');


# Alerts

A Simple alert. 

Ej:

    echo tag('alert')->content('Some content')->warning();

An alert with some link. 

Ej:

    echo tag('alert')->content(
		tag('alertLink')->href('#')->anchor('A danger content')
	)->danger();

Dismissable alerts

Just add ->dismissible(true) to become the alert dismissable.

Ej:

	echo tag('alert')->content('Some content')->warning()->dismissible(true);
o
	echo Bt5Form::alert(content:'Some content', attributes:['warning', 'dismissible']);


# Badges

Ej:

	echo tag('badge')->content('barato')->success();
	echo tag('badge')->content('casi agotado')->warning();
	echo tag('badge')->content('agotado')->danger();

Modificar el tamaño

Ej:

	echo tag('h3')->text(
        tag('badge')->content('barato')->success()
    );

Bages como pílodoras

Es solo de aplicar la clase rounded-pill.

Ej:
	echo tag('badge')->content('barato')->class('rounded-pill')->success();


A los botones es posible aplicarles badges

Ej:

	echo tag('button')->content([
        'Notifications', 
        tag('badge')->content('4')->secondary()
    ])
    ->class('rounded')
    ->primary();

Posicionando el badge 

Ej:

	echo tag('button')->content([
        'Inbox', 
        tag('badge')->content('99+')->danger()->class('position-absolute top-0 start-100 translate-middle rounded-pill')
    ])
    ->class('rounded position-relative')
    ->primary();


# Notification buttons

Un botón que muestra en su márgen superior derecho un número.

Ej:

	echo tag('notificationButton')->text('Inbox')->qty(101);


# Breadcrumbs

Un breadcrumb renderiza un elemento de navegación como:

	Home > Library > Data

Ej:

	echo tag('breadcrumb')->content([
        [   
            'href' => '#', 
            'anchor' => 'Home'
        ],
        
        [
            'href' => '#library',
            'anchor' => 'Library'
        ],

        [
            'anchor' => 'Data'
        ]
    ]);


# Cards

Se implementan varios métodos para la creación de tarjetas aunque las cards son tan flexibles que no hay un diseño fijo.

Ej:

	echo tag('card')
        ->header('Quote') 
        ->body(

            tag('blockquote')->content(
                tag('p')->text(
                    'A well-known quote, contained in a blockquote element.'
                ) .
                tag('blockquoteFooter')->content('Someone famous in ' . 
                tag('cite')->title("Source Title")->content('Source Title'))

            )->class('mb-0')
        
        ) 
        ->footer('Some footer')
        ->class('mb-4');

Tanto header como footer son opcionales.

Ej:

	echo tag('card')->content(
		tag('cardHeader')->content(
			tag('cardTitle')->text('Some title')
		)
        tag('cardBody')->content(
            tag('cardSubtitle')->text('Some subtitle')->class('mb-2')->textMuted()
        )
    )->class('mb-4');

Sintaxis simplificada

	echo tag('card')
	->header('Some header') 
	->body(
		'Some body'
	) 
	->footer('Some footer')
	->class('mb-4');


Cards con imágenes

Cuando hay una imágen dentro de una card es imprescindible setear el ancho de la tarjeta para evitar que crezca hasta el 100% del width del padre. Por ejemplo con style('width: 18rem;')

Notar que la imágen se coloca en el content() y no en el body.

Ej:

	echo tag('card')->style('width: 18rem;')->class('my-3')
	->content(
		tag('cardImgTop')->src(asset('img/mail.png'))
	)
	->body([   
		tag('cardTitle')->text('Some title'),        
		tag('cardText')->text('Some quick example text to build on the card title and make up the bulk of the cards content.'),
		tag('inputButton')->value('Go somewhere')
	]);


Sizing

	Se pueden aplicar distintas utilidades como w-75, w-50, etc sobre la card o usando style(), ej: style('width: 18rem;')

Colores 

Se puede aplicar textColor() y bg() sobre el body() y por supuesto también colorear los botones.

Ej:

	echo tag('card')->style('width: 18rem;')
	->header(tag('cardTitle')->text('Some title'))
	->body([            
		tag('cardText')->text('Some quick example text to build on the card title and make up the bulk of the cards content.'),
		tag('inputButton')->value('Go somewhere')->info()->textColor('white')
	])
	->class('my-3')
	->bg('primary')
	->textColor('white');

Card title

Tanto title como subTitle pueden ir dentro o fuera del header() pero la diferencia es que dentro del header quedan "remarcados" con un border inferior y se ubicarían delante del content(). Para cards que contienen imágenes queda anti-estético que se use con header.

Ej:

	/*
      Sin header
    */
    echo tag('card')->style('width: 18rem;')->class('my-3')
    // ->content(
    //   tag('cardImgTop')->src(asset('img/mail.png'))
    // )
    ->body([   
      tag('cardTitle')->text('Some title'),        
      tag('cardText')->text('Some quick example text to build on the card title and make up the bulk of the cards content.'),
      tag('inputButton')->value('Go somewhere')
    ]);


    /*
      Con header
    */
    echo tag('card')->style('width: 18rem;')->class('my-3')
    // ->content(
    //   tag('cardImgTop')->src(asset('img/mail.png'))
    // )
    ->header(tag('cardTitle')->text('Some title'))
    ->body([           
      tag('cardText')->text('Some quick example text to build on the card title and make up the bulk of the cards content.'),
      tag('inputButton')->value('Go somewhere')
    ]);

Notas:

Debería ser posible capturar la salida un "componente" a fin de que sea utilizado como template para un "widget". Notar el uso de elementos placeholders para templates {}

Ej:

	echo tag('card')
		->header(tag('cardTitle')->text('{{cartTitle:text}}'))
		->content(
        tag('cardBody')->content(
            tag('cardSubtitle')->text('{{cartsubtitle:text}}')->textMuted()
        )
    );


# Flip cards

Están basadas en ejemplo de w3schools.com y quizás no sean 100% responsivas. Toca ajustar el ancho de la imágen según como sea ésta y también los paddings.

Toca escribir el componente que use las clases flip-card, flip-card-inner, flip-card-front y flip-card-back aunque primero debería probarse su utilidad / respinsividad.

Ej:

	include_widget_css('flip_card');

    echo tag('card')->class('my-3 flip-card')
	->content([
		tag('div')
		->class('flip-card-inner')
		->content([			
			tag('div')->content([
				tag('h3')->text('Tienes un correo')->bg('primary')->class('py-2'),
				tag('img')->src(asset('img/mail.png'))->w(65)
			])
			->class('flip-card-front bg-transparent'),
			
			tag('div')->content([
				tag('h3')->text('Some title'),
				tag('cardText')->text('Some quick example text to build on the card title and make up the bulk of the cards content.'),
				tag('inputButton')->value('Go somewhere')
			]) 
			->class("flip-card-back py-2") 
		])  
	]);



# Citas

Para citas use el tag blockquote

Ej:

	echo tag('card')
	->header('Quote') 
	->body(

		tag('blockquote')->content(
			tag('p')->text(
				'A well-known quote, contained in a blockquote element.'
			) .
			tag('blockquoteFooter')->content('Someone famous in ' . 
			tag('cite')->title("Source Title")->content('Source Title'))

		)
	
	) 
	->footer('Some footer')
	->class('mb-4');

Con AdminLTE cambie el color del marco con color()

	echo tag('card')
	->header('Quote') 
	->body(

		tag('blockquote')->content(
			tag('p')->text(
				'A well-known quote, contained in a blockquote element.'
			) .
			tag('blockquoteFooter')->content('Someone famous in ' . 
			tag('cite')->title("Source Title")->content('Source Title'))

		)->color('secondary')
	
	) 
	->footer('Some footer')
	->class('mb-4');


# Carousels

Los carruseles son de los componentes más complejos y con los métodos "base" es una ardua tarea poder crear un uno. Es por esto que se ha eliminado el boilerplate y la creación es algo trivial.

Ej:

	echo tag('carousel')->content(
		tag('carouselItem')->content(
			tag('carouselImg')->src(asset('img/slide-1.jpeg'))
		)->caption(
			'<h5>First slide label</h5>
			<p>Some representative placeholder content for the first slide.</p>'
		),

		tag('carouselItem')->content(
			tag('carouselImg')->src(asset('img/slide-2.jpeg'))
		),

		tag('carouselItem')->content(
			tag('carouselImg')->src(asset('img/slide-3.jpeg'))
		),
	)->id("carouselExampleControls")->withControls()->withIndicators();

Componentes opcionales:

	withControls			-- permiten navegar hacia adelante y atrás
	withIndicators			-- están en el "footer" del componente e indican el "avance" 


Para transacción con efecto "fade" llamando a carouselFade() o fade() y para tema obscuro es con carouselDark() o dark()

Ej:

	echo tag('carousel')->content(
		// Items
	)->id("carouselExampleControls")->dark()->fade();

Para especificar el tiempo en milisegundos para cada transición es con interval()

	tag('carouselItem')->content(
		// ...
	)->interval(1500)


En vez de 

	tag('img')->class("d-block w-100")->src('...')

puede usar:

	tag('carouselImg')->src('...')

El uso "captions" para aclarar una diapositiva se puede hacer mediante caption()

Ej:

 	tag('carouselItem')->content(
		tag('carouselImg')->src('...')
	)->caption(
		'<h5>Second slide label</h5>
		<p>Some representative placeholder content for the second slide.</p>'
	),

Altura de las diapositivas

Use height() sobre el tag carousel para normalizar el height de las diapositivas. El valor puede tener cualquier escala pero por defecto son pixeles.

Ej:

	echo tag('carousel')->content([
		tag('carouselItem')->content(
			tag('carouselImg')->src(asset('img/slide-1.jpeg'))
		)->caption(
			'<h5>First slide label</h5>
			<p>Some representative placeholder content for the first slide.</p>'
		),

		tag('carouselItem')->content(
			tag('carouselImg')->src(asset('img/slide-2.jpeg'))
		),

		tag('carouselItem')->content(
			tag('carouselImg')->src(asset('img/slide-3.jpeg'))
		)
	])->id("carouselExampleControls")->withControls()->withIndicators()
	->height('400px');
	

# Ventanas modales

La estructura de un modal es más o menos la siguiente:

	echo tag('modal')->content(
		tag('modalDialog')->content(
			tag('modalContent')->content(
				tag('modalHeader')->content(
					tag('modalTitle')->text('Modal title') . 
					tag('closeButton')->dataBsDismiss('modal')
				) .
				tag('modalBody')->content(
					tag('p')->text('Modal body text goes here.')
				) . 
				tag('modalFooter')->content(
					tag('closeModal') .
					tag('button')->text('Save changes')
				) 
			) 
		)
	)->id('exampleModal');


Static

Para que la ventana modal no se cierre al hacer click fuera de ella se puede usar static()

Ej:

	echo tag('modal')->content(
		// ...
	)->id('exampleModal')->static();

Scrollable 

Cuando son textos largos se puede aplicar scrollable()

Ej:

 	echo tag('modal')->content(
		tag('modalDialog')->content(
			//  ....
		)->scrollable()
	)->id('exampleModal');


Ancho del modal

En teoría es posible cambiar el ancho con small(), large() y extraLarge() sobre el tag('modalDialog')


Pantalla completa

Llamar a fullscreen() sobre tag('modalDialog')


Forma simplificada

Usando algo de "azucar sintáctico" es posible simplificar notablemente la creación de una ventana modal.

Ej:

	echo tag('modal')
	->header(
		tag('modalTitle')->text('Modal title') . 
		tag('closeButton')->dataBsDismiss('modal')
	)
	->body(
		tag('p')->text('Modal body text goes here!')
	)
	->footer(
		tag('closeModal') .
		tag('button')->text('Save changes')
	)
	->options(['fullscreen'])
	->id('exampleModal');

Como puede observarse en options() se envian las opciones para el "modelDialog" que ya no es necesario declararlo.


# Collapse 

Elementos como div pueden colapsarse mediante el "componente" de collapse de Boostrap.

Los eventos para colapsar y des-colapsar se pueden asociar a "links" y "buttons".

Ej:

	echo tag('p')->text(
		tag('collapseLink')->href("#collapseExample")->anchor('Link with href')->class('me-1') .            
		tag('collapseButton')->dataBsTarget("#collapseExample")->content('Button with data-bs-target')
	);

	echo tag('collapse')->id("collapseExample")->content(
		tag('cardBody')->content('Some placeholder content for the collapse component. This panel is hidden by default but revealed when the user activates the relevant trigger.')
	);

Multiple targets

"A <button> or <a> can show and hide multiple elements by referencing them with a selector in its href or data-bs-target attribute. Multiple <button> or <a> can show and hide an element if they each reference it with their href or data-bs-target attribute"

Usando el método multiple() sobre collapse() se agrega la clase "multi-collapse".


# Dropdown

La estructura básica es la siguiente:

	echo tag('dropdown')->content(
		tag('dropdownButton')->id('dropdownMenuButton1')->content('Dropdown button') .
		tag('dropdownMenu')->ariaLabel('dropdownMenuButton1')->content(
			tag('dropdownItem')->href('#')->anchor('Action') .
			tag('dropdownItem')->href('#')->anchor('Another action') .
			tag('dropdownItem')->href('#')->anchor('Something else here')
		)
	);

En vez de un button puede usarse un link:

	echo tag('dropdown')->content(
		tag('dropdownLink')->id('dropdownMenuButton1')->href('#')->anchor('Dropdown button') .
		tag('dropdownMenu')->ariaLabel('dropdownMenuButton1')->content(
			tag('dropdownItem')->href('#')->anchor('Action') .
			tag('dropdownItem')->href('#')->anchor('Another action') .
			tag('dropdownItem')->href('#')->anchor('Something else here')
		)
	);

Variantes de los botones

Ej:

Se puede aplicar danger(), warning(), success() ... outline() a los botones.

Ej:

	echo tag('dropdown')->content(
		tag('dropdownButton')->id('dropdownMenuButton1')->content('Dropdown button')->danger() .

		tag('dropdownMenu')->ariaLabel('dropdownMenuButton1')->content(
			tag('dropdownItem')->href('#')->anchor('Action') .
			tag('dropdownItem')->href('#')->anchor('Another action') .
			tag('dropdownItem')->href('#')->anchor('Something else here')
		)
	);

Divisor 

Se pueden agregar divisores entre los items del menú con dropdownDivider()

	echo tag('dropdown')->content(
		tag('dropdownButton')->id('dropdownMenuButton1')->content('Dropdown button')->danger()->outline() .
		tag('dropdownMenu')->ariaLabel('dropdownMenuButton1')->content(
			tag('dropdownItem')->href('#')->anchor('Action') .
			tag('dropdownItem')->href('#')->anchor('Another action') .
			tag('dropdownDivider') .
			tag('dropdownItem')->href('#')->anchor('Something else here')
		)
	);

Tamaño del botón

Se ajusta con small() o large() sobre dropdown()

Ej:

	echo tag('dropdown')->content(
		tag('dropdownButton')->id('dropdownMenuButton1')->content('Dropdown button')->danger()->outline()->large() .
		tag('dropdownMenu')->ariaLabel('dropdownMenuButton1')->content(
			tag('dropdownItem')->href('#')->anchor('Action') .
			tag('dropdownItem')->href('#')->anchor('Another action') .
			tag('dropdownDivider') .
			tag('dropdownItem')->href('#')->anchor('Something else here')
		)
	);

Disabled

Para des-habilitar solo aplicar disabled() sobre el botón


# Split buttons

Son una variación de los dropdowns donde lo que cambia es el tag split por dropdown y dos botones en vez del dropdownButton.

Ej:

	echo tag('split')->content([
      tag('button')->content('Split button')->default(),

      tag('splitButton')->id('dropdownMenuButton33')->content('Toggle Dropdown'),

      tag('dropdownMenu')->ariaLabel('dropdownMenuButton33')->content(
        tag('dropdownItem')->href('#ln1')->anchor('Action #1') .
          tag('dropdownItem')->href('#ln2')->anchor('Another action') .
          tag('dropdownDivider') .
          tag('dropdownItem')->href('#ln3')->anchor('Something else here')
      )
    ]);

A diferencia del dropdown despliega las opciones hacia la derecha y con el color default se ve una línea divisoria en el botón.


# List group

Ej:

	echo tag('listGroup')->content([
		tag('listGroupItem')->text('An item'),
		tag('listGroupItem')->text('An item #2'),
		tag('listGroupItem')->text('An item #3')
	])->class('mt-3');

Item "activo"

	echo tag('listGroup')->content([
		tag('listGroupItem')->text('An item')->active(),
		tag('listGroupItem')->text('An item #2'),
		tag('listGroupItem')->text('An item #3')
	])->class('mt-3');

En caso de querer usar la clase Bt5Form en vez de Tag() sería:

    Bt5Form::listGroupItem('An item', ['active' => true]),
o
	Bt5Form::listGroupItem(text:'An item', active:true),


Actionable

Solo aplique actionable() sobre los items.

	echo tag('listGroup')->content([
		tag('listGroupItem')->text('An item #1')->actionable()->active(),
		tag('listGroupItem')->text('An item #2')->actionable(),
		tag('listGroupItem')->text('An item #3')->actionable()
	])->class('mt-5');


Removoción de bordes

Para hacer un "flush" solo aplique flush() al listGroup.

Ej:

	echo tag('listGroup')->content([
		// ...
	])->flush();

Numerados

Se puede aplicar un numerado sobre el listGroup con numbered() aunque en principio no es compatible con actionable.

Ej:

	echo tag('listGroup')->content([
		tag('listGroupItem')->text('An item')->active(),
		tag('listGroupItem')->text('An item #2'),
		tag('listGroupItem')->text('An item #3')
	])->class('mt-5')->numbered();


Si se quisiera usar la clase Bt5Form directamente para el caso de numbered sería así:

	echo Bt5Form::listGroup([
		// Items
	], ['class' => 'mt-5', 'numbered' => true] );


Arreglo horizontal

Se logra aplicando horizontal() sobre el listGroup.

Ej:

	echo tag('listGroup')->content([
		tag('listGroupItem')->text('An item')->active(),
		tag('listGroupItem')->text('An item #2'),
		tag('listGroupItem')->text('An item #3')
	])->class('mt-5')->horizontal();

Colores

Se pueden aplicar colores sobre cada item con color($color). No intente con $color() como success() porque NO es lo que desea.

Ej:

	echo tag('listGroup')->content([
		tag('listGroupItem')->text('An item #1')->color('info'),
		tag('listGroupItem')->text('An item #2')->warning(),  // mal
		tag('listGroupItem')->text('An item #3')->color('success')  // ok
	])->class('mt-5')->horizontal();


# Navs

	echo tag('nav')->content([
		tag('navLink')->anchor('Active')->active(),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Disabled')->disabled()
	])->class('mb-3')
	//->vertical()
	->justifyRight()
	//->justify()
	->pills()
	//->fill()
	//->tabs();    

Vertical

Solo aplique vertical() a tag('nav')

Ej:

	tag('navLink')->anchor('Active')->active(),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Disabled')->disabled()
	])
	->vertical();    

Justify right

Solo aplique justifyRight() a tag('nav')


Pills

Solo aplique pills() a tag('nav')


Tabs

Solo aplique tabs() a tag('nav')

Ej:

	tag('navLink')->anchor('Active')->active(),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Disabled')->disabled()
	])
	->pills
	->tabs(); 

Fill

Para que el nav ocupe todo el espacio disponible en ancho use fill()

Ej:

	tag('navLink')->anchor('Active')->active(),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Link'),
		tag('navLink')->anchor('Disabled')->disabled()
	])
	->fill();    


Justify

	Para que el nav ocupe todo el espacio disponible y el ancho de cada botón sea el mismo use justify() en vez de fill()


Si por alguna razón deseara usar "navItems" como wrapper sobre los navLinks haga aplique as('ul') sobre tag('nav') 

Ej:

	echo tag('nav')->content([
		tag('navItem')->content(
			tag('navLink')->anchor('Active')->active()
		),
		tag('navItem')->content(
			tag('navLink')->anchor('Link')
		),
		tag('navItem')->content(
			tag('navLink')->anchor('Link')
		),
		tag('navItem')->content(
			tag('navLink')->anchor('Disabled')->disabled()
		)
	])->as('ul')->justifyRight();     


Working with flex utilities

"If you need responsive nav variations, consider using a series of flexbox utilities. 
While more verbose, these utilities offer greater customization across responsive breakpoints."

https://getbootstrap.com/docs/5.0/components/navs-tabs/#working-with-flex-utilities


Nav con Dropdowns

Add dropdown menus with a little extra HTML and the dropdowns JavaScript plugin.

Ej:

	echo tag('nav')->content([             
		tag('navLink')->anchor('Active')->active(),    

		tag('dropdown')->content(
			tag('dropdownButton')->id('dropdownMenuButton1')->content('Dropdown button') .

			tag('dropdownMenu')->ariaLabel('dropdownMenuButton1')->content(
				tag('dropdownItem')->href('#')->anchor('Action') .
				tag('dropdownItem')->href('#')->anchor('Another action') .
				tag('dropdownDivider') .
				tag('dropdownItem')->href('#')->anchor('Something else here')
			)
		),

		tag('navLink')->anchor('Link'),        
		tag('navLink')->anchor('Disabled')->disabled()

	])	
	->justifyRight()	
	->tabs();     

O con navItems (aunque el resultado es el mismo),

	echo tag('nav')->content([     
		tag('navItem')->content(        
			tag('navLink')->anchor('Active')->active(),    
		),    
		tag('navItem')->content(
			tag('dropdown')->content(
				tag('dropdownButton')->id('dropdownMenuButton1')->content('Dropdown button') .    
				tag('dropdownMenu')->ariaLabel('dropdownMenuButton1')->content(
					tag('dropdownItem')->href('#')->anchor('Action') .
					tag('dropdownItem')->href('#')->anchor('Another action') .
					tag('dropdownDivider') .
					tag('dropdownItem')->href('#')->anchor('Something else here')
				)
			)
		),

		tag('navItem')->content(
			tag('navLink')->anchor('Link'), 
		),     
		
		tag('navItem')->content(
			tag('navLink')->anchor('Disabled')->disabled()
		)    
	])


Simplificación

En muchos casos se puede simplificar enviando un array a tag('nav') de estructura similar al que recibe breadcrumb.

	echo tag('nav')->content([  
		[
			'href'   => '#',
			'anchor' => 'Home'
		],

		[
			'href' => '#library',
			'anchor' => 'Library'
		],

		[
			'anchor' => 'Data'
		]
	])
	->justifyRight()
	->tabs();     

Casting 

Un navLink es implementado con un el tag <a> pero se lo puede "castear" a <button> mediante as()

Ej:

	tag('navLink')->anchor('Click Me')->as('button')


Tab list

De momento a medio-implementar pero la idea es pasar el array de "links", aplicar tabs() o pills() y role('tablist') así como un array con los "textos" (html) a renderizar para cada tab.

Ej:

	// Nav como tab-list
	echo tag('nav')->content([  
		[
			'anchor' => 'Uno',
			'href'   => '#uno'
		],

		[
			'anchor' => 'Dos',
			'href' => '#dos'
		],

		[
			'anchor' => 'Tres',
			'href'   => '#tres'
		]
	])->class('mb-3')
	->justifyRight()
	->tabs()
	->role('tablist')
	->panes([
		'Textoooooooooo oo',
		'otroooooo',
		'y otro más'            
	]); 

Inclusive es posible combinar "panes" con un Dropdown

Ej:

	// Nav como tab-list
	echo tag('nav')->content([  
		[
			'anchor' => 'Uno',
			'href'   => '#uno'
		],

		[
			'anchor' => 'Dos',
			'href' => '#dos'
		],

		[
			'anchor' => 'Tres',
			'href'   => '#tres'
		],
		tag('dropdown')->content(
			tag('dropdownButton')->id('dropdownMenuButton')->content('Dropdown button') .    
			tag('dropdownMenu')->ariaLabel('dropdownMenuButton')->content(
				tag('dropdownItem')->href('#')->anchor('Action 1') .
				tag('dropdownItem')->href('#')->anchor('Another action') .
				tag('dropdownDivider') .
				tag('dropdownItem')->href('#')->anchor('Something else here')
			)
		),
	])->class('mb-3')
	->justifyRight()
	->tabs()
	->role('tablist')
	->panes([
		'Textoooooooooo oo',
		'otroooooo',
		'y otro más'            
	]); 

Lo importante en este último caso es que tanto el array de "links" como los "panes" apuntados por los primeros conserven los mísmos índices.

También puede hacerse de píldoras en vertical aplicando pills() y vertical() al nav.

Ej:

	// Nav como tab-list
	echo tag('nav')->content([  
		[
			'anchor' => 'Uno',
			'href'   => '#uno'
		],

		[
			'anchor' => 'Dos',
			'href' => '#dos'
		],

		[
			'anchor' => 'Tres',
			'href'   => '#tres'
		]
	])->class('mb-3')
	->vertical()
	->pills()
	->role('tablist')
	->panes([
		'Textoooooooooo oo',
		'otroooooo',
		'y otro más'            
	]);  


# Navbar

Hay varios sub-componentes y utilidades para armar un navbar entre ellos navbarBrand, navbarToggler,...

Brand

Para mostrar el logo en el navbar ya sea como texto o imágen con o sin enlace la estructura básica incluye al navbar, un contenedor y un navbarBrand.

Ej:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor('Navbar')
		])
	);  

con enlace:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor('Navbar')->href('#')
		])
	);  

Con imágen es solo pasar la imágen dentro del anchor del navbarBrand:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
			)->href('#')
		])
	)

Imágen + texto

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
				->class("d-inline-block align-text-top") . '&nbsp;&nbsp; Some text'
			)->href('#') 
		])
	)


Tema / estilos

De mínima puede cambiarse a tema oscuro aplicando dark() sobre el navbar.

Ej:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
				->class("d-inline-block align-text-top") . '&nbsp;&nbsp; Some text'
			)->href('#') 
		])
	)->class('mb-3')
	->dark()


Navbar collapsable

Cuando hay varios elementos en el navbar entonces éste debe colapsarse en dispositivos con poco ancho renderizando en su lugar el ícono de hamburguesa conocido como "toggler" (elemento navbarToggler) ya que al ser clickeado se alterna entre el colapso y descolapso de elementos.

Use expand() para que los elementos dentro del navbar se muestren en vez de estar colapsados.

Ej:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
				->class("d-inline-block align-text-top") . '&nbsp;&nbsp; Some text'
			)->href('#'),
			
			tag('navbarToggler')->target("#navbarNavAltMarkup"),

			tag('navbarCollapse')->content([
				tag('navbarNav')->content([
					tag('navLink')->anchor('Home')->active(),
					tag('navLink')->anchor('Features')->href('#features'),
					tag('navLink')->anchor('Pricing')->href('#pricing'),
					tag('navLink')->anchor('Disabled')->disabled()->attributes(["tabindex" => "-1"])
				])
			])->id("navbarNavAltMarkup")
		])
	)->expand();

O enviando un array más simple a navbarNav.

Ej:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
				->class("d-inline-block align-text-top") . '&nbsp;&nbsp; Some text'
			)->href('#'),
			
			tag('navbarToggler')->target("#navbarNavAltMarkup"),

			tag('navbarCollapse')->content([
				tag('navbarNav')->content([
					[
						'anchor'   => 'Home'
					],
					[
						'anchor'   => 'Features',
						'href'     => '#features'
					],
					[
						'anchor'   => 'Pricing',
						'href'     => '#pricing'
					],
					[
						'anchor'   => 'Disabled',
						'class'    => 'disabled',
						'aria-disabled' => "true"                        
					],
				])
			])->id("navbarNavAltMarkup")
		])
	)->expand()

Se puede agregar dropDown como un elemento más al navbar.

Ej:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
				->class("d-inline-block align-text-top") . '&nbsp;&nbsp; Some text'
			)->href('#'),
			
			tag('navbarToggler')->target("#navbarNavAltMarkup"),

			tag('navbarCollapse')->content([
				tag('navbarNav')->content([
					[
						'anchor'   => 'Home'
					],
					[
						'anchor'   => 'Features',
						'href'     => '#features'
					],
					[
						'anchor'   => 'Pricing',
						'href'     => '#pricing'
					],
					[
						'anchor'   => 'Disabled',
						'class'    => 'disabled',
						'aria-disabled' => "true"                        
					],

					/*
						Dropdown
					*/
					tag('dropdown')->content(
						tag('dropdownButton')->id('dropdownMenuButton33')->content('Dropdown button') .    
						tag('dropdownMenu')->ariaLabel('dropdownMenuButton33')->content(
							tag('dropdownItem')->href('#')->anchor('Action') .
							tag('dropdownItem')->href('#')->anchor('Another action') .
							tag('dropdownDivider') .
							tag('dropdownItem')->href('#')->anchor('Something else here')
						)
					),
				])
			])->id("navbarNavAltMarkup")
		])
	)->class('mb-3')->expand()


Para que el <form> barra de búsqueda quede del lado derecho y el navbarBrand del lado izquierdo debe sacarse fuera del form. La distribución de estos elementos sería la de un flexbox.	

Ej:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
				->class("d-inline-block align-text-top") . '&nbsp;&nbsp; Some text'
			)->href('#'),

			tag('form')->class("d-flex")->content([
				tag('search')->placeholder("Search")->class('me-2'),
				tag('button')->outline()->success()->value('Search')
			])
		])->class('mb-3')
	)

Posicionamiento

Para fijar el navbar al márgen 

...	superior: 			fixed-top
...	superior flotando:  sticky-top
...	inferior: 			fixed-bottom

Ej:

	echo tag('navbar')->content(
		tag('container')->fluid()->content([
			tag('navbarBrand')->anchor(
				tag('img')->src(asset('img/ai_logo.png'))->witdh(24)->height(24)
				->class("d-inline-block align-text-top") . '&nbsp;&nbsp; Some text'
			)->href('#'),
			
			tag('navbarToggler')->target("#navbarNavAltMarkup"),

			tag('navbarCollapse')->content([
				tag('navbarNav')->content([
					[
						'anchor'   => 'Home'
					],
					[
						'anchor'   => 'Features',
						'href'     => '#features'
					],
					[
						'anchor'   => 'Pricing',
						'href'     => '#pricing'
					],
					[
						'anchor'   => 'Disabled',
						'class'    => 'disabled',
						'aria-disabled' => "true"                        
					]
				])
			])->id("navbarNavAltMarkup")
		])
	)->class('mb-3 fixed-top');


Scrolling

Es posible habilitar el scrolling vertical de los elementos colapsados:

https://getbootstrap.com/docs/5.0/components/navbar/#scrolling


Responsive behaviors

Navbars can use .navbar-toggler, .navbar-collapse, and .navbar-expand{-sm|-md|-lg|-xl|-xxl} classes to determine when their content collapses behind a button. In combination with other utilities, you can easily choose when to show or hide particular elements.

For navbars that never collapse, add the .navbar-expand class on the navbar. For navbars that always collapse, don’t add any .navbar-expand class.


# Offcanvas

Son paneles laterales ocultos que se desocultan ante un evento y presentan generalmente opciones.

El panel se puede desocultar con un offcanvasLink o bien un offcanvasOpenButton y se cierra con un offcanvasCloseButton.

La estructura básica es:

	<button | link href="#id">

	<offcanvas id="">
		<offcanvasHeader>
			<offcanvasTitle>
			<offcanvasCloseButton>

		<offcanvasBody>

Ej:

	echo tag('div')->content([
		tag('offcanvasLink')->anchor('Link with href')->href('#offcanvasExample')->class('btn btn-primary'),
		tag('offcanvasOpenButton')->anchor('Button with data-bs-target')->href('#offcanvasExample')
	])->class('vstack gap-2 col-md-5 mx-auto my-3');

	echo tag('offcanvas')->id("offcanvasExample")->content([
		tag('offcanvasHeader')->content([
			tag('offcanvasTitle')->text('Offcanvas'),
			tag('offcanvasCloseButton')
		]),

		tag('offcanvasBody')->content([
			/*
				Body example
			*/
			
			'Some text as placeholder. In real life you can have the elements you have chosen. Like, text, images, lists, etc.',

			tag('dropdown')->content(
				tag('dropdownButton')->id('dropdownMenuButtonX')->content('Dropdown button')
				->success() .
	
				tag('dropdownMenu')->ariaLabel('dropdownMenuButtonX')->content(
					tag('dropdownItem')->href('#')->anchor('Action') .
					tag('dropdownItem')->href('#')->anchor('Another action') .
					tag('dropdownDivider') .
					tag('dropdownItem')->href('#')->anchor('Something else here')
				)
			)

		])
	]);


Se puede simplificar haciendo que <offcanvas> aceptara el Title y el Body (como content) 

	<offcanvas id="">
		<offcanvasHeader>
			<offcanvasTitle>
			<offcanvasCloseButton>

		<offcanvasBody>

A ...

	<offcanvas id="" title="" body="">

Ej:

		echo tag('div')->content([
            tag('offcanvasLink')->anchor('Link with href')->href('#offcanvasExample')->class('btn btn-primary'),
        ])->class('vstack gap-2 col-md-5 mx-auto my-3');

        echo tag('offcanvas')->id("offcanvasExample")->title('Offcanvas')->body([
            // The body
            )
        ]);

Placement

There’s no default placement for offcanvas components, so you must add one of the modifier classes below;

.offcanvas-start 	places offcanvas on the left of the viewport (shown above)
.offcanvas-end 		places offcanvas on the right of the viewport
.offcanvas-top 		places offcanvas on the top of the viewport
.offcanvas-bottom 	places offcanvas on the bottom of the viewport

En si es aplicar pos() con {'left', 'right', 'top' o 'bottom'} a offcanvas.

Ej:

	echo tag('div')->content([
		tag('offcanvasLink')->anchor('Link with href')->href('#offcanvasExample')->class('btn btn-primary'),
	])->class('vstack gap-2 col-md-5 mx-auto my-3');

	echo tag('offcanvas')->id("offcanvasExample")->title('Offcanvas')->body([
		// The body
		)
	])->bottom();

Scroll

Para habilitar el scroll del resto de la página se debe setear el atributo

	data-bs-scroll="true"


Oscurecer el fondo

Para oscurecer el resto de la página (que se verá como en segundo plano) es seteando el atributo

	data-bs-backdrop="true" 

que se puede usar en conjunto con data-bs-scroll="true"


Se implementaron backdrop() y scroll() para oscurecer el fondo y habilitar scroll respectivamente.

Ej:

		echo tag('offcanvas')->id("offcanvasExample")->title('Offcanvas')->body(
            'Some text as placeholder. In real life you can have the elements you have chosen. Like, text, images, lists, etc.'
        ])
        ->pos('left')
        ->backdrop()
        ->scroll();

Nota: recordar que es necesario un enlace o botón o algún evento para visibilizar el offcanvas.


# Pagination

Para crear un paginador es con paginator.

Ej:

	echo tag('paginator')->content([
		[
			'href'   => '#?page=1',
			'active' => true
		],
		[
			'href' => '#?page=2'
		],
		[
			'href' => '#?page=3'
		]
	]);

Sizing

Se pueden aplicar small() o larg() a paginator.

	echo tag('paginator')->content([
		[
			'href'   => '#?page=1',
			'active' => true
		],
		[
			'href' => '#?page=2'
		],
		[
			'href' => '#?page=3'
		]
	])->class('mt-5')->large();

Alignment

En si el paginador es una "lista" desordenada (ul) y se pueden aplicar flexbox utilities sobre el <ul class="pagination"> mediante options() 

Ej:

	echo tag('paginator')->content([
		[
			'href'   => '#?page=1',
			'active' => true
		],
		[
			'href' => '#?page=2'
		],
		[
			'href' => '#?page=3'
		]
	])->class('mt-5')->options(['justify-content-center']);


Next & Previous

Para renderizar los botones de atrás y adelante es aplicando withPrev() y withNext()

Ej:

	echo tag('paginator')->content([
		[
			'href'   => '#?page=1',
			'active' => true
		],
		[
			'href' => '#?page=2'
		],
		[
			'href' => '#?page=3'
		]
	])
	->withPrev([
		'href'   => '#?page=1',
		'anchor' => 'Previous',
		'disabled' => true
	])
	->withNext([
		'href'   => '#?page=4',
		'anchor' => 'Next'
	]);


Mostrar flechas

Si se desea mostrar íconos de flechas en vez las leyendas Next | Previous, solo reemplace por '&laquo;' y '&raquo;' respectivamente.

	->withPrev([
		'href'   => '#?page=1',
		'anchor' => '&laquo;',
		'disabled' => true
	])
	->withNext([
		'href'   => '#?page=11',
		'anchor' => '&raquo;'
	])


Personalización

Ej:

	/*
		Previous | 1 | 2 | 3 | .. | 10 | Next
	*/
	echo tag('paginator')->content([
		[
			'href'   => '#?page=1',
			'active' => true
		],
		[
			'href' => '#?page=2'
		],
		[
			'href' => '#?page=3'
		],
		[
			'href' => '#',
			'anchor' => '..',
			'disabled' => true
		],
		9 => [
			'href' => '#?page=10'
		]
	])
	->class('mt-5')
	->large()
	->options(['justify-content-center'])
	->withPrev([
		'href'   => '#?page=1',
		'anchor' => 'Previous',
		'disabled' => true
	])
	->withNext([
		'href'   => '#?page=11',
		'anchor' => 'Next'
	]);

El truco está en:

	[
		'href' => '#',
		'anchor' => '..',
		'disabled' => true
	],
	9 => [
		'href' => '#?page=10'
	]

Se especifica un anchor '..' donde normalmente va el número de página en automático y se agrega en la secuencia la página 10 que sería la #4 ya que es un array de 5 elementos comenzando por 0 pero se fuerza se vea como #10 agregándo manualmente el índice como 9.

Lógica incluida

Si la página activa es la primera, entonces se auto-desabilita el botón prev y no es necesario pasar 'disabled' => true

Ej:

	echo tag('paginator')->content([
		[
			'href'   => '#?page=1',
			'active' => true              
		],
		[
			'href' => '#?page=2'                
		],
		[
			'href' => '#?page=3'
		]
	])
	->class('mt-5')
	->large()
	->options(['justify-content-center'])
	->withPrev([
		'href'   => '#?page=1',
		'anchor' => 'Previous'
	])
	->withNext([
		'href'   => '#?page=4',
		'anchor' => 'Next'
	]);
	

Podría incluirse más lógica como que:

- Si hay una sola página que se deshabiliten tanto Prev como Next.

- Que si se recibe como parámetro del número total de páginas y está activa la última, entonces se desabilite Next.


Paginador de meses

Debe aplicarse la clase de css "pagination-month" al paginator e incluir en principio cierto html para cada mes-año.

Ej:

	/*
		Previous | Ene | Feb | Mar | Next
	*/
	echo tag('paginator')
	->class('pagination-month')
	->content([
		[
		'href'   => '#?page=1',
		'anchor' => '
					<p class="page-month">Ene</p>
					<p class="page-year">2021</p>'
		],
		[
			'href'   => '#?page=2',
			'anchor' => '
						<p class="page-month">Feb</p>
						<p class="page-year">2021</p>',
			'active' => true
		],
		[
		'href'   => '#?page=3',
		'anchor' => '
					<p class="page-month">Mar</p>
					<p class="page-year">2021</p>'
		],
		// ...
	])
	->options(['justify-content-center'])
	->withPrev([
		'href'   => '#?page=1',
		'anchor' => '&laquo;',
	])
	->withNext([
		'href'   => '#?page=11',
		'anchor' => '&raquo;',
	]);


# Placeholders

Use loading placeholders for your components or pages to indicate something may still be loading.

En particular se implemetó para cardTitle, cardSubtitle, cardText e inputButton.

Ej:

	echo tag('card')->style('width: 18rem;')->class('my-3')
	->content(
		tag('cardImgTop')->src(asset('img/mail.png'))
	)
	->body([            
		tag('cardTitle')
		->placeholder(),
		
		tag('cardSubtitle')
		->placeholder(),

		tag('cardText')
		->placeholder(),
		
		tag('inputButton')->value('Go somewhere')
		->placeholder()
	]);

Color

Se pueden aplicar los colores de background bg-* con bg()

Ej:

	echo tag('card')->style('width: 18rem;')->class('my-3')
	->content(
		tag('cardImgTop')->src(asset('img/mail.png'))
	)
	->body([            
		tag('cardTitle')
		->placeholder()->bg('danger'),
		
		tag('cardSubtitle')
		->placeholder()->bg('warning'),

		tag('cardText')
		->placeholder()->bg('success'),
		
		tag('inputButton')->value('Go somewhere')
		->placeholder()
	]);


# Popover

Un popover debe ser habilitado via JavaScript. La forma más sencilla es habilitar todos referenciándolos via clase css. Se utlizará la clase "popovers" para hacer esa referencia.

	<button type="button" 
	class="btn btn-lg btn-danger popovers" 
	data-bs-toggle="popover" 
	title="Popover title" 
	data-bs-content="And here's some amazing content. It's very engaging. Right?">Click to toggle popover</button>

O con links

	<a role="button" 
	class="btn btn-lg btn-danger" 
	data-bs-toggle="popover" 
	data-bs-trigger="focus" 
	title="Dismissible popover" 
	data-bs-content="And here's some amazing content. It's very engaging. Right?">Dismissible popover</a>

El JavaScript habilitante para los popovers es:

	var popover = new bootstrap.Popover(document.querySelector('.popovers'), {
		container: 'body'
	})

Ej:

	echo tag('popoverButton')
	->content('Click to toggle popover')
	->title('Popover title')
	->body("And here's some amazing content. It's very engaging. Right?")
	->class('btn-lg')->danger();

Four directions

Aplique pos() con top, bottom, left o right.

	echo tag('popoverButton')
	->content('Click to toggle popover')
	->title('Popover title')
	->body("And here's some amazing content. It's very engaging. Right?")
	->class('btn-lg')->danger()->pos('top');

Es importante notar que sino hay espacio el popover no se materializa aunque se intentará hacerlo aparecer del lado derecho (default).

Dismiss on next click

Se logra aplicando dismissible()

Ej:
	echo tag('popover')
	->content('Click to toggle popover')
	->title('Popover title')
	->body("And here's some amazing content. It's very engaging. Right?")
	->as('button')
	->class('btn-lg mt-5')->danger()->pos('top')
	->dismissible();

Casting

En caso de querer usar un <button> haga el casting correspondiente con as()

	echo tag('popover')
	->content('Click to toggle popover')
	->title('Popover title')
	->body("And here's some amazing content. It's very engaging. Right?")
	->as('button')
	->class('btn-lg mt-5')->danger()->pos('top');

De momento solo se puede cambiar el color del botón cuando se hace el casting a button. A corregir moviendo el casting al método tag.


# Progress bars

Indican el avance de un proceso, generalmente en porcentaje (%) y por ello por defecto se asume:

	min = 0
	max = 100

Ej:

	echo tag('progress')->content(
		tag('progressBar')->current(80)
	);

También claro puede especificarse el rango.

Ej:

	echo tag('progress')->content(
		tag('progressBar')
		->min(5)
		->max(25)
		->current(15)
	);

Labels

Para mostrar una label con el % de avance es con withLabel() sobre el progresBar.

Ej:

	echo tag('progress')->content(
		tag('progressBar')
		->min(5)
		->max(25)
		->current(15)->withLabel()
	)

Height

Se logra seteando la altura en progress.

	echo tag('progress')->content(
		tag('progressBar')
		->current(25)->withLabel()
	)->class('my-5')->style("height: 50px");


Background colors

Aplicando bg($color) sobre el progressBar.

Ej:

	echo tag('progress')->content(
		tag('progressBar')
		->current(25)->withLabel()->bg('danger')
	)->class('my-5')->style("height: 50px;");


Multiple bars

Include multiple progress bars in a progress component if you need.

	echo tag('progress')->content([
		tag('progressBar')
		->current(15)->withLabel()->bg('primary'),

		tag('progressBar')
		->current(30)->withLabel()->bg('success'),

		tag('progressBar')
		->current(25)->withLabel()->bg('info')
	])->class('mt-3');

Striped

Se puede aplicar un gradiente de color con striped() sobre el progresBar.

Ej:

	echo tag('progress')->content(
		tag('progressBar')
		->min(5)
		->max(25)
		->current(15)->withLabel()->striped()
	)->class('my-5');

Animated

Aplicando animated() una progresBar se hace striped y se "anima".

Ej:

	echo tag('progress')->content(
		tag('progressBar')
		->current(25)->withLabel()->bg('danger')->animated()
	)->class('my-5')->style("height: 50px;");


Sería ideal poder encapsular en un componente o en varios (por el tema de las progresBar múltiples).


Con AdminLTE al menos,... se definen clases de css para los tamaños xxs, xs y sm que se pueden aplicar con size()

	echo tag('progress')->content(
	tag('progressBar')
	->current(25)->bg('danger')->animated()
	->size('xxs');  

Barras de progreso verticales

Aplicar vertical() 

	echo tag('progress')->content(
		tag('progressBar')
		->current(20)->bg('primary')->striped()
	)
	->size('xs')
	->vertical();  


# Scrollspy

To easily add scrollspy behavior to your topbar navigation, add data-bs-spy="scroll" to the element you want to spy on (most typically this would be the <body>). Then add the data-bs-target attribute with the ID or class of the parent element of any Bootstrap .nav component.


	body {
		position: relative;
	}

	<body data-bs-spy="scroll" data-bs-target="#navbar-example">
		...
		<div id="navbar-example">
			<ul class="nav nav-tabs" role="tablist">
			...
			</ul>
		</div>
		...
	</body>

<-- no logré funcionara. Queda pendiente ! problema: recarga la página en vez de ir al #id.

# Spinners

Ej:

	echo tag('spinner');

Colors

Ej:

	echo tag('spinner')->textColor('danger')

Growing spinner

	echo tag('spinner')->textColor('danger')->grow();
	
Placement

Solo utilice un wrapper y utilidades como flex. Ej:

	<div class="d-flex justify-content-center">
	<?php
		echo tag('spinner')->textColor('danger')->grow();
	?>
	</div>

Sizing

Use size() con el tamaño expresado en rems. El valor por defecto parecer ser 2 rems.

Ej:

	echo tag('spinner')->class('my-3')->color('danger')->grow()->size(5);


En botones

Ej:

	echo tag('spinner')->class('my-3')->as('button');
	echo tag('p');
	echo tag('spinner')->class('my-3')->grow()->as('button');

Con texto como "Loading..."

Ej:

	echo tag('spinner')->class('my-3')->as('button')->unhide();
	echo tag('p');
	echo tag('spinner')->class('my-3')->grow()->as('button')->unhide();

Para cambiar el texto "Loading.." por otro solo envíelo en content()

Ej:

echo tag('spinner')->class('my-3')->grow()->as('button')->unhide()->content('Cargando..');


# Toasts

Sirven para notificaciones en tiempo real (del lado del front) y por ello no tiene mucho sentido implementarlas en el backend (con PHP)

Importante:

- Toasts are opt-in for performance reasons, so you must initialize them yourself.
- Toasts will automatically hide if you do not specify autohide: false.


To encourage extensible and predictable toasts, we recommend a header and body.

At a minimum, we require a single element to contain your “toasted” content and strongly encourage a dismiss button.

El código HTML mínimo recomendado es el siguiente:

	<!-- button to initialize toast -->
	<button type="button" class="btn btn-primary" id="toastbtn">Initialize toast</button>

	<!-- positioning ->
	<div class="position-fixed bottom-0 end-0 p-3" style="z-index: 11">

		<!-- Toast -->
		<div class="toast" id="toastNotice">
			
			<div class="toast-header">  
			<svg class="bd-placeholder-img rounded me-2" width="20" height="20" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" preserveAspectRatio="xMidYMid slice" focusable="false"><rect width="100%" height="100%" fill="#007aff"></rect></svg>
			<strong class="me-auto">Bootstrap</strong>
			<small>11 mins ago</small>
			<button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
			</div>

			<div class="toast-body">
			Hello, world! This is a toast message.
			</div>

		</div>

	</div>

Con el builder:

	echo tag('button')->id("toastbtn")->value("Abrir toast");

	echo tag('div')->class("position-fixed bottom-0 end-0 p-3")->style("z-index: 11")->content(
			tag('toast')->content([
				tag('toastHeader')->content([
					'<svg class="bd-placeholder-img rounded me-2" width="20" height="20" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" preserveAspectRatio="xMidYMid slice" focusable="false"><rect width="100%" height="100%" fill="#007aff"></rect></svg>
					<strong class="me-auto">Bootstrap</strong>
					<small>11 mins ago</small>',

					tag('toastCloseButton')
				]),
				tag('toastBody')->content(
					'Hello, world! This is a toast message.'
				),
			])
	);

Los toast requieren inicialización via JavaScript:

	document.getElementById("toastbtn").onclick = function() {
		var myAlert =document.querySelector('.toast');
		var bsAlert = new bootstrap.Toast(myAlert);//inizialize it
		bsAlert.show();//show it
	};

Notas:

Las "toast" sirven para notificaciones en tiempo real (del lado del front) y por ello no tiene mucho sentido implementarlas en el backend (con PHP)

Boostrap 5 tiene varias opciones más para toast de las descritas aquí.


# Tooltips

Tooltips y popovers son componentes similares siendo lo tooltips para mostrar mucho menos texto y son más simples.

inicialización

Los tooltips deben ser inicializados por motivos de performance:

	var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
		var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
		return new bootstrap.Tooltip(tooltipTriggerEl)
	})

Ej:

	echo tag('tooltip')->title('Some title')->content('Tooltip on top');

Positioning

	echo tag('tooltip')->title('Some title')->content('Tooltip on bottom')->pos('bottom');


# Colors

Para los botones y alertas en particular existen "temas" que ajustan tanto el color del texto como el background de los botones manejados por las clases btn-{color}, btn-outline-{color} y alert-{color}.

Estos se aplican con los "métodos"

	info()
	success()
	warning()
	danger()
	etc

En general existen los "text colors" y "background colors" que se aplican respectivamente con textColor() y bg()

Ej:

	echo tag('card')->style('width: 18rem;')
	->body([            
		tag('cardTitle')->text('Some title'),
		tag('cardText')->text('Some quick example text to build on the card title and make up the bulk of the cards content.'),
		tag('inputButton')->value('Go somewhere')->info()->textColor('white')
	])
	->class('my-3')
	->bg('primary')
	->textColor('white');

Para el caso particular de los botones donde se puede aplicar el outline es con outline() 

Ej:

	tag('button')->content('Botón verde')->class('rounded-pill')->success()->outline()

En algunos componentes se permitió el uso de color() como alternativa a $color()

Ej:

	echo tag('alert')->content(
        tag('alertLink')->href('#')->anchor('A danger content')
    )->color('danger')->dismissible(true);

Equivale a,...

	echo tag('alert')->content(
        tag('alertLink')->href('#')->anchor('A danger content')
    )->danger()->dismissible(true);


Se está transicionando de la forma success() a bg('success') o lo que corresponda por cuestiones de eficiencia. 

Sin embargo hay casos donde no se puede evitar el uso de color()

Ej:

	// incorrecto: bg-{$color}
	tag('listGroupItem')->text('An item #3')->bg('success')

No es lo mismo que 

	// correcto: list-group-item-{$color}
	tag('listGroupItem')->text('An item #3')->color('success')


Opacidad

La opacidad es una propiedad que tiene un rango de 0 a 1 y se aplica con opacity()

Ej:

	echo tag('div')->content('Some content')->textColor('primary')->opacity(0.5);


Gradiente de color

Ej:

  echo tag('div')->class('mt-5 p-3 py-5 mb-2')
  ->content('Gradiente?')
  ->textColor('white')
  ->bg('success')
  ->gradient();


Link colors

En teoría (según la doc oficial), para los links deben aplicarse clases css link-{color} sin embargo,
en principio producen el mismo efecto que los text-{color}

Usar color() para aplicar "link colors".

Ej:

	echo tag('link')
	->href("www.solucionbinaria.com")
	->anchor('SolucionBinaria .com')
	->color('success');


# Borders

Con border() se aplican borders sobre todos los lados.

Ej:

	echo tag('div')->width(100)->content('
		Some content,...
		<p>
		<p>
	')
	->border();

Bordes sobre lados (aditivos)

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    ->border()
    ->border('top bottom');

Bordes sobre lados (substractivo)

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    ->border()
    ->borderSub('top bottom');  // solo a los lados

Border color

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    ->border()
    ->borderSub('top bottom')
	->borderColor('success');

Border width

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    ->border('top left right')
    ->borderColor('success')
	->borderWidth(5);

Border radius

Con borderRad() se especifica la redondez de 1 a 3

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    ->border('top left right')
    ->borderWidth(5)
    ->borderColor('success')
	->borderRad(3);

Bordes como "píldora"

Con borderPill() se consigue la forma de píldora.

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    ->borderWidth(5)
    ->borderColor('warning')
	->borderRad(3)
	->borderPill();


Bordes circulares

Con bordeCircle() se consiguen borders circulares.

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    ->borderWidth(5)
    ->borderColor('warning')
	->borderRad(3)
	->borderCircle();


Redondear corners específicos

Con borderCorner() se pueden redondear solo determinados corners y en particular el efecto es visible cuando se aplica borderPill() o borderCircle()

Ej:

	echo tag('div')->width(100)->content('
      Some content,...
      <p>
      <p>
    ')
    //->border()
    ->borderWidth(5)
    ->borderRad(3)
    ->borderColor('warning')
    ->borderPill()
	->borderCorner('left top');

# Size

- Relative to the parent

Width

Valores posibles: cualquier entero de 0 a 100 y 'auto'

Ej:

	echo tag('div')->content(
      'Width 75%'
    )
    ->w(75)
    ->bg('warning')
    ->class('p-3');

Height

Valores posibles: cualquier entero de 25, 50, 75, 100 y 'auto'.

	echo tag('div')->content(
	'Height 75%'
	)
	->w(75)
	->h(75)
	->bg('warning')
	->class('d-inline-block');


- Relative to the viewport

You can also use utilities to set the width and height relative to the viewport.

	<div class="min-vw-100">Min-width 100vw</div>
	<div class="min-vh-100">Min-height 100vh</div>
	<div class="vw-100">Width 100vw</div>
	<div class="vh-100">Height 100vh</div>


# Text utilities

Para justificar texto (o como si texto se tratara) use:

	left()
	center()
	right()

Ej:

	echo tag('h4')
	->text('Indigo!')
	->bg('indigo')
	->center();

La justificación (centrado, a izquierda o a derecha) se puede aplicar con un breakpoint (solo cuando lo supere).

Ej:

	echo tag('h4')
	->text('Orange!')
	->bg('orange')
	->lgCenter();

Los breakpoints en BT5 son sm, md, lg y xl.

Nota: las clases bg- para colores como "indigo" u "orange" no están disponibles con Bootstrap pero si en templates como AdminLTE. 


# Tables

Las tablas se crean con tag('table') que recibe arrays de rows y cols.

NOTA: rows y cols está alrevés !!! tocaría intercambiar los nombres.

Ej:

	echo tag('table')
    ->rows([
      '#',
      'First',
      'Last',
      'Handle'
    ])
    ->cols([
      [
        1,
        'Mark',
        'Otto',
        '@mmd'
      ],
      [
        2,
        'Lara',
        'Cruz',
        '@fat'
      ],
      [
        3,
        Juan',
        'Cruz',
        '@fat'
      ],
      [
        4,
        'Feli',
        'Bozzolo',
        '@facebook'
      ]
    ]);

Colores

Se aplican colores con color()

Ej:

	echo tag('table')
    ->rows([
      '#',
      'First',
      'Last',
      'Handle'
    ])
    ->cols([
      [
        1,
        'Mark',
        'Otto',
        '@mmd'
      ],
      [
        2,
        'Lara',
        'Cruz',
        '@fat'
      ],
      [
        3,
        'Juan',
        'Cruz',
        '@fat'
      ],
      [
        4,
        'Feli',
        'Bozzolo',
        '@facebook'
      ]
    ])
    ->color('primary');


Aplicar color al head

Mediante headOptions() se puede pasar un array de atributos al head de la tabla.

	echo tag('table')
    ->rows([
      '#',
      'First',
      'Last',
      'Handle'
    ])
    ->cols([
      [
        1,
        'Mark',
        'Otto',
        '@mmd'
      ],
      [
        2,
        'Lara',
        'Cruz',
        '@fat'
      ],
      [
        3,
        'Juan',
        'Cruz',
        '@fat'
      ],
      [
        4,
        'Feli',
        'Bozzolo',
        '@facebook'
      ]
    ])
    ->color('light')
    ->headOptions([
      'color' => 'dark'
    ]);


Aplicar color a una columna 

Se implementó en principio para colorear una sola columna (que es el caso típico) para desctacarla aplicando colorCol($index, $color) 

 	->colorCol([
        'pos'   => 1, 
        'color' => 'primary'
      ])

Ej:

	echo tag('table')
      ->rows([
      '#',
      'First',
      'Last',
      'Handle'
      ])
      ->cols([
      [
          1,
          'Mark',
          'Otto',
          '@mmd'
      ],
      [
          2,
          'Lara',
          'Cruz',
          '@fat'
      ],
      [
          3,
          'Juan',
          'Cruz',
          '@fat'
      ],
      [
          4,
          'Feli',
          'Bozzolo',
          '@facebook'
      ]
      ])
      ->color('light')
      ->headOptions([
        'color' => 'dark'
      ])
      ->colorCol([
        'pos'   => 1, 
        'color' => 'primary'
      ]);


# Animations

Parecen faltar en BT5 pero están en "MDB Pro Essential package" 

Más
https://dev.to/mdbootstrap/bootstrap-5-animations-1kf0



~ Widgets

Basados en elementos de formulario se han construido varios Widgets. 


# Milestone / Timeline

El siguiente componente puede usare como milestone o timeline. 

Ej:
	
	echo tag("h_timeline")->content([
		[
		'title' => 2010,
		'subTitle' => 'algo remoto'
		],
		[
		'title' => 2011,
		'subTitle' => 'algo hermoso'
		],
		[
		'title' => 2016,
		'subTitle' => 'algo horrible'
		],        
	]); 


# Search tool

Este componente consciste en un inputSeach + icon

Ej:

	echo tag('searchTool')->id('my_search');


# Mask

Son overlays sobre imágenes con posibilidad de texto superpuesto.

Ej:

	echo tag('mask')->content(
		'<img src="'. asset('img/slide-1.jpeg') .'" class="w-100" alt="Louvre Museum">'
	);   

o

	echo tag('mask')
	->img([
		'src' => asset('img/slide-3.jpeg'), 
		'class' => "w-100",
		'alt' => "Louvre Museum"
	]);

Para superponer texo use text()

Ej:

	echo tag('mask')
	->img([
		'src' => asset('img/slide-3.jpeg'), 
		'class' => "w-100",
		'alt' => "Louvre Museum"
	])
	->text('Puedes verme?')->style('font-size:130%;');');


# Shadow

Con el tag shadow se obtienen sombras para contenedores.

	echo tag('shdow')
    ->content('Some content')
    ->class("p-3");

Hay varias clases para sombras en shadows.css del widget "shadow"

	echo tag('shadow')
	->content('Some content')
	->class("p-3 shadow-lg");


# Note

Con el tag note se pueden crear notas y opcionalmente especificar color con color()

Ej:

	echo tag('note')
	->text('<strong>!!! Note secondary:</strong> Lorem, ipsum dolor sit amet consectetur adipisicing
      elit. Cum doloremque officia laboriosam. Itaque ex obcaecati architecto! Qui
      necessitatibus delectus placeat illo rem id nisi consequatur esse, sint perspiciatis
      soluta porro?')
	->color('secondary');


# Steps

El tag step permite crear milestones minimalistas para formularios en varios pasos.

Ej:

	echo tag('steps')->max(4)->current(3);


Otro componente es wizard_steps

Ej:
	echo tag('wizard_steps')
	->content([
		[
		'href'        => "#s1",
		'title'       => 'Step 1',
		'description' => 'Step 1 description'
		],
		[
		'href'        => "#s2",
		'title'       => 'Step 2',
		'description' => 'Step 2 description'
		],
		[
		'href'        => "#s3",
		'title'       => 'Step 3',
		'description' => 'Step 3 description'
		],       
	])
	->current(2);

También pueden setearse solo algunos campos.

Ej:

	echo tag('wizard_steps')
	->content([
		[
		'href'        => "#s1"
		],
		[
		'href'        => "#s2"
		],
		[
		'href'        => "#s3"
		],    
		[
		'href'        => "#s4",
		],    
	])
	->current(3);

O incluso solo pasar la cantidad de pasos y el paso actual.

Ej:

	echo tag('wizard_steps')
	->max(5)
	->current(3);

Con vertical() debería verse vertical pero parece que faltó importar CSS.
	

----- 
-----
-----


ADMIN LTE

Con este tema es necesario re-implementar algunos componentes y otros como el accordion no funcionan bien pero en tal caso simplemente no incluir los estilos si son componentes del frontoffice (home).

# Alert

Los alerts para Admin LTE aceptan de forma opcional un "title".

Ej:

	echo tag('alert')
	->content('OK')
	->title('Perfecto!')
	->success()
	->dismissible(true);

	echo tag('alert')
	->content('Algo para tener en cuenta.')
	->title('Cuidado!')
	->warning()
	->dismissible(true);

	echo tag('alert')
	->content('Algo salió mal.')
	->title('Error!')
	->danger()
	->dismissible(true);

	// Sin título
	echo tag('alert')
	->content('Algo salió mal.')
	->danger()
	->dismissible(true);

	echo AdminLte::alert(content: 'Some content', attributes: ['warning', 'dismissible']);


# Callout

Son el equivalente "light" de las cards. Color y title son opcionales.

Ej:

	echo tag('callout')->color('danger')
	->content('There is a problem that we need to fix. A wonderful serenity has taken possession of my entire
	soul, like these sweet mornings of spring which I enjoy with my whole heart.');

O con title.

Ej:

	echo tag('callout')->color('danger')
	->content('There is a problem that we need to fix. A wonderful serenity has taken possession of my entire
	soul, like these sweet mornings of spring which I enjoy with my whole heart.')
	->title('Some title');


# Ion Sliders

Estos sliders utilizan un plugin y básicamente se diferencian de un inputRange en que tienen un máximo, un mínimo y dentro de este rango el usuario puede elegir el suyo.

Hay de dos tipos: "single" y "double". Por defecto son "single" siendo similares a un inputRange o sea sin sub-rango.

Ej:

	<div class="col-sm-6">
		<?= tag('ionSlider')->id('range_1') ?>
	</div>

El código JavaScript mínimo es:

	$('#range_1').ionRangeSlider({
    })

Sino se especificara mínimo o máximo, los valores por defecto son 10 y 100. Se pueden especificar más paramátros.

Ej:

	$('#range_1').ionRangeSlider({
		min     : 0,
		max     : 10,
		type    : 'single',
		step    : 0.1,
		postfix : ' mm',
		prettify: false,
		hasGrid : true
	})

Para el caso de los tipo "double" se pasa también un "from" y "to".

Ej:

	$('#range_1').ionRangeSlider({
		min     : 0,
		max     : 5000,
		from    : 1000,
		to      : 4000,
		type    : 'double',
		step    : 1,
		prefix  : '$',
		prettify: false,
		hasGrid : true
	})

Es posible fijar el valor de inicio ("from") con el "value" en el ionSlider (ya que hereda de un inputText) cuando es de tipo "single". Para los tipo "double" y en general sería con el "from".

Ej:

	<!--
		Solo tiene sentido si es de tipo "single". Sino usar from.
	-->
	<div class="col-sm-6">
		<?= tag('ionSlider')->id('range_1')->value(1400) ?>
	</div>


Con el código JavaScript mínimo es posible inicializar todo desde el Builder en el backend.

Ej:

	<?=
		/*
			Slider "simple"
		*/

		tag('ionSlider')->id('range_1')
          ->min(0)
          ->max(6000)
          ->value(50) 
          ->postfix(" &euro;")
          ->step(10)
	?>

Recordemos que value() y from() para el caso de los sliders "simples" son equivalentes:

	<?=
		/*
			Slider "simple"
		*/

		tag('ionSlider')->id('range_1')
          ->min(0)
          ->max(6000)
          ->from(50) 
          ->postfix(" &euro;")
          ->step(10)
	?>

Para el caso de los sliders "dobles", especificaremos un sub-rango inicial con from y to.

Ej:

	<?= 
		/*
			Slider "doble"
		*/
          
		tag('ionSlider')->id('range_2')
		->min(-100)
		->max(400)          
		->postfix(" C")
		->step(1)

		->type('double')
		->from(100)
		->to(200)
		
    ?>

Se implementó de forma muy primitiva la inclusión del código JS mínimo de inicialización del componente.

Recordar que debe incluirse el JS del plugin:

	<?php
    	include_js(ASSETS_PATH . 'adminlte/plugins/ion-rangeslider/js/ion.rangeSlider.min.js');
    ?>


# Ribbons

Admin LTE ofrece "cintas" o ribbons que se pueden aplicar a un contenedor.

Código base:

	<div class="position-relative bg-gray"> 
	<!-- body -->
	<div class="ribbon-wrapper">
		<div class="ribbon bg-primary">
		Ribbon
		</div>
	</div>
	
	<!-- footer -->
	Ribbon Default <br />
	<small>.ribbon-wrapper.ribbon-lg .ribbon</small>
	</div>


Se pueden agrandar: ribbon-lg, ribbon-xl

  <div class="ribbon-wrapper ribbon-lg">
    <div class="ribbon bg-info">
      Ribbon Large
    </div>
  </div>

El texto del ribbon también se puede agrandar: text-lg, text-xl

	<div class="ribbon-wrapper ribbon-lg">
	<div class="ribbon bg-success text-lg">
		Ribbon
	</div>
	</div>

Sobre imágenes

	<div class="position-relative">
	<!-- header -->
	<img src="../../dist/img/photo1.png" alt="Photo 1" class="img-fluid">
	
	<!-- body -->
	<div class="ribbon-wrapper ribbon-lg">
		<div class="ribbon bg-success text-lg">
		Ribbon
		</div>
	</div>
	</div>


Implementando ribbons con el builder

De mínima se necesita un texto para la cinta (title) y un contenido (body).

Como punto de partida:

	<?=

		tag('ribbon')
		->bg('gray')
		->style('height: 100px')
		->title(
		tag('ribbonTitle')->content('Ribbon')->bg('primary')
		)
		->body(
		'Ribbon Default <br />
		<small>.ribbon-wrapper.ribbon-lg .ribbon</small>'
		)

	?>

O con imágenes

En este caso la imágen va en el *header* habiendo header, title y body.

Ej:
	
	<?=

		tag('ribbon')
		->bg('gray')
		//->style('min-height: 300px')
		->class('mt-3')  
		->header(
			tag('img')->src(asset('img/photo2.png'))->class('img-fluid py-3')
		)                  
		->title(
			tag('ribbonTitle')->content('Ribbon')->bg('danger')
		)
		->body(
			'Ribbon Default <br />
			<small>.ribbon-wrapper.ribbon-lg .ribbon</small>'
		)

	?>

Para alargar la cinta o ensancharla conjuntamente con el tamaño del texto use size() y textSize() respectivamente con 'lg' o 'xl' sobre el ribbonTitle.

Ej:

	<?=

		tag('ribbon')
		->bg('gray')
		->style('min-height: 300px')
		->class('mt-3')  
		->header(
			tag('img')->src(asset('img/photo2.png'))->class('img-fluid py-3')
		)                  
		->title(
			tag('ribbonTitle')->content('Ribbon')->bg('danger')->size('xl')->textSize('xl')
		)
		->body(
			'Ribbon Default <br />
			<small>.ribbon-wrapper.ribbon-lg .ribbon</small>'
		)

	?>


# Custom File

Ej:

	<div class="form-group">
		<?php
		echo tag('customFile')
		->id('my_file')
		->placeholder('Elija los archivos');
		?>
	</div>

Desconozco porque *no* está funcionando aún habiendo incluido en el "footer" el plugin.

    include_js(ASSETS_PATH . 'adminlte/plugins/bs-custom-file-input/bs-custom-file-input.min.js'

Más
https://github.com/Johann-S/bs-custom-file-input


# Input validation

Con Admin LTE las clases para marcar un inputText como valid, invalid o con un warning son is_valid, is_invalid e is_warning respectivamente.

	<?= tag('inputText')->class("is-valid")->placeholder("Enter ...")->id("id1");   ?>

	<?= tag('inputText')->class("is-warning")->placeholder("Enter ...")->id("id2"); ?>

	<?= tag('inputText')->class("is-invalid")->placeholder("Enter ...")->id("id3"); ?>


# Select2

Select2 actua sobre un select normal y solo requiere incluir CSS y JS e inicializar el componente:

	<link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
	<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>	

Ej:

	 echo tag('select')
	->id('sexo')
	->options([
		'varon' => 1,
		'mujer' => 2
	])
	->default(1)
	->placeholder('Su sexo')
	->class('my-3');


inicialización (requerida) del componente:

	$(function () {
      $( '#sexo' ).select2( {
          theme: 'bootstrap-5'
      } );
    })

También funciona con select con "option groups".

Ej:

	echo tag('select')
	->id('comidas')
	->placeholder('Tu comida favorita')
	->options([
		'platos' => [
			'Pasta' => 'pasta',
			'Pizza' => 'pizza',
			'Asado' => 'asado'
		],

		'frutas' => [
			'Banana' => 'banana',
			'Frutilla' => 'frutilla'
		]
	])
	//->multiple()   
	->class('my-3');


En cualquier caso si se habilita el modo "múltiple" entonces las opciones seleccionadas se mostrarán como "tags" y podrán entonces removerse también fácilmente.

La forma fácil

En vez de usar tag("select"), use tag("select2") que ya incorpora la clase '.select2' con lo cual se pueden inicializar todos los select2 de forma sencilla así:

Ej:

	echo tag('select2')
	->id('comidas_duallistbox')
	->placeholder('Tu comida favorita')
	->options([
		'Pasta' => 'pasta',
		'Pizza' => 'pizza',
		'Asado' => 'asado',
		'Banana' => 'banana',
		'Frutilla' => 'frutilla'
	])
	->multiple()   
	->class('my-3');


	$(function () {
      $( '.select2' ).select2( {
          theme: 'bootstrap-5'
      } );
    })


PD: Es posible elegir el color de los tags aunque no se implementó esta funcionalidad.

Más
https://select2.github.io/



# Bootsrap Duallistbox

Plugin que debe instalarse e inicializarse:

	<script src="dist/jquery.bootstrap-duallistbox.min.js"></script>
	<link rel="stylesheet" type="text/css" href="../src/bootstrap-duallistbox.css">

Requiere también de JQuery y PopperJs.

inicialización:

	//Bootstrap Duallistbox
	$("#element").bootstrapDualListbox({
		// see next for specifications
	});

O sin parámetros y aplicándolo a cualquier en general via clase '.duallistbox'

	//Bootstrap Duallistbox
    $('.duallistbox').bootstrapDualListbox()

Pero es altamente configurable.

Ej:

	var demo1 = $('select[name="duallistbox_demo1[]"]').bootstrapDualListbox({
      nonSelectedListLabel: 'Available Payees',
      selectedListLabel: 'Selected Payees',
      preserveSelectionOnMove: 'moved',
      moveAllLabel: 'Move all',
      removeAllLabel: 'Remove all'
    });

En si el ÚNICO requisito del componente es que sea un select *múltiple*

Ej:

	<?php

	echo tag('select')
      ->id('comidas_duallistbox')
      ->placeholder('Tu comida favorita')
      ->options([
          'Pasta' => 'pasta',
          'Pizza' => 'pizza',
          'Asado' => 'asado',
          'Banana' => 'banana',
          'Frutilla' => 'frutilla'
      ])
      ->multiple()   
      ->class('my-3');

	?>

	<script>    
    	$('#comidas_duallistbox').bootstrapDualListbox()
  	</script>

La forma fácil

En vez de usar select use el componente duallistbox que ya incorpora la clase .duallistbox

Ej:

	echo tag('duallistbox')
	->id('comidas_duallistbox')
	->placeholder('Tu comida favorita')
	->options([
		'Pasta' => 'pasta',
		'Pizza' => 'pizza',
		'Asado' => 'asado',
		'Banana' => 'banana',
		'Frutilla' => 'frutilla'
	])
	->multiple()   
	->class('my-3');

Entonces puede inicializar todos los duallistbox de una vez así:

	$('.duallistbox').bootstrapDualListbox()

Más
https://github.com/istvan-ujjmeszaros/bootstrap-duallistbox


# Input mask

Requiere instalar el plugin:

	<!-- InputMask -->
    <script src="<?= asset('adminlte/plugins/moment/moment.min.js') ?>"></script>
    <script src="<?= asset('adminlte/plugins/inputmask/jquery.inputmask.min.js') ?>"></script>

Fecha 

Por defecto es 'dd/mm/yyyy'

	<?php
		echo tag('inputMask')->id('mydate');
	?>

O especificando el formato:

	<?php
		echo tag('inputMask')->id('mydate')->format('mm/dd/yyyy');
	?>

Telefono

	<?php
		echo tag('phoneMask')->id('myphone')->format('(01) 999-9999');
	?>

Hay otras máscaras como para IP.


# Date picker

Presenta interferencia con el js de jQuery UI por lo cual *no* pueden usarse simultaneamente.

Requisitos:

	<!-- datepicker -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-datepicker/1.9.0/css/bootstrap-datepicker.min.css" />
	<script src="http://simplerest.lan:8082/public/assets/js/plugins/bootstrap-datepicker/bootstrap-datepicker.min.js"></script>

Ej:

	<div class="input-group date" id="reservationdatetime">
		<input type="text" class="form-control" id="date"/>
		<span class="input-group-append">
		<span class="input-group-text bg-light d-block">
			<i class="fa fa-calendar"></i>
		</span>
		</span>
	</div>

Y debe inicializarse:

	<script>
		$('#reservationdatetime').datepicker();
	</script>

Con el builder podría hacerse algo así:

 	echo tag('inputGroup')
	->content(
		tag('inputText')
	)
	->append(
		tag('button')->info()->icon('calendar')
	)->class('mb-3 date')->id("reservationdatetime");


En este caso es posible personalizar el color del botón aplicando info(), warning(), etc.

También es posible cambiar de lugar el botón con el ícono de calendario cambiando append() por prepend().

	echo tag('inputGroup')
	->content(
		tag('inputText')
	)
	->prepend(
		tag('button')->info()->icon('calendar')
	)->class('mb-3 date')->id("reservationdatetime");



Notas Dev:
=========

# CORREGIR severo problema de RENDIMIENTO relacionado con include_css()

Ej:

	static function ionSlider(mixed $default = null, Array $attributes = [], ...$args){
		include_css(ASSETS_PATH . 'adminlte/plugins/ion-rangeslider/css/ion.rangeSlider.min.css');
		
		// ...

Incluir el CSS acá genera dos problemas muy graves:

		1) No puede ser cacheado y 

		2) Queda repetido tantas veces como se incluya el componente! 

		La solución para "producción" sería "compilar" el las vistas con lo cual los archivos css 
		de cada componente serían incluídos una sola vez para la vista correspondiente.

		En si,... include_css() debería "encolar" los archivos css para la vista corespondiente.


# Debería existir un mecanismo para "encolar" JS a eventos como "on document ready".

Ej:

	enqueue_ready("        
		$('#$id').ionRangeSlider({})
	");

Esto debería agregarlo aquí:

	<!-- 
		Antes de </body>
	-->

	<script>
		$(function () {     
			// ...

			$('#range_2').ionRangeSlider({})
		})
	</script>


# Compatibilidad con "react-boostrap"

Dado que la librería es parte del proyecto "Supra", se hará compatible con la API de react-boostrap. Esto incluirá la auto-importación de los componentes necesarios.

https://react-bootstrap.github.io/components/


# Escribiendo nuevos componentes

Todo componente debe en última instancia depender del método Form::tag() 

Ej:

	static function alert(string $content, bool $dismissible = false, Array $attributes = [], ...$args){
       	// ..
        return static::div($content, $attributes, ...$args);
    }

En este caso div() depende (prácticamente "hereda") de group() que a su vez lo hace de tag()

Aplicando colores

Hay dos estrategias para aplicar colores aunque una es muy directa y la otra no y por ello deben de performar muy distinto.

	// Proceso colores por si se envian usando color($color)
			
	$color = $attributes['color'] ?? $args['color'] ?? null;

	if ($color !== null){
		if (!in_array($color, static::$colors)){
			throw new \InvalidArgumentException("Invalid color for '$color'");
		}

		static::addClass(" alert-$color", $attributes['class']);
		unset($args['color']);
	}

	$kargs = array_merge(array_keys($args), array_keys($attributes));

	// Proceso colores provinientes en cualquier key => mucho más ineficiente

	foreach ($kargs as $k){
		if (in_array($k, static::$colors)){
			static::addClass(" alert-$k", $attributes['class']); 
			break;
		}           
	}


La primera estrategia permite usar un color medianre color($color) y la segunda (mucho más ineficiente) como $color()

	color('success);
vs
	success()




Al traducir a JavaScript usar los siguientes "ports" de métodos mágicos como __call, __get, __set, etc

https://gist.github.com/loilo/4d385d64e2b8552dcc12a0f5126b6df8
https://gist.github.com/adinan-cenci/ed4f23eb719e4c2820aedc5feb91032b
