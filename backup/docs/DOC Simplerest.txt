DOCUMENTACION 
-------------

SimpleRest utiliza la arquitectura MVC, está orientado a API Restful y es un framework para desarrollo rápido de aplicaciones (RAD).

Algunas características:

- Arquitectura MVC 
- APIs funcionan out--of-the-box o sea sin escribir nada de código ***
- Autenticación via web tokens al estilo OAuth 2 y API Keys
- ACL centralizado con sistema de roles y de permisos granulares + permisos personalizados que decoran los roles
- Posibilidad de "compartir" recursos via "folders"
- Impersonate
- Papelera de reciclaje
- Colecciones para acciones masivas
- Versionado
- Internacionalización
- Query Builder
- UUIDs
- Migrations (en progreso)
- Multitenant support
- Service Providers
- Validator y auto-validaciones en los modelos
- WebHooks
- Sub-recursos
- Utilidad para consumo de APIs
- Perfilador del código (tiempos de ejecución)

Cómo "índice" para buscar documentación puede buscar por las características enumeradas previamente más las siguientes referencias:

- Requerimientos
- Instalación
- Variables de entorno
- Componentes del core
- La clase DB
- Procedimientos almacenados
- El helper db


(*) A pesar de ser un framework orientado a API Rest es posible servir vistas aunque no posee un motor de plantillas. Es posible que esta característica sea removida en futuras versiones.

# Estructura del proyecto

```
├── app                           # Main MVC file structure directory
│   ├── controllers               # Controllers directory 
|   |   └── api                   # API controllers  
│   ├── models                    # Models directory
│   ├── views                     # Views directory
│   ├── libs                      
|   ├── helpers                   # helpers
│   ├── locale                    # i18n translations
│   └── core                      # Core directory
|
├── core                          # Basically mvc engine directory
│   ├── api
|   |   ├── v1
|   |   ├── v2
|   |   └── vN
│   ├── exceptions
│   ├── interfaces                          
│   └── config                    # Configuration directory
│		├── acl.php 
│       ├── config.php          
│       └── constants.php           
│         
├── public
|   ├── assets                     
│   |   ├── css               
│   |   ├── img    
|   |   └── js
|   ├── .htaccess      
|   ├──  index.php
|   └──  favicon.ico
|
├─── vendor                    
└── .htaccess                     
```

# Requerimientos 

	PHP 7.4+
	MySQL / MariaDB - SqlLite - PostgreSql (*)
	Apache Web Server 2.4

Es posible hacer funcionar el framework con Nginx y en cuanto a PostgreSql está parcialmente soportado porque no se dispone actualmente de migraciones para este motor de base de datos.


# Instalación

Hay varios archivos por configurar y hay que correr un script de instalación.

Vea archivo adjunto sobre Instalación para más información.


### Archivo config.php

Hay varios archivos de configuración del framework en /config del cual el config.php es el principal.

El config.php es cargado via constructor en controladors y modelos siempre y cuando se extienda dicho constructor y está disponible como $this->config

Además, se puede cargar la configuración de varias formas:

	- Con el helper config()

	- Desde la clase Factory como config()

Incluir el archivo config.php directamente no es recomendado.

Ud. puede cambiar un valor de configuración con Config::set() aunque tenga en cuenta que muchas librerías y componentes del framework pueden estar guardándose una copia de la configuración e inclusive la clase DB lo hace con lo cual lo siguiente *no* funcionará:

	Config::set('db_connection_default') = 'db_xyz';
	DB::getDefaultConnection(); // sin cambio


# Configuración de "tenant groups"

Si se tienen varias bases de datos se deben configurar los "tentant_groups" en el archivo config.php

La implementación de "tenant groups" permite en principio separar schemas y modelos de distintas bases de datos y agrupar los que se se supone son de bases de datos con igual estructura.

Ej:

	'tentant_groups' => [
		'legion' => [
		  'db_[0-9]+',
		  'db_legion',
		  'db_flor'
		],
		'az' => [
		  'az'
		],
	],

Es recomendado definir grupos de multitenencia aunque se tenga bases de datos que no constituyan "clusters" para que los schemas queden organizados en carpetas distintas dentro de app/models/schemas y no se mezclen.

Además, si llegaran a existir dos tablas en dos bases de datos distintas con el mismo nombre no habrá problemas.

Se pueden definir varios patrones de nombres para un mismo grupo que en si son expresiones regulares de PHP. El órden en que se definan puede alterar el resultado de la clasificación de haber superposición de patrones.

Ej:

Lo siguiente define dos grupos

	'tentant_groups' => [
		'db_az' => [
			'db_az'
		],
		'legion' => [
			'db_[a-z0-9]+',
			'db_legion',
			'db_flor'
		]		
	],

Pero... lo siguiente define dos pero clasificará todo en el primero pues la primera expresión regular contiene a "db_az"  

	'tentant_groups' => [
		'legion' => [
			'db_[a-z0-9]+',
			'db_legion',
			'db_flor'
		],
		'db_az' => [
			'db_az'
		],
	],


# Variables de entorno

Se ofrece la clase Env con la finalidad de poder acceder a variables de entorno (del archivo .env) como alternativa al paquete Dotenv

Ej:

	// Usando Env::get()

	$dbname = Env::get('DB_NAME);
    $user   = Env::get('DB_USERNAME');
    $pass   = Env::get('DB_PASSWORD');
    $dsn    = "mysql:dbname=$dbname;host=127.0.0.1";

	// Crear la conexión manualmente 
	
    try {
        $conn = new \PDO($dsn, $user, $pass);
    } catch (PDOException $e) {
        throw new \Exception('DB connection fails: ' . $e->getMessage());
    }


# Configuración de endpoints

Endpoints pueden o no comienzar con /api

Las urls comienzan *sin* /api si en /config/config.php 

	'REMOVE_API_SLUG' => true

<-- remover el /api puede dar lugar a colisiones con controladores. Inclusive no funcionarán los resource controllers. 

OJO ! afecta al DownloadController


# El comando "make"

Este comando sirve para crear cualquier archivo importante para el framework ya sea helpers, librerías, modelos, esquemas, controladores, controladores para uso en la consola, serivice providers, migraciones, etc.

El uso básico del comando make puede aprenderse simplemente ejecutando:

	php com make

Crear nuevos comandos es bastante sencillo y la clase Make se puede extender. Observe la estrucura básica:

Ej:

	function controller($name, ...$opt) {
        $namespace = 'simplerest\\controllers';
        $dest_path = CONTROLLERS_PATH;
        $template_path = self::CONTROLLER_TEMPLATE;
        $subfix = 'Controller';  // Ej: 'Controller' o incluso '' (caso helpers)

        $this->generic($name, $subfix, $namespace, $dest_path, $template_path, ...$opt);
    }


# Creación de usuarios

	POST /api/v1/auth/register	

	{
		"username": "super_ventas",
		"email": "b2@mail.com",
		"password": "gogogo"
	}		

<-- campos mínimos

Y se devuelve un JSON como este:

{
    "data": {
        "access_token": "eyJInR5cC....4Vhvo",
        "token_type": "bearer",
        "expires_in": 900,
        "refresh_token": "eyJ0e...EKhNjuc",
        "roles": [
            []
        ],
        "uid": "351",
        "email_confirmation_link": "http://localhost/incu_users/auth/confirm_email/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTU5NzUxNDA1NSwiZXhwIjoxNTk4MTE4ODU1LCJpcCI6Ijo6MSIsImVtYWlsIjoiYWFhQG1haWwuY29tIn0.J2pUPHmmIwpXtlTpgDqu23jb-h0HlAz9ife-4HVfa1c/1598118855"
    },
    "error": "",
    "error_detail": ""
}

Es posible solicitar un rol (comprador o vendedor por ejemplo) al momento del registro. Es requisito tener definidos los roles como pre-aprobados en config/config.php

Ej:
	'auto_approval_roles' => ['vendedor'],

Entonces al momento de hacer el registro se puede especificar el o los roles que se desean obtener:

{
		"username": "super_ventas",
		"email": "b2@mail.com",
		"password": "gogogo",
        "roles": ["vendedor"]
}


# Login 

	POST /api/v1/auth/login

	{
		"email": "usuario@mail.com",
		"password": "xxxx"
	}

Se devuelve un JSON como el siguiente:

{
    "data": {
        "access_token": "eyJ0eXAiOiJ.....QwjPRA",
        "token_type": "bearer",
        "expires_in": 900,
        "refresh_token": "eyJ0e....SUxd_dpg-Js",
        "roles": [
            "contabilidad",
            "mercadotecnia"
        ],
        "uid": 350
    },
    "error": "",
    "error_detail": ""
}


# Verficación de correo

Es solo seguir el enlace provisto al momento de registrarse o .........


# Recordar contraseña

	POST /api/v1/auth/rememberme

	{
		"email": "usuario@mail.com"
	}

=> devuelve un JSON con el enlace (request por GET) para cambiar la contraseña 	

Ej:

	{
		"data": {
			"link_sent": "http://localhost/incu_users/auth/change_pass_by_link/eyJ0eX...I15SY/1598117791"
		},
		"error": "",
		"error_detail": ""
	}

Al seguir el enlace se devuelve un nuevo JSON con el access token necesario para poder realizar el cambio de contraseña. Redireccionar a la vista correspondiente es un asunto aparte.

{
    "data": {
        "access_token": "eyJ0eXAi.....4fAs",
        "token_type": "bearer",
        "expires_in": 900,
        "uid": "350",
        "roles": [
            "contabilidad",
            "mercadotecnia"
        ],
        "permissions": []
    },
    "error": "",
    "error_detail": ""
}

Finalmente para cambiar efectivamente la contraseña se hace uso del siguiente endpoint enviando las credenciales correspondientes (access token)

	POST /api/v1/auth/change_pass_process

	{
		"password": "xxxxx"
	}


# Renovación de tokens

	POST /api/v1/auth/token

<-- enviando el refres_token en headers y sin body

Se devolverá un nuevo acccess token en un JSON como este:

{
    "data": {
        "access_token": "eyJ0e.....8eXKY",
        "token_type": "bearer",
        "expires_in": 900,
        "roles": [
        ],
        "uid": "352"
    },
    "error": "",
    "error_detail": ""
}

# Impersonate

Es posible asumir la identidad de otro usuario o bien un rol en particular -solo uno a la vez-. 

Esta característica solo está disponible con autenticación via Web Tokens y no otras como API KEY ***

POST /api/v1/auth/impersonate que recibe un *refresh_token* de un admin (usuario con permiso 'impersonate') y en el body:

	{ 
		"uid" : "90"  
	}

Lo cual genera el par access y refresh token como Admin donde dentro un campo "impersonated_by" con el id del admin, ej:

{
    "data": {
        "access_token": "eyJ0...",
        "refresh_token": "eyJ0....",
        "token_type": "bearer",
        "expires_in": 90000000,
        "roles": [
            "regular"
        ],
        "uid": "90",
        "impersonated_by": 4  <-- id del Admin
    },
    "error": "",
    "error_detail": ""
}

O bien con un rol que inclusive puede ser "guest"

	POST /api/v1/auth/impersonate que recibe un refresh_token de un Admin y en el body:

	{ 
		"role": "basic"	
	}

La ventaja de hacer la impersonalización por roles es que no es necesario tener varias cuentas con diferentes roles para hacer pruebas y tampoco es necesario des-loguearse para simular ser un "guest".

Al hacer un impersonate debe elegirse si se hace por uid o por rol. No tiene mucho sentido enviar un rol y un uid en el mismo request y el resultado puede no ser el esperado.

Para parar la "impersonalización",...

POST /api/v1/auth/stopImpersonate con el access_token del admin que está haciendo uso de impersonate lo cual debe devolver un nuevo token sin impersonate, ej:

{
    "data": {
        "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTU5OTY5MjYwMCwiZXhwIjoxNjg5NjkyNjAwLCJpcCI6IjEyNy4wLjAuMSIsInVpZCI6NCwicm9sZXMiOlsiYWRtaW4iXSwiY29uZmlybWVkX2VtYWlsIjoxLCJwZXJtaXNzaW9ucyI6W119.5k272dPgzKFZVEYPC9NgKbrsf9qu1EdUe01CTagYrjE",
        "token_type": "bearer",
        "expires_in": 90000000,
        "refresh_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTU5OTY5MjYwMCwiZXhwIjoxOTE1MDUyNjAwLCJpcCI6IjEyNy4wLjAuMSIsInVpZCI6NCwicm9sZXMiOlsiYWRtaW4iXSwiY29uZmlybWVkX2VtYWlsIjoxLCJwZXJtaXNzaW9ucyI6W119.k8SNRcSD4j3JtFlV8Qj3lfVqOiP_2hVYI4bCM0rhWWg",
        "roles": [
            "admin"
        ],
        "uid": 4
    },
    "error": "",
    "error_detail": ""
}

Tanto created_by, updated_by y deleted_by reflejan referencian al Admin pero belongs_to al momento de crear un registro es con el usuario con por el que se hace la sustitución.

El token se puede seguir renovando normalmente pero con ciertas limitaciones: al renovar el token de un impersonate hecho "por rol", el rol se pierde volviendo al rol de admin. Esto ocurre porque los roles no viajan en el payload del refres_token que solo se utiliza para autenticación -y no autorización-.

S puede hacer el impersonate al rol de "guest" y en este caso particular se puede seguir renovando el token conservando dicho rol indefinidamente (hasta vencimiento el refres_token)

POST /api/v1/auth/impersonate que recibe un refresh_token de un Admin y en el body:

{ 
	"role" : "guest"	
}

Obteniendo algo como

{
    "data": {
        "access_token": "eyJ0eXAiOiJ..",
        "refresh_token": "eyJ0eXAi...",
        "token_type": "bearer",
        "expires_in": 90000000,
        "roles": [
            "guest"  
        ],
        "uid": -1,
        "impersonated_by": 4
    },
    "error": "",
    "error_detail": ""
}

<-- observar que el único rol es "guest", el uid es -1 y nuevamente queda habilitada la impersonalización.

Nota: se puede hacer un impersonate con el refresh_token de otro Impersonate.


# Confirmación de correo

Al momento de registrarse exitosamente en el JSON de la respuesta se incluye

	"email_confirmation_link": "http://az.lan/api/v1/auth/confirm_email/eyJ0eXA...KDFsI/1600830742"

Y siguiendo ese enlace el correo de la cuenta queda verificado devolviendo:

{
    "data": {
        "msg": "Email confirmed - thanks!"
    },
    "status_code": 200,
    "error": "",
    "error_detail": ""
}

<-- es posible devolver tokens pero serían inseguro -aunque el recuérdame genera tokens-. 

Luego de confirmar el correo es responsabilidad del usuario volverse a loguear. 


# Recuérdame

POST /api/v1/auth/rememberme con el body

	{
		"email": "algun_usuario@mail.com"
	}

Debe generar un enlace para cambiar el enlace por GET y en "modo desarrollador" produciría una respuesta como esta: 

	{
		"data": {
			"link_sent": "http://az.lan/api/v1/auth/change_pass_by_link/eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImlhdCI6MTYwMDIyNjQxMCwiZXhwIjoxNjAwODMxMjEwLCJpcCI6IjEyNy4wLjAuMSIsInJvbGVzIjpbInJlZ3VsYXIiXSwicGVybWlzc2lvbnMiOnsicHJvZHVjdHMiOjcsImZvbyI6N30sInVpZCI6IjE2OCIsImFjdGl2ZSI6IjEifQ.Z2HsyPGfGflCG1vOq5hwKqd50QOEgLZO5flixz4hMTU/1600831210"
		},
		"status_code": 200,
		"error": "",
		"error_detail": ""
	}

<-- en producción no tiene chiste que se lea el enlace a seguir !	

# Versionado

Se especifica la versión en la url y esto tiene como efecto cargar una versión distinta de la clase ApiController en /app/core/api

	GET /api/v1/products
	GET /api/v2/products
	GET /api/v3/products

En el primer por ejemplo caso carga la clase /app/core/api/v1/ApiController

La clase MyApiController en /app/controllers es la responsable de seleccionar la versión solicitada de la API.

Cuando sea necesario crear una nueva versión de la API, deberá agregarse al MyApiController algo como:

	if ($api_version == 'v2'){
		class MyApiController extends \simplerest\core\api\v2\ApiController {}
		return;
	}

Debe hacerse lo mismo en MyAuthController.php 

	if ($api_version == 'v2'){
    	class AuthController extends \simplerest\core\api\v1\AuthController {}
    	return;
	}

Esto posibilita hacer uso de hooks en la clase extendida. 

Las urls comienzan *sin* /api si en /config/config.php 

	'REMOVE_API_SLUG' => true


### La clase Config

Para usar la utilería Config debe hacerse a través de Factory para acceder a la misma instancia:

# Obtener instancia única:

	config()


# Introducir y leer datos (de forma no-persistente)

Se puede escribir mediante el método set() y leer con get() o bien acceder como array ya que se implementa la interfaz ArrayAccess:

	config()['xxx'] = 'zzz';
    dd(config()['xxx']);  // 'zzz'

o
	
	config()->set('xxx','zzz');
	dd(config()->get('xxx'));  // 'zzz' 

o

	config()->set('xxx','zzz');
	dd(config()['xxx']);  // 'zzz'   


### Autenticación

El framework soporta dos tipos de autenticación, una basada en web tokens y otra en API Keys para backend-to-backend 

Para API KEYs, se deben generar las apis para los usuarios (una por usuario) e insertarlas en la tabla api_keys.

Hay dos formas de pasar la API KEY

1) Via url agregando el parámetro api_key

Ej:

	GET /api/v1/some_resource?api_key=8ZfTPJB3VeCAAkea HTTP/1.1

2) Via header X-API-KEY 

	GET /api/v1/some_resource HTTP/1.1
	X-API-KEY: 8ZfTPJB3VeCAAkea

Más
https://swagger.io/docs/specification/authentication/api-keys/


### Controlador

Los controladores son clases cuyos métodos ejecutan acciones al ser invocados desde el FrontController o el Router.

Para demostrar como ejecutar un controlador desde la linea de comandos ejemplificaremos con un simple controlador ubicado en la carpeta controllers:

	<?php

	namespace simplerest\controllers;

	class DumbController extends Controller
	{

		function add($a, $b){
			$res = (int) $a + (int) $b;
			return  "$a + $b = " . $res;
		}

	}

La acción será ejecutada con: 

	php com dumb add 1 6

Hay soporte para sub-directorios o sub-sub-(sub)-directorios 


# Front Controller y Router 

Es posible configurar el uso del Front Controller y/o del Router. El primero es más sencillo pero se aconseja casi exclusivamente para utilizar los controllers desde la terminal. 

El Router tiene la enorme ventaja de permitir filtrar los requests por su verbo HTTP:

	# ruta: /calc/sum/4/5
	Route::get('calc/sum', function($a, $b){
		return "La suma de $a y $b da ". ($a + $b);
	})->where(['a' => '[0-9]+', 'b' =>'[0-9]+']);

	# ruta: /saludador/sp/hi/Juan/Carlos/44
	Route::get('saludador/sp/hi/', function($nombre, $apellido, $edad){
		return "Hola ". ($edad > 30 ? 'Sr. ' : '') . "$nombre $apellido";
	})->where(['edad' => '[0-9]+', 'nombre' =>'[a-zA-Z]+', 'apellido' =>'[a-zA-Z]+']);

	# ruta: /saludador/en/hi/Juan/Carlos/44
	Route::get('saludador/en/hi/', function($nombre, $apellido, $edad){
		return "Hello ". ($edad > 30 ? 'Mr. ' : '') . "$apellido $nombre";
	})->where(['edad' => '[0-9]+', 'nombre' =>'[a-zA-Z]+', 'apellido' =>'[a-zA-Z]+']);

	# ruta: /tonterias
	Route::get('tonterias',  'DumbController');

	# ruta: /chatbot/hi
	Route::get('chatbot/hi', 'DumbController@hi')
	->where(['name' => '[a-zA-Z]+']);  // <-- where() no implementado con controladores !

	# ruta: /cosas/67
	Route::delete('cosas', function($id){
		return "Deleting cosa con id = $id";
	});


El router se habilitan desde el archivo config/config.php y se configura desde /config/routes.php


### Resource Controller:

Un ResourceController es un tipo de controlador que mediante un Authorization header identifica al usuario y su rol.

Ejemplo:

class DumbAuthController extends ResourceController
{
    function __construct()
    {
        parent::__construct();
    }

    function super_cool_action($a)
    {
        if (!$this->hasAnyRole(['cajero', 'gerente']))
            Factory::response()->error('Unauthorized', 401);

        // acción cualquiera:
        return ++$a;
    }       
}


# Api Controller:

Un ApiController es un tipo de ResourceController que sirve para procesar un endpoint y por tanto sus métodos son los verbos correspondientes: get, post, put, patch, delete, head


# Middlewares

Los middlewares constituyen una capa intermedia que permiten interceptar una respuesta y alterarla o modificar el flujo del programa proveyendo un punto donde se pueden hacer chequeos de seguridad por ejemplo.

SimpleRest implementa Middlewares para el FrontController de la siguiente manera:

Supongamos que se tiene un Controlador llamado TestController con un método que genera una respuesta y queremos alterarla *sin* tocar el código del método:

	class TestController {
		// ...

		function mid(){
			return "Hello World!";        
		}
	}

1) Se debe crear un Middleware que tendrá una estructura parecida a:

	<?php

	namespace simplerest\middlewares;

	use simplerest\core\Middleware;

	class InyectarSaludo extends Middleware
	{   
		function __construct()
		{
			parent::__construct();
		}

		function handle(?callable $next = null){
			$data = $this->res->getData();

			if (is_string($data)){
				if (Strings::startsWith('Hello ', $data)){
					$this->res->setData(preg_replace('/Hello (.*)/', "Hello happy $1", $data,1));
				}
			}
		}
	}

2) Se registra el Middleware en config/middlewares.php

	return [
		// ...
		'simplerest\controllers\TestController@mid' => InyectarSaludo::class,
		// ...
	];

Ahora la respuesta del método mid() de TestController será interceptada y modificada.


# El Schema

Todas las tablas deben tener un único id inclusive si son "tablas intermedias" (conocidas también como "tablas puente") y se especifica en la propiedad $id_name.

Se recomienda que las tablas tengas claves primarias simples pero si son compuestas entonces es requisito que uno de los campos sea AUTOINCREMENTAL. A futuro se prevee que se acepte que uno de los campos de una PRIMARY KEY compuesta pueda ser un UUID en vez de AUTOINCREMENTAL. 


# Modelo

Cada modelo es definido en una clase en /app/models que extiende a Model y donde se define el schema y algunas propiedades de los campos. Ejemplo:
	
	class BazModel extends Model
 	{ 

		protected $hidden   = [];
		protected $not_fillable = [];

		function __construct(bool $connect = false){
			parent::__construct($connect, BazSchema::class);
		}	
	}

Un modelo extendiende a la clase Model que les provee toda la funcionalidad y acepta un schema. Tanto modelos como schemas pueden ser generados por el comando "make".

La clase "base" para el modelo es Model pero se sugiere extender a MyModel a fin de poder aplicar campos automáticos y hooks de forma general o sea que apliquen a todos los modelos.

Ej:

	class MyModel extends Model 
	{
		protected $createdBy = 'usu_intIdCreador';
		protected $updatedBy = 'usu_intIdActualizador';
		protected $createdAt = 'gen_dtimFechaActualizacion';
		
		function __construct(bool $connect = false, $schema = null, bool $load_config = true){
			parent::__construct($connect, $schema, $load_config);
		}
	}

En el ejemplo previo se especifica que para todos los modelos (salvo que en el propio modelo se explicite lo contrario) los campos automáticos que allí se listan (hay más) tienen los nombres mencionados.

Hay básicamente 3 formas de usar un Model:

a) Instanciando directamente Model en cuyo caso *no* dispondríamos de un schema a menos que se lo inyectemos:

	$m = (new Model(true))
		->table('products')   
		->select(['id', 'name', 'size'])
		->where(['cost', 150, '>=']);

	dd($m->get());

	Ventajas: 

	- Puede hacerse uso del Query Builder sin un schema lo cual es útil para probar la validez del mismo (pruebas unitarias)
	- Puede generar las queries sin una conexión a la base de datos (comportamiento por defecto).

	Desventaja:

	- Verboso
	- En principio no se dispone del Schema sin lo cual no es posible hacer validaciones contra el mismo.
	- No funcionan de forma automática los campos UUID

b) Instanciando una clase Model derivada

	$m = (new ProductsModel(true))
		->select(['id', 'name', 'size'])
		->where(['cost', 150, '>=']);

	dd($m->get());

	Ventajas: 

	- Se dispone del schema si se inyecta en el modelo derivado (así es generado por "make")
	- Validación out-of-the-box si se inyectando el validator.
	- Menos verboso: ya no es necesario llamar al método table('nombre_tabla')   

c) Usando la clase DB para obtener la instancia

    $m = DB::table('products')
		->select(['id', 'name', 'size'])
		->where(['cost', 150, '>=']);
    
	dd($m->get());
    
	Ventajas:

	- Es la opción menos verbosa.
	- Se dispone del Schema para hacer validaciones.

	Desventajas:

	- Obtiene una conexión a la base de datos aún antes de hacer cualquier tipo de validación.
	- Es un poco más lenta 

Es de destacar que podría darse el caso de que sea Ud. necesite acceder a la base de datos desde el archivo config.php pero si se hiciera DB::table('xxx') se generaría una referencia circular porque se incluiría nuevamente el archivo config.php

La solución es crear una conexión directamente sin uso de las clases Model o DB y luego especificar que el modelo no deba ni crear conexión ni intentar cargar el config.php para nada.

Ej:

	$dbname = 'nombre_db';
    $user = 'boctulus';
    $pass = 'xxxxxxxxxxxxxxx';
    $dsn  =  "mysql:dbname=$dbname;host=127.0.0.1";

    try {
        $conn = new \PDO($dsn, $user, $pass);
    } catch (PDOException $e) {
        throw new \Exception('DB connection fails: ' . $e->getMessage());
    }

    $m = (new Model(false, null, false))
    ->setConn($conn);
    
    $rows = $m->table('mi_tabla')
    ->get();


# Inserción de registros

El método create() acepta un array asociativo de campos con sus valores y hace el INSERT

	$last_id = DB::table('super_cool_table'
	->create([
		'name' => 'SUPER',
		'age' => 22,
	]);


# Insert múltiple

Se puede enviar a  insertar varios registros de forma simultánea y se devolverá también el ID del último registro insertando si se hace de la siguiente forma:

Ej:

	// En caso de haber varias DB(s), selecciono la conexión donde está
	DB::getConnection('az');

	$data = [
		array (
			'name' => 'N1',
			'comment' => 'P1',
			'product_id' => 100
		),

		array (
			'name' => 'N2',
			'comment' => 'P2',
			'product_id' => 103
		),

		array (
			'name' => 'N3',
			'comment' => 'P3',
			'product_id' => 105
		)
	];

	$last_id = DB::table('product_tags')
	->create($data);

Cabe aclarar que el con el método create() se hace un INSERT INTO detrás de otro y no se envian juntas las rows la base de datos.  

Si se desea enviar todas las rows de una vez a la DB se puede hacer con insert()

Ej:

	$data = [
		array (
			'name' => 'N1',
			'comment' => 'P1',
			'product_id' => 100
		),

		array (
			'name' => 'N2',
			'comment' => 'P2',
			'product_id' => 103
		),

		array (
			'name' => 'N3',
			'comment' => 'P3',
			'product_id' => 105
		),

		array (
			'name' => 'N4',
			'comment' => '',
			'product_id' => 105
		)
	];

	/*
		id del primer registro insertado en bloque
	*/

	$id = DB::table('product_tags')
	->insert($data);


# Obtención de registros

Todos los registros (menos los marcados como borrados)

	$rows = DB::table('products')
	->get();

Para filtrar usar where()

	$rows = DB::table('products')
	->where(['size' => '2L'])
	->get();

También es válido usar el método where() con un array (campo, valor)

	$rows = DB::table('products')
	->where(['size', '2L'])
	->get();

Si bien el método where() admite userse de dos ambas dos formas no es aconsejable combinarlas:

	// ok
	$rows = DB::table('products')
	->where(['size', '2L'])
	->where(['cost', 100])
	->get();

	// ok
	$rows = DB::table('products')
	->where(['size' => '2L'])
	->where(['cost' => 100])
	->get();

	// No se recomienda (!)
	$rows = DB::table('products')
	->where(['size' => '2L'])
	->where(['cost', 100])
	->get();

La última forma es funcional pero podría fallar en algún caso.


# Comparar dos campos en el WHERE

	$m = (DB::table('users'))
	->whereColumn('firstname', 'lastname', '=');  

	dd($m->get()); 


# Forma básica de debugueo de queries

Siempre que se use el método DB::table() será posible debuguear la última query de la siguiente manera:

    dd(DB::getLog());

Ejemplo:

	$rows = (DB::table('users'))
	->whereColumn('firstname', 'lastname', '=')
	->get();  

	dd(DB::getLog()));

Hay otras formas de debugueo de consultas que se pueden encontrar más adelante en este manual.


# Ocultar y des-ocultar campos

Si existe el modelo y el schema correspondiente para una tabla se pueden suprimir campos:

	class UsersModel extends Model
	 { 	
		protected $hidden   = [	'password' ];

		// ...

En este caso password será por defecto suprimido cuando no haya un SELECT o sea cuando sea un SELECT *

Es posible ocultar o desocultar campos programáticamente siempre que se utilice select() o selectRaw() en la consulta:

	$u = DB::table('users');
    $u->unhide(['password']);
    $u->hide(['confirmed_email']);
    $u->where(['id'=>$id]);

    dd($u->get());


Si se desea des-ocultar cualquier campo oculto se dispone del método unhideAll()

	$rows = DB::table('users')
    ->crossJoin('products')
    ->where(['users.id', 90])
    ->unhideAll()
    ->get();


# Campos no rellenables 

Del mismo modo que como ocurre con los campos ocultos hay campos que son no-fillables:

	class UsersModel extends Model
	 { 	
		protected $hidden   = [	'password' ];
		protected $not_fillable = ['confirmed_email', 'is_active'];

		// ...


Igualmente hay métodos para programáticamente hacer rellenables o no-rellenables ciertos campos:

	$u = DB::table('users');
    $u->fill(['email']);
    $u->unfill(['password']);
    $id = $u->create([
    				'email'=>$email, 
    				'password'=>$password, 
    				'firstname'=>$firstname, 
    				'lastname'=>$lastname
    ]);
    


# Borrado "suave"

Si una tabla y su schema dispone de un campo "deleted_at" de tipo DATETIME, al hacer un delete() el registro no es borrado fisicamente sino solo se oculta de los resultados:

	DB::table('products')
	->where(['id' => $id])
	->get());

	// SELECT * FROM products WHERE id = $id AND deleted_at IS NULL

En caso de querer des-ocultar registros borrados para que sean visualizados en una consulta usar showDeleted()

	DB::table('products')
	->where(['id' => $id])
	->showDeleted()
	->get());

	// SELECT * FROM products WHERE id = $id 

Si se desea que al momento de borrar el campo se elimine de forma definitiva user ->setSoftDelete(false)

	$u = DB::table('users')
	->find($id)
	->setSoftDelete(false)
	->delete();  


# Joins

Un INNER JOIN se hace de la siguiente manera:

	$instance->join('table2', 'table2.id', '=',  'table1._id');

El operador puede ser =, >, <, >= o <=

Ej:

	$m = DB::table('users')
	->join('user_sp_permissions', 'users.id', '=',  'user_sp_permissions.user_id')
	->join('sp_permissions', 'sp_permissions.id', '=', 'user_sp_permissions.id')

	->select(['sp_permissions.name as perm', 'username', 'is_active']);

	dd($m->get()); 
	dd($m->dd()); 
     

Los joins pueden simplificarse como auto-joins de haber un schema para el modelo:

	$m = DB::table('users')
	//->join('user_sp_permissions');
	->join('sp_permissions');

	$m->select(['sp_permissions.name as perm', 'username', 'is_active']);

	dd($m->get()); 
	dd($m->dd()); 

Es importante notar que *no* debe hacerse el JOIN() *explícito* con la tabla puente y la table relacionada
por esta porque en tal caso la relación con la tabla puente quedaría duplicada. Si se incluyera 
se generaría para el caso de MySQL un error como

	SQLSTATE[42000]: Syntax error or access violation: 1066 Not unique table/alias: 'user_sp_permissions'

Si hay una tabla puente, la relación debe hacerse con la table del otro lado del puente y no incluir a la tabla puente en cuestión.


# Left y Right joins

Ej:

	$users = DB::table('users')->select([
	    "users.id",
	    "users.name",
	    "users.email",
	    "countries.name as country_name"
	])
	->leftJoin("countries", "countries.id", "=", "users.country_id")
	->get();

# Cross y natural joins

	$rows = DB::table('users')
    ->crossJoin('products')
    ->where(['users.id', 90])
    ->unhideAll()
    ->showDeleted()
    ->get();

	$rows = (new Model())->table('employee')
    ->naturalJoin('department')
    ->unhideAll()
    ->showDeleted()
    ->get();


# Alias (as)

Es posible declarar alias tanto para la table principal como para las tablas a ser unidas por join.

Ej1)

	DB::getConnection('az');

	$rows = DB::table('users', 'u')
	->join('products')
	->join('roles')
	->unhideAll()
	->showDeleted()
	//->dontExec()
	->get();
	
	dd($rows);
	dd(DB::getLog());  

Ej2)

	DB::getConnection('az');

	$rows = DB::table('users', 'u')
	->join('products as p')
	->join('roles as r')
	->unhideAll()
	->showDeleted()
	//->dontExec()
	->get();
	
	dd($rows);
	dd(DB::getLog());   

El SQL generado en este caso sería algo como:

	SELECT * FROM users as u 
	INNER JOIN products as p ON u.id=p.belongs_to 
	INNER JOIN user_roles ON u.id=user_roles.user_id 
	INNER JOIN roles as r ON r.id=user_roles.role_id;

Cabe notar que no es posible especificar el alias para la tabla puente del ejemplo (`user_role`)

Tampoco es posible explicitar el "alias" (con 'as') cuando haya se haga un join hacia una tabla desde la cual existe más una relación con la primera. 

Ej:

	$rows = DB::table('users', 'u')
    ->join('products as p')
	->get();

Posible salida:

	SELECT * 
	FROM users as u 
	INNER JOIN products as p ON p.belongs_to = u.id 

En el caso anterior no habría problema si products tiene dos FKs (`belongs_to` y `deleted_by`) para users pero el "problema" se presenta si la relación se hace al revés:

	$rows = DB::table('products', 'p')
    ->join('users as u')
	->get();

Posible salida:

	SELECT * 
	FROM products as p 
	INNER JOIN users as __belongs_to ON __belongs_to.id = p.belongs_to 
	INNER JOIN users as __deleted_by ON __deleted_by.id = p.deleted_by


El "problema" es que cuando hay más de una relación entre dos tablas se necesita un alias por cada relación y con "as" solo es posible especificar una por lo cual la ambiguedad la resuelve automáticamente el framework.


### Referencia de métodos de la clase Model

La clase Model responsable del Query Builder tiene una gran cantidad de métodos que proveen las distintas funcionalidades.


# selectRaw

Por lo general cuando se desea usar un alias a un campo es necesario hacer algo como

	$vals = DB::table('products')
	->setFetchMode('COLUMN')
	->selectRaw('cost * 1.05 as cost_after_inc')->get();

O lo mismo pero con parámetros 

	$vals = DB::table('products')
	->setFetchMode('COLUMN')
	->selectRaw('cost * ? as cost_after_inc', [1.05])->get();

# havingRaw

En general las funciones raw permiten corregir situaciones donde es muy difícil expresar con el query builder exactamente lo que queremos o bien este falla en construir algo con la sintáxis correcta para el motor de base de datos que estamos utilizando.

Ej:

	$rows = DB::table('products')
	->showDeleted()
	->groupBy(['name'])
	->having(['c', 3, '>'])
	->select(['name'])
	->selectRaw('COUNT(*) as c')
	->get();

Podría ser traducido a SQL como:

	SELECT 
	COUNT(*) as c, 
	name 
	FROM 
	products 
	GROUP BY 
	name 
	HAVING 
	products.c > 3;

Lo cual no es totalmente válido y en MySQL genera el error:

	Uncaught PDOException: SQLSTATE[42S22]: 
	Column not found: 1054 Unknown column 'products.c' in 'having clause'

La solución en este caso viene de la mano de havingRaw()

	$rows = DB::table('products')
	->showDeleted()
	->groupBy(['name'])
	->select(['name'])
	->selectRaw('COUNT(*) as c')
	->havingRaw('c > ?', [3])
	->get();

Generando esta vez un SQL correcto:

	SELECT 
	COUNT(*) as c, 
	name 
	FROM 
	products 
	GROUP BY 
	name 
	HAVING 
	c > 3;


Hay situaciones que son para usar havingRaw() pero el Query Builder hace la conversión internamente de having() a havingRaw() aunque tiene un costo en rendimiento y se pierde cierto control de la Query formada.

Ej:

	DB::table('products')
	->select(['size'])
	->selectRaw('AVG(cost)')
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->get();

En este caso el primer parámetro no es un campo sino que hay una función aplicada sobre un campo e internamente se ejecutará como:

	DB::table('products')
	->select(['size'])
	->selectRaw('AVG(cost)')
	->groupBy(['size'])
	->havingRaw('AVG(cost) >= ?', [150])
	->get();

Es posible forzar el uso de havingRaw() cuando sea necesario con setStrictModeHaving(true)

Ej:

	DB::table('products')		
	->setStrictModeHaving(true)
	->select(['size'])
	->selectRaw('AVG(cost)')
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->get();

Ya con el modo estricto activado se generará una excepción:

	PHP Fatal error:  Uncaught Exception: Use havingRaw() instead for AVG(cost) >= ?


# when

El método when() simplifica la creación de queries condicionales y generalmente se usa en conjunto con where() o sus variantes.

Veamos un snipet extraido del propio core del framework escrito sin when() y luego con when() 

-- sin when()

	$m = DB::table('migrations');

	if ($to_db == '__NULL__'){
		$m->whereNull('db');
	} else {
		$m->where(['db' => $to_db]);
	}
			
	$filenames = $m->orderBy(['created_at' => 'DESC'])
	->pluck('filename');

El método when() tiene tres parámetos: la condición y dos callbacks de los cuales el primero se aplica si la condición es verdadera y la segunda si es falsa.

-- con when()

	$filenames = DB::table('migrations')
	->when($to_db == '__NULL__', 
		function($q){
			$q->whereNull('db');
		},
		function($q) use($to_db){
			$q->where(['db' => $to_db]);
		}
	)
	->orderBy(['created_at' => 'DESC'])
	->pluck('filename');


# Grupos

Para colocar paréntesis en el WHERE del SQL resultante usando el Query Builder existen los "grupos" implementados con el método group()

Ej:

	DB::table('xxxx')
	->group(function($q){
		$q->where(condA)
		->orWhere(condB)
	})
	->where(condC);


Lo anterior en el WHERE de arma algo como

	WHERE (A OR B) AND C


Veamos otro ejemplo:

	DB::table('xxxx')
	->where(condC)
	->group(function($q){
		$q->where(condA)
		->orWhere(condB)
	});

Lo anterior equivale a tener en el WHERE algo como

	WHERE C AND (A OR B)


La diferencia es que en último caso se está suponiendo que el operador que queremos usar para conectar el grupo con la primera condición (C) es un 'AND' pero podría no ser el caso por lo que se dispone de grupos especiales llamados "conectores" donde se explicita el operador de la conjunción:

Conectores:

	and()
	or()
	andNot()
	orNot()

Ej:
	A OR (B AND C)


En pseudo-código (ver como se usa la función where) sería algo así:	

	DB::table('xxxx')
	->where(condA)
	->or(function($q){
		$q->where(condB)
		->where(condC);
	})

o ..

	DB::table('xxxx')
	->where(condA)
	->or(function($q){
		$q->where([
			condB,
			condC
		]);
	})


Es importante tener en cuenta que se abren paréntesis hacia el lado derecho solamente con lo cual,

	DB::table('xxxx')
	->where(condA)
	->where(condB)
	->or(function($q){
		$q->where([
			condC
		]);
	})


Genera en SQL una expresión del tipo "A AND B OR C" y *no* "(A AND B) OR C". En caso de estar buscándo lo anterior podría hacerse de la siguiente manera:

	DB::table('xxxx')
	->where([
			condA,
			condB
	])
	->or(function($q){
		$q->where([
			condC
		]);
	})

Otra opción, más general, es usar un grupo también para "agrupar" las condiciones A y B

	DB::table('xxxx')
	->group(function($q){
		$q->where(condA)
		$q->where(condB);
	])
	->or(function($q){
		$q->where([
			condC
		]);
	})


Ejemplo funcional de operadores OR / AND anidados en WHERE con group()

	$m = DB::table('products')

	->group(function($q){  
		$q->where([
			['cost', 100, '>'],
			['id', 50, '<']
		]) 
		// OR
		->orWhere([
			['cost', 100, '<='],
			['description', NULL, 'IS NOT']
		]);  
	})
	// AND
	->where(['belongs_to', 150, '>'])
	
	->select(['id', 'cost', 'size', 'description', 'belongs_to']);

	dd($m->get()); 


Los grupos / conectores aplican también a having() y havingRaw()

Ej:

	DB::table('products')->showDeleted()

	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->orderBy(['size' => 'DESC'])
	->get(['cost', 'size', 'belongs_to']); 


# Restricciones que aplican para having() y havingRaw()

Puede -según sea el caso- que having() y havingRaw() no sean combinables en la misma query y que de ser necesario el uso de havingRaw() entonces todo lo que corresponda a HAVING deba realizarse con *unico* havingRaw().


# Qualificación de campos

Por defecto todos los campos son auto-qualificados como tabla.campo o si hay un alias para la tabla como alias.campo en la query construida. Esto obviamente tiene cierto impacto de performance pero es el comportamiento por defecto dado que evita posibles colisiones de nombres cuando hay JOINs.

Puede desactivarse la auto-qualificación con el método dontQualify()

Ej:

	$m = DB::table('products')
	->groupBy(['cost', 'size'])
	->having(['cost', 100])
	->select(['cost', 'size']);

	dd($m->dd());  

Produce:

	SELECT 
	products.cost, 
	products.size 
	FROM 
	products 
	WHERE 
	products.deleted_at IS NULL 
	GROUP BY 
	products.cost, 
	products.size 
	HAVING 
	products.cost = 100;

Mientras que,

	$m = DB::table('products')
	->dontQualify()
	->groupBy(['cost', 'size'])
	->having(['cost', 100])
	->select(['cost', 'size']);

	dd($m->dd());  

Produce:

	SELECT 
	products.cost, 
	products.size 
	FROM 
	products 
	WHERE 
	products.deleted_at IS NULL 
	GROUP BY 
	products.cost, 
	products.size 
	HAVING 
	products.cost = 100

Para cambiar el flag en sentido contrario se puede utilizar el método doQualify()


### La clase DB

La clase DB es una librería clave cuyo rol principal es manejar las conexiones de base de datos y ofrecer información sobre las mismas. Posee además un mini Query Builder para consultas "raw".


# Obtención de información de drivers

Método DB::driver()							devuelve driver de la conexión actual
Método DB::driverVersion(bool $numeric)		devuelve la versión del driver			
Método DB::isMariaDB()						devuelve si es MariaDB

Ej:

	dd(DB::driver(), 'Driver');
	dd(DB::driverVersion(), 'Driver version');
	dd(DB::driverVersion(true), 'Driver version (num)');
	dd(DB::isMariaDB(), 'Is MariaDB');

El resultado será algo como:

	--[ Driver ]-- 
	mysql

	--[ Driver version ]-- 
	5.7.35-0ubuntu0.18.04.2

	--[ Driver version (num) ]-- 
	5.7.35

	--[ Is MariaDB ]-- 
	false


### Ejecución de "consultas crudas"

Las consultas puramente crudas son aquellas que son un simple string en SQL que pueden contener los "?" para los parámetros en caso de que las consultas o sentencias sean preparadas. 

# select

Se dispone del método DB::select()()

Ej:

	$res = DB::select('SELECT * FROM products');

O pasando parámetros:

	$res = DB::select('SELECT * FROM products WHERE cost > ? AND size = ?', [550, '1 mm']);

Un ejemplo completo donde se genera una query cruda y luego se ejecuta:

	$m = DB::table('products')
	->dontBind()    
	->dontExec()    
	->select(['size', 'cost'])
	->groupBy(['size'])        
	->having(['cost', null, '>='])
	->having(['size' => null]);

	$sql = $m->toSql();

	dd(DB::select($sql, [5, '1L']));
	dd($sql, 'pre-compiled SQL');
	dd(DB::getLog(), 'Excecuted SQL');

# insert

Para la inserción de registros de forma "cruda" existe el método DB::insert()

Ej:

	$id = DB::insert('insert into baz (id_baz, name, cost) values (?, ?, ?)', [100, 'cool thing', '16.25']);
    dd(DB::getLog(), 'Excecuted SQL');

Ej:

	$id = DB::insert('insert ignore into `baz2` (id_baz2, name, cost) values (?, ?, ?)', [5000, 'cool thing', '16.25']);
	dd(DB::getLog(), 'Excecuted SQL');

La función intenta encontrar la PRIMARY KEY de la tabla para así devolver el 'id' y a tal fin revisa si existe un archivo de schema creado y sino lo encuentra intenta con 'id' como nombre para la PRIMARY KEY.


# update

Para la actualización en crudo de datos se dispone del método DB::update()

Ej:

	$affected_rows = DB::update('update `baz2` SET name = ?, cost = ? WHERE id_baz2 = ?', ['something', '99.99', 5000]);


# delete

Similarmente se dispone del método DB::delete()

Ej:

	$affected_rows = DB::delete('DELETE FROM `baz2` WHERE id_baz2 = ?', [5000]);


# statement

Finalmente existe un método genérico para ejecutar "raw" statements o sea, comandos SQL que no son de tipo consulta o sea distintos de select.

Ej:

	$affected_rows = DB::statement('DELETE FROM `baz2` WHERE id_baz2 = ?', [5000]);


Nota: 

Las funciones "raw" de la clase DB admiten un parámetro para el tenant_id y en caso de tener que cambiar la conexión al finalizar la conexión original es restaurada.

Ej:

	dd(DB::getCurrentConnectionId());

	$res = DB::select('SELECT * FROM my_table', [], null, 'conn_2');

	dd(DB::getCurrentConnectionId());


# Procedimientos almacenados

Para la ejecución de procedimientos almacenados se puede sacar ventaja de los métodos "raw" de la clase DB, en particular:

DB::statement()         para ejecución de sentencias que no devuelven resultado
DB::select()            para la ejecución de sentencias que devuelven resultado

En los siguientes ejemplos se usará la keyword "CALL" presente en MySQL pero se entiende que deba usarse la equivalente según el RDBMS donde en SQLSRV por ejemplo es "EXEC".

Ej:

    DB::statement("CALL insertEvent('?')", ['2012.01.01 12:12:12']);

Y para el caso de un DB::select()

Ej:

    $price = DB::select('CALL productpricing()');

O si contuviera algún parámetro como por ejemplo el id de categoría:

Ej:

    $price = DB::select('CALL productpricing(?)', [34]);

Además es posible especificar el "modo" en el que se traen los resultados ("ASSOC", "NUM", ...) que se corresponden a los de PDO:

Finalmente tanto DB::statement() como DB::select() permiten pasar el id de la conexión en el último parámetro


# Transacciones

La forma básica de crear una transacción con su "roll back" en caso de fallo tiene la siguiente estructura:

	DB::beginTransaction();

	try {

		// ...
		// ...
		
		DB::commit(); 

	}catch(\Exception $e){
		DB::rollback();

		dd($e->getMessage(), "Error en transacción");
	}	

Ej:

	DB::beginTransaction();

	try {
		$name = '';
		for ($i=0;$i<20;$i++)
			$name .= chr(rand(97,122));

		$id = DB::table('products')->create([ 
			'name' => $name, 
			'description' => 'bla bla bla', 
			'size' => rand(1,5).'L',
			'cost' => rand(0,500),
			'belongs_to' => 90
		]);   

		//throw new \Exception("AAA"); 

		DB::commit();

	} catch (\Exception $e) {
		DB::rollback();
		throw $e;
	} catch (\Throwable $e) {
		DB::rollback();            
	}            

Cabe notar que se olvidara colocar el DB::beginTransaction() se producirá el error "There is no is_active transaction".

Una forma más conveniente de realizar transacciones es usando una función anómima con transaction()

	DB::transaction(function(){
		// operación sobre la base de datos   
		// operación sobre la base de datos 
		// operación sobre la base de datos 
	}); 

Ej:

	DB::transaction(function(){
		$name = '';
		for ($i=0;$i<20;$i++)
			$name .= chr(rand(97,122));

		$id = DB::table('products')->create([ 
			'name' => $name, 
			'description' => 'Esto es una prueba', 
			'size' => rand(1,5).'L',
			'cost' => rand(0,500),
			'belongs_to' => 90
		]);   
	});     


Output mutators

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->get();

Transformers 

	$t = new UsersTransformer();

	$rows = DB::table('users')
	->registerTransformer($t, $this)
	->get();

otro ejemplo:

	$t = new \simplerest\transformers\ProductsTransformer();

	$rows = DB::table('products')
	->where(['size'=>'2L'])
	// ...
	->registerTransformer($t)
	->get();

Son combinables transformers con output mutators:

	$t = new \simplerest\transformers\UsersTransformer();

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->registerTransformer($t)
	->get();



# Fetch modes 

Los modos de obtención de datos pueden setearse  en cualquera de los casos mediante el método setFetchMode() antes de llamar a un método final como get(), first(), min(), avg(), etc 

Ej:

	dd((new BarModel())
	->connect()
	->setFetchMode('ASSOC')
	->get());


# Debuguear una query (desde el controlador)

Hay varios métodos para hacer un debug de una query comenzando por DB::dd() que ocupa el lugar del método get()

Ejemplo:

	$res = DB::table('products')
		->groupBy(['name'])
		->having(['c', 3, '>='])
		->select(['name'])
		->selectRaw('COUNT(name) as c')
		->get());

var_dump($res);

Reemplazando ->get() por ->dd()

	$res = DB::table('products')
		->groupBy(['name'])
		->having(['c', 3, '>='])
		->select(['name'])
		->selectRaw('COUNT(name) as c')
		->dd());

var_dump($res);

Resultado:

	SELECT AVG(cost), size FROM products WHERE deleted_at IS NULL GROUP BY size HAVING AVG(cost) >= 150

El problema del método dd() es que no funciona si en su lugar hay una función get() parametrizada -en vez de usar select()- o bien una función agregativa comon min(), max(), count(), sum() y avg() 

Otra función de debug, disponible cuando se usa DB::table() es DB::getLog()

Ejemplo:

	$c = DB::table('products')
		->where([ 'belongs_to'=> 90] )
		->count('*', 'count');

	dd(DB::getLog());


Nota:

Para que DB::getLog() arroje la query estaba debe haber sido "armada" algo que sucede cuando se "compila" al ejecutar funciones como get(), first(), pluck() .... o dd()

	$m = DB::table('products')
	->where(['size', ['0.5L', '3L'], 'NOT IN']);

	// Nada
	dd(DB::getLog());

Sin embargo lo siguiente *SI* devuelve la query:

	$m = DB::table('products')
	->where(['size', ['0.5L', '3L'], 'NOT IN']);

	$m->dd();
	dd(DB::getLog());
    
Lo siguiente también sirve:

	DB::table('products')
	->where(['size', ['0.5L', '3L'], 'NOT IN'])
	->dontExec()
	->dontBind()
	->get();

	dd(DB::getLog());
	

# Obtención de la query pre-compilada

Una función de debug que puede utilizarse es getLastPrecompiledQuery(), la cual devuelve el último query antes de ser bindeado con los parámetros -aunque per se no evita el binding-.

Ejemplo:

	$uno = DB::table('products')->showDeleted()
	->select(['id', 'name', 'description', 'belongs_to'])
	->where(['belongs_to', 90]);

	$m2  = DB::table('products')->showDeleted();
	$dos = $m2
	->select(['id', 'name', 'description', 'belongs_to'])
	->where(['belongs_to', 4])
	->where(['cost', 200, '>='])
	->union($uno)
	->orderBy(['id' => 'ASC'])
	->get();

	dd($m2->getLastPrecompiledQuery());

En cualquier caso es posible realizar un debug *sin* ejecutar la consulta con el método dontExec() y mediante el método dontBind() evitar el "bindeo" de parámetros. Esto podría ser útil para armar una sub-query.

Ejemplo:

	$res = DB::table('products')
	->dontBind()   // <--- here 
	->dontExec()   // <--- here 
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->select(['size'])
	->selectRaw('AVG(cost)')
	->get();

	dd(DB::getLog());

También podemos evitar se cree una conexión a la base de datos pasando false como tercer parámetro a DB::table() y finalmente si nuestro interés es obtener la consulta pre-compilada o sea armada pero aún con los parámetros sin bindear podemos llamar a toSql().

Ej:

	$m = DB::table('products', null, false)
	->where(['belongs_to', null])
	->group(function($q){
		$q->where(['size', null])
		->orWhere([
			['cost', null, '<='],
			['cost', null, '>=']
		]);
	})
	->whereRaw('cost < IF(size = "1L", ?, 100) AND size = ?', [null, null])
	->orderBy(['cost' => 'ASC']);

	$sql = $m
	->dontBind()
	->toSql();
	
	dd($sql);

Si desea realizar pruebas de performance remítase en la documentación a Time::exec()

Como si fueran pocas funciones de debug existe el método Model::getLog()

	$model = new \simplerest\core\Model($conn);
	$res = $model->create(['name' => 'Jhon', 'age' => 32]);
	dd($model->getLog());
	

# Debuguear una query (desde el propio modelo)

Es posible usar hooks sobre el modelo para debuguear una query. Por ejemplo si se desea debuguear un create ("INSERT INTO") sería así:

	class XXXXXModel extends Model
	{ 
		// ...

		function onCreated(array &$data, $last_inserted_id)
		{
			dd($this->dd());
		}
	}

Si la query falla entonces solo simule que se ejecuta usando el método dontExec() así: 

	class XXXXXModel extends Model
	{ 
		// ...

		function onCreating(array &$data)
		{
			$this->dontExec();
		}

		function onCreated(array &$data, $last_inserted_id)
		{
			dd($this->dd());
		}
	}


En el caso particular de los INSERTs es posible que Model::dd() no reemplace los parámetros y los deje como "preparados" obtieniendo algo como:

    INSERT INTO my_table (
      column1, column2
    ) 
    VALUES (
        :column1, :column2
    )

Entonces se puede obtener por separado los parámetros recibidos para el binding con Model::getLastBindingParamters()

Ej:

    function onCreating(array &$data)
    {
        $this->dontExec();  
    }

    function onCreated(array &$data, $last_inserted_id)
    {
        dd($this->dd(), 'SQL');
        dd($this->getLastBindingParamters(), 'PARAMETERS');
    }


# Formateo de las queries

Con fines de debugging se utiliza por defecto un paquete que formatea las queries SQL en la mayor parte de los casos aunque no es perfecto y puede querer desactivarse o parametrizarse de otra manera.

En MyModel podría hacerse:

	function __construct(bool $connect = false, $schema = null, bool $load_config = true){
        parent::__construct($connect, $schema, $load_config);

		static::$sql_formatter_callback = function(string $sql){
      		return MySqlFormatter($sql);
    	};
    }

O bien

	function __construct(bool $connect = false, $schema = null, bool $load_config = true){
        parent::__construct($connect, $schema, $load_config);
	
		$this->setSqlFormatter(function(string $sql){
			return MySqlFormatter($sql);
		});
	}

Donde si simplemente quisiera anularse por completo el sql formater bien podría hacerse:

	function __construct(bool $connect = false, $schema = null, bool $load_config = true){
        parent::__construct($connect, $schema, $load_config);

		static::$sql_formatter_callback = null;
    }	


Además es posible activar o des-activar el formateo de queries con los métodos Model::sqlFormaterOn(), Model::sqlFormaterOff() o bien pasándole un boolean a dd()

Producen el mismo resultado:

	echo $m->sqlFormaterOn()->dd();
	echo $m->dd(true);


Algunos ejemplos:

 	/*
        Sql formater habilitado via Model::sqlFormaterOn()
    */

	$m = DB::table('products')
	->showDeleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		$m
		->sqlFormaterOn()   /* habilito */
		->dd()
	);


    /*
        Sql formater des-habilitado (por defecto)
    */
   
	$m = DB::table('products')
	->showDeleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd($m->dd());
    

    /*
        Sql formater habilitado via Model::dd()
    */

	$m = DB::table('products')
	->showDeleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		$m
		->dd(true)
	);


Como Model::sqlFormatter() es un método público y convenientemente estático fácilmente se puede usar fuera del ámbito de la clase. El método es parametrizable y los parámetros pasan directamente al formateador.
    

    /*
        Sql formateador es aplicado en un segundo paso
        y se parametriza para colorizar 
    */

	$m = DB::table('products')
	->showDeleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		Model::sqlFormatter($m->dd(), true)
	);
    

Se provee de la función helper sql_formater() que es un atajo de Model::sqlFormatter()


    /*
        Sql formateador es aplicado en un segundo paso
        y se parametriza para colorizar pero usando el helper sql_formater 
    */

	$m = DB::table('products')
	->showDeleted()
	->groupBy(['cost', 'size', 'belongs_to'])
	->having(['cost', 100, '>='])
	->or(function($q){
		$q->havingRaw('SUM(cost) > ?', [500])
		->having(['size' => '1L']);
	})
	->select(['cost', 'size', 'belongs_to']);

	dd(
		sql_formater($m->dd(), true)
	);    


#### Campos manejados por el framework

Hay una cantidad de campos (que si están presentes en la tabla y declarados en el schema del modelo) que son manejados directamente por el framework. Consideremos la siguiente tabla:

id 				int(11)		
name			varchar(60)				
is_active			tinyint(4)
belongs_to		int(11)			*	
created_at		datetime		*			
created_by		int(11)			*	
updated_at		datetime		*	
updated_by		int(11)			*	
deleted_at 		datetime		*
deleted_by		tinyint(4)		*
is_locked			tinyint(4)		*

belongs_to		apunta directamente al user_id de quien crea el registro. Si el usuario tiene el permiso especial 'transfer' puede cambiar ese valor y hacer que apunte a otro usuario. Un caso especial son los registros creados dentro de un 'folder'.

created_by 		apunta indefectiblemente al user_id quien creó el registro.
update_by		apunta indefectiblemente al user_id del último usuario que modificó un registro. 
deleted_by		apunta indefectiblemente al user_id que hizo un borrado suave un registro.
created_at 		apunta indefectiblemente a la fecha-hora en que se creó un registro.
updated_at 		apunta indefectiblemente a la fecha-hora en que se modificó por última vez un registro.
deleted_at 		apunta indefectiblemente a la fecha-hora en que se creó un registro.
is_locked 			cuando un registro es mofificado por un usuario con permiso de 'lock' automáticamente se guarda un 1.


Los campos created_by, update_at y deleted_at son rellenados por Model pero al modelo no le compete si hay un sistema de autenticación y que usuario está haciendo el query así que los campos created_by, update_by, deleted_by y belongs_to son manejados a nivel de la API por ApiController al igual que el campo is_locked.

Nota: no olvides que los campos que necesites deben estar en las tablas y en el schema del modelo correspondiente. 


### Mutators

Se presentan casos donde es necesario hacer una transformación de los datos ya sea antes de enviarlos la query o bien antes de guardarlos en base de datos. 

El caso emblemático es cuando se requiere hacer un "hash" del password antes de guardarse ya sea en la creación o edición de un registro. Entonces usaremos un "input mutator".

Ejemplo

class UsersModel extends Model
{ 
	// ...

    function __construct($db = NULL){
		$this->registerInputMutator('password', function($pass){ 
			return password_hash($pass, PASSWORD_DEFAULT); 
		}, function($op, $dato){
			return ($dato !== null);
		});

        parent::__construct($db);
    }
}

El método registerInputMutator() acepta 3 parámetros:

- El campo cuyo contenido se quiere mutar (condicionalmente)
- Un callback que transforma el dato de entrada 
- Un callback (opcional) que determina en que caso se debe aplicar la función de entrada y que es alimentada con el tipo de operación ('UPDATE' o 'CREATE') y el dato de entrada. En caso de omitirse aplica siempre el mutator para ese campo.

El procedimiento es registrar los mutators para cada campo del modelo que los requiera. Otro uso de input mutators es para utilizar UUIDs donde dentro de un Trait podemos tener la funcionalidad de generar el uuid:

	namespace simplerest\traits;

	trait Uuids
	{
		protected function boot()
		{
			parent::boot();

			$this->registerInputMutator('uuid', function($id){ 
				return uuid_create(UUID_TYPE_RANDOM); 
			}, function($op, $dato){
				return ($op == 'CREATE');
			}); 
		}    
	}

<-- Como sería un efecto indeseado que se auto-generara un UUID reemplazando el actual al hacer un UPDATE, entonces ponemos como condición que se aplique solo en el CREATE.	

En el modelo donde queremos implementar el uuid, debemos declar el campo como string, importamos y hacemos el "use" del Trait:

	<?php
	namespace simplerest\models;

	use simplerest\core\Model;
	use simplerest\traits\Uuids;

	class BarModel extends Model 
	{ 
		use Uuids;
		
		function __construct($db = NULL){
			parent::__construct($db);
		}
	}

Recordar actualizar el Schema donde el campo uuid debe ser un string y pertenecer a los nullables.

Además de los Input Mutators, tenemos también los Output Mutator que permiten aplicar una función sobre la salida de la ejecución de una query. Lógicamente un Output Mutator sobre un campo no es compatible con declarar a ese mismo campo como "hidden". 

Ejemplo:

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->get();

Los mutators de salida pueden aplicarse incluso cuando hay funciones agregativas y las cláusulas GROUP BY y HAVING. 

Ejemplo:

	rows = DB::table('products')
	->registerOutputMutator('size', function($str){ return strtolower($str); })
	->groupBy(['size'])
	->having(['AVG(cost)', 150, '>='])
	->select(['size'])
	->selectRaw('AVG(cost)')
	->get();


### Transformers

Los transformers se aplican a la salida de la ejecución de una query y en orden después de los "output mutators" si los hubiere.

Una transformación permite (a diferencia de un output mutator) no solo aplicar funciones sobre la salida de cada campo sino también crear campos virtuales, eliminar campos o cambiarles el nombre.

Ejemplo:

	class UsersTransformer 
	{
		public function transform(object $user, Controller $controller = NULL)
		{
			return [
				'id' => $user->id,
				'username' => $user->username,
				'is_active' => $user->is_active,
				'email' => $user->email,
				'confirmed_email' => $user->confirmed_email,
				'password' => $user->password,
				'firstname' => 'Mr. ' . $user->firstname,
				'lastname' => $user->lastname,
				'full_name' => "{$user->firstname} {$user->lastname}",
				'deleted_at' => $user->deleted_at,
				'belongs_to' => $user->belongs_to
			];
		} 
		
		//...

Si un campo del SCHEMA no está presente desaparece de la salida (en caso de estar presente) y si se asigna con otra key, su nombre será otro. Ejemplo:

	family_name' => $user->lastname
	
Es importante destacar que no funciona si hay funciones agregativas presentes en la query y tampoco sirve para cambiar datos accediendo por un campo virtual por ejemplo.

Al registrar un transformer cualquier campo oculto se vuelve visible aunque cabe recordar que sino está presente como key del array devuelto desaparece.

Es posible acceder a propiedades del controller que invocó al transformer, ejemplo:

	class UsersTransformer 
	{
		public function transform(object $user, $controller = NULL)
		{
			return [
				'id' => $user->id,
				//...
				'password' => $controller->is_admin ? $user->password : false,
			];
		}
	}

Y ahora en un Controller paso $this como segundo parámetro a registerTransformer() para brindar acceso a las propieades del controlador:

	$t = new \simplerest\transformers\UsersTransformer();

	$rows = DB::table('users')
	->registerTransformer($t, $this)
	->get();

	dd($rows);

En el ejemplo si el controller tiene un campo is_admin (como sucede con los resource controllers en SimpleRest) entonces según el valor mostrará o no el password.
 
Mutators y transformers pueden usarse juntos, ej:

	$t = new \simplerest\transformers\UsersTransformer();

	$rows = DB::table('users')
	->registerOutputMutator('username', function($str){ return strtoupper($str); })
	->registerTransformer($t)
	->get();

	dd($rows);

Nota: de momento los Transformers se han probado desde Controllers y no desde las APIs <-- quizás sea posible usarlos de alguna forma si surge una necesidad real.


### Campos fillables, no-fillables, nullables y ocultos

Se puede definir un array de campos "fillables" aunque por lo general se lo puede dejar en automático. También es posible definir por el contrario, campos a excluir como "no fillables".

	protected $fillable = [
							'email',
							'password',
							'firstname',
							'lastname',
							'deleted_at',
							'belongs_to'
	];

	// o ...
	protected $not_fillable = ['confirmed_email'];

Los campos no-nullables serian los requeridos para las validaciones y se definen de igual modo: 

	protected $nullable = ['id', 'firstname', 'lastname', 'deleted_at', 'belongs_to', 'confirmed_email'];

Por último tenemos los campos ocultos:

	protected $hidden   = [	'password' ];


# Hooks sobre el modelo

Se definen varios event hooks sobre el modelo que se disparan ante una operación CRUD

	protected function onReading() {	}
	protected function onRead(?int $count) { }
	
	protected function onDeleting($soft_delete) { }
	protected function onDeleted(?int $count) { }

	protected function onCreating(Array $data) {	}
	protected function onCreated(Array $data, ?int $count) { }

	protected function onUpdating(Array $data) { }
	protected function onUpdated(Array $data, ?int $count) { }

Un uso práctico de estos eventos es para des-confirmar un email cuando se ha cambiado. En este caso se hace uso de la función isDirty() que acepta como parámetro el campo que necesitamos saber si ha cambiado.

	protected function onUpdating($data) {
		if ($this->isDirty('email')) {
			$this->update(['confirmed_email' => 0]);
		}	
	}

La función isDirty() acepta un campo o un array de campos o incluso puede estar vacia en cuyo caso verifica si algún campo sería cambiado.

Otro uso práctico sería el uso del evento onReading() para hacer un (inner, left, right, natural, cross,...) JOIN automático para devolver el contenido de tablas relacionadas cada vez que se lea un registro de esa tabla. Así:

class MaestroModel extends Model
{ 
	// ...

	function onReading(){
		$this->leftJoin('detalle');
	}
}

Desde cualquier hook del modelo es posible acceder a propiedades (si son públicas) útiles como $w_vars y $w_vals -entre otras- con las que es posible reconstruir el where.

A futuro podrían incluirse los eventos onRestoring() y onRestored() para cuando existe un soft-delete


# Hooks en APIs

Al igual que los modelos, las APIs que extienden a ApiController también tienen varios event hooks

	protected function onGetting($id) { }
    protected function onGot($id, $count){ }

    protected function onDeleting($id){ }
    protected public function onDeleted($id, $affected){ }

    protected function onPosting($id, $data){ }
    protected function onPost($data, $id){ }

    protected function onPutting($id, $data){ }
    protected function onPut($id, $data, $affected){ }


Existen otros hooks en en ApiController relacionados con el acceso a folders.

Uso prácticos de los hooks sobre APIs:

Ej:

	Podríamos querer recibir cierto parámetro por GET o via body y evitar que tener problemas con las valicaciones que hace el framework en particular del ApiController.

	Si el parámetro viene via Body podríamos leer el valor de forma destructiva en el constructor de la clase ApiController derivada con shiftBodyParam() así:

	class Products extends MyApiController
	{ 
		static protected $soft_delete = true;
		static protected $connect_to = [
			'product_categories',
			'users',
			'product_tags',
			'valoraciones',
			'digital_products'
		];

		function __construct()
		{       
			parent::__construct();

			global $my_param;
			$my_param = request()->shiftBodyParam('my_param');
		}        
	} 

Ahora tenemos el parámetro recibido como variable "global" y podremos usarlo en un hook de la misma API como onPost()

Ej:

	protected function onPost($data, $id){
		// acá está disponible $my_param
	
		DB::statement("EXEC sp_zyz()", [$id, $my_param]);
	}

Una derivación del ejemplo anterior es cuando necesitamos recibir el valor en el modelo ya sea de la entidad de la API o de un sub-recurso. Entonces podríamos dejar disponible el valor recibido usando la variable superglobal $GLOBALS o bien mediante alguna variable o propiedad estática.

Ej:

class Products extends MyApiController
	{ 
		static protected $soft_delete = true;
		static protected $connect_to = [
			'product_categories',
			'users',
			'product_tags',
			'valoraciones',
			'digital_products'
		];

		function __construct()
		{       
			parent::__construct();
			$GLOBALS['my_param'] = request()->shiftBodyParam('my_param');
		}        
	} 

y en el modelo:

	protected function onCreated(Array $data, ?int $count) {

		// acá está disponible $GLOBALS['my_param]
	
		DB::statement("EXEC sp_zyz()", [$id, $GLOBALS['my_param']]);
	}

De igual forma si el parámetro viniera por GET entonces puede leerse de forma destructiva con Request::shiftQuery()

Ej:

	$my_param = request()->shiftQuery('my_param');


# Hooks sobre el módulo de autenticación

La clase AuthController provee varios hooks que pueden usarse en MyAuthController

	function onRegister($data){ }
    function onRegistered($data, $uid, $is_active, $roles){ }
    function onRemember($data){}
    function onRemembered($data, $link_url){}
    function onLogin($data){}
    function onLogged($data, $uid, $is_active, $roles, $perms){}
    function onImpersonated($data, $uid, $is_active, $roles, $perms, $impersonated_by){}	
    function onChecked($uid, $is_active, $roles, $perms, $auth_method){}
    function onConfirmedEmail($uid, $roles, $perms){}
    function onChangedPassword($uid, $roles, $perms){}

    function getDbAccess($uid) : Array { return []; }


# Webhooks

Las APIs reversas o webhooks son un mecanismo que evita tener que andar preguntando a un endpoint si un registro fue creado o actualizado. SimpleRest permite crearlos de forma muy sencilla.

Los webhooks se crean via POST como cualquier otro recurso:

	POST /api/v1/hooks 

	{
		"name": "musk-cryptos", <nullable>
		"entity": "twitts",
		"op": "create"			
		"conditions": "account=eleonmusk&body[containsWord]=BTC,bitcoin,doge,crypto"
		"callback": "http://hexagon-alerts.lan/feed-reaction"
	} 

Existen 5 tipos de eventos u "operaciones" a las que reacciona un webhook: "create", "show", "list", "update" y "delete"

Las condiciones son opcionales pero sino las hay entonces se disparará el evento de forma incondicional cada vez que se cree, muestre, liste, actualice o borre un registro.

El webhook se ejecuta *después* de la operación u evento así que si el registro fue borrado físicamente (no hay softdelete) no habrá forma de chequear la condición si se hubiera especificado y tampoco de devolver el registro. 

Para el evento de listado no se chequea por condiciones ya que implicaría revisar cada registro y sería muy costoso.

Los valores que se buscan en las condiciones para el caso de un update son los actualizados así por ejemplo si se acutalizó un campo "categoría" se reaccionará al nuevo valor y no al viejo que pudiera contener.


El callback apunta a donde es procesador el request (también un POST ya que lleva body) y éste puede ser tan sencillo como:

	    if ($_SERVER['REQUEST_METHOD'] != 'POST'){
            exit;
        }

        $body = Factory::request()->getBody(false);
        Files::logger($body);
    
Notar que no se puede hacer un "vardump()" ya que el procesamiento ocurre en background.

Los operadores implementados son los mismos que para el ApiController más alguno adicional:

	'eq', 'gt', 'gteq', 'lteq', 'lt', 'neq', 'in', 'notIn', 'contains', 'notContains', 'startsWith', 'notStartsWith', 'endsWith', 'notEndsWith', 'containsWord', 'notContainsWord', 'between', 'notBetween'

El operador "in" es opcional siendo equivalentes:

	categoria[in]=7,8,22 
y
	categoria=7,8,22

Del mismo modo, 'contains', 'notContains' y 'containsWord', 'notContainsWord' aceptan varios valores delimitados por coma. El operador implícito es un OR.


### Validaciones

El framework incluye un validador que está integrado a nivel de la API Rest y puede también incluirse a nivel de los modelos o bien usarse de forma aislada.

Para mostrar el funcionamiento de la clase Validator consideremos el siguiente ejemplo donde usamos directamente la clase validator para procesar errores de un formulario por ejemplo:

	$data = [
				'nombre'=>'Pablo1',
				'apellido'=>'Bz',
				'segundo_apellido'=>'San Martín',
				'usuario'=>'',
				'celular'=>'321530', 
				'correo'=>'a@b',
				'calle'=>'0',
				'numero_de_casa'=>'',
				'observaciones'=>'la vida es complicada y bla bla bla bla bla bla bla',
				'fecha'=>'32-09-2019',
				'hora'=>'24:00:17',
				'rol'=>'',
				'fuerza'=>'100.xxx',
				'estrato'=>'3',
				'felicidad'=>'0.25',
				'energia'=>'.25',
				'hora_almuerzo'=>'13:30:00',
				'hora_cena'=>'18:00:00',
				'fecha_nac'=>'10-12-1902',
				'frutas_favoritas'=>['bananas','manzanas']  // podria provenir de un grupo de checkboxes
				
	];

	$rules = [
				'nombre' 			=> ['type'=>'alpha','required'=>true],
				'apellido' 			=> ['type'=>'alpha','required'=>true,'min'=>3,'max'=>30],
				'segundo_apellido'	=> ['type'=>'alpha','required'=>true,'min'=>3,'max'=>30],
				'usuario' 			=> ['required'=>true,'min'=>2,'max'=>15],
				'celular' 			=> ['type'=>'regex:/^[0-9]{10}$/','required'=>true],
				'correo' 			=> ['type'=>'email','required'=>true], 
				'calle' 			=> ['type'=>'int','required'=>false, 'min'=>1],
				'numero_de_casa'    => ['type'=>'numeric','required'=>false],
				'observaciones' 	=> ['type'=>'string','max'=>40],
				'fecha' 			=> ['type'=>'date'], 
				'hora' 				=> ['type'=>'time'], 
				'rol' 				=> ['type'=>'int','required'=>false], 
				'fuerza' 			=> ['type'=>'decimal','required'=>false],
				'estrato' 			=> ['type'=>'int','required'=>false, 'min'=>1, 'max'=>6],
				'felicidad' 		=> ['type'=>'int','required'=>false, 'min'=>0, 'max'=>100],
				'energia' 			=> ['type'=>'decimal','required'=>false, 'min'=>0, 'max'=>100],
				'hora_almuerzo' 	=> ['type'=>'time','min'=>'11:00:00','max'=>'10:15:00'],
				'hora_cena' 		=> ['type'=>'time','min'=>'19:00:00','max'=>'22:30:00'],
				'fecha_nac' 		=> ['type'=>'date','min'=>'01-01-1980','max'=>'12-12-2018'],
				'frutas_favoritas' 	=> ['type'=>'array','min'=>3]
				
	];

	$validado = (new Validator())->validate($rules,$data);

	if ($validado !== true)
		var_dump($validado);

La salida en caso de fracaso es un array conteniendo las reglas rotas para cada campo:

	array(14) {
	["nombre"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(10) "Sebastian1"
		["error"]=>
		string(4) "type"
		["error_msg"]=>
		string(11) "no es alpha"
		}
	}
	["usuario"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		string(0) ""
		["error"]=>
		string(8) "required"
		["error_msg"]=>
		string(20) "usuario es requerido"
		}
	}
	...	
	["frutas_favoritas"]=>
	array(1) {
		[0]=>
		array(3) {
		["dato"]=>
		array(2) {
			[0]=>
			string(7) "bananas"
			[1]=>
			string(8) "manzanas"
		}
		["error"]=>
		string(3) "min"
		["error_msg"]=>
		string(18) "mínimo 3 opciones"
		}
	}
	}

### Tipos

Los tipos (type) admitidos son:

bool
int
float
number
decimal(n,m)
string
alpha
notnum
email
date
datetime (compatible con DATETIME de SQL)
time
array
regex:/expresión/

El tipo 'time' es 'H:i:s' y el 'date' es 'd-m-Y' aunque siempre es posible crear un tipo personalizado con una expresión regular que se ajuste a las necesidades.


### Validaciones en los modelos

Para efectuar la validación sobre las operaciones CRUD con los modelos es tan simple como incluir una instancia de la clase Validator:

	$u = DB::table('products')->setValidator(new Validator());
	$rows = $u->where(['cost' => '100X', 'belongs_to' => 90])->get();

El validador es alimentado con los tipos del $schema y es complementado con un array $rules que puede estar presente opcionalmente en cada modelo.

La clase Validator implementa la interfaz IValidator proveyendo un método validate() que recibe un array de reglas a validar, un array asociativo con los datos y opcionalmente un array de campos sobre los que se deben saltear las validaciones.

	mixed : validate(array $rules, array $data, array $ignored_fields = null, bool $as_string = false)

El método validate() devuelve TRUE si no detectó reglas rotas y caso contrario devolverá un array con los errores como vimos previamente.

Es posible desactivar el chequeo de campos requeridos para todos los campos llamando al método setRequired(false).

Ejemplo:

	$data  = [ ..., ... , ...];
	$rules = [ ..., ... , ...];

	$validado = (new Validator())->setRequired(false)
	->validate($rules,$data);


### Constraints

La clase Validator admite las siguientes restricciones:

required 	# el campo es requerido
type 		# por tipo incluidos nuevos tipos creados con expresiones regulares
min 		# valor mínimo o longitud mínima para un string
max			# valor máximo o longitud máxima para un string
in 			# el valor debe estar dentro de un array de valores
between		# el valor debe estar entre dos valores; es un rango que incluye ambos extremos


### Mensajes personalizados

Para cualquier restricción es posible crear un mensaje personalizable (traducible con i18n) para el error en caso de que falle. 

Los mensajes se crean para cualquier restricción como required, type, min, max, in o between

Ejemplo:

	protected $rules = [
		'id 			=> ['type' => 'int', 'required' => true]
        'name' 			=> ['min'=>3, 'max'=>40],
		'description' 	=> ['max'=>50],
		'size' 			=> ['max'=>20],
		'workspace'		=> ['max'=>20],
		'is_active'		=> ['type' => 'bool', 'messages' => [ 'type' => 'Value should be 0 or 1'] ]
	];

Es posible utiliza una sintaxis mucho más amigable importando la librería ValidationRules. Así en un modelo podríamos tener el constructor:

	$this->addRules((new ValidationRules())
		->field('id')->type('int')->required()
		->field('name')->type('str')->max(40)->min(3)
		->field('description')->type('str')->max(50)
		->field('size')->type('str')->max(20)
		->field('workspace')->type('str')->max(20)
		->field('is_active')->type('bool', 'Value should be 0 or 1')
	);


### El helper db

El helper db (.php) ofrece una cantidad de funciones interesantes relacionadas con base de datos:


# User table & model helpers

get_users_table()

	Returns the table for users which is specified in config.php

get_user_model_name()

	Gets namespace-qualified model name corresponding to the users table specified in config.php


# Model helpers

table()				

	Similar to DB::table() but it does not load the schema for the model so there are no validations.

get_model_name()

	Gets namespace-qualified model name for a given table


# Schema helpers

get_schema_name()

	Gets namespace-qualified schema name for a given table

get_schema()

	Returns the schema for a given table. Result is cached.

in_schema()

	Returns if the given array of properties are in some schema.

get_pivot()	

	Returns an array for a pivot table given two tables in the pivot one.

get_primary_key()

	Returns the primary key for a given table name. If the primary key is compound then it returns the AUTOINCREMENT column. 


# Relationship analysis helpers

get_rels()

	Returns array with relations for a pair of given tables of an specified type of relation ('1:1', '1:n' or 'n:m'). If the asked relation is not the right one then result can be false or an empty array. Specifically returns false when there is no direct relationship between the tables (case n:m) and it asks if the relationship is 1:1 or 1:n

    If the relation is found, then the returned array has a different structure depending on whether it is a relation n: m or 1:1/1:n. 

get_rel_type()

	Get the type of relationship between two tables.

is_1_1()

	Returns if the relation between two given tables is 1:1

is_1_n()

	Returns if the relation between two given tables is 1:n

is_n_m()

	Returns if the relation between two given tables is n:m

is_mul_rel()

	Returns if the relation between two given tables can gives multiple rows or not. If rel type is 1:1 or FK is on $t1 (left side) => false


### ACL

La implementación del ACL incluye "roles" y permisos individuales (llamados también "scopes") para cada usuario sobre cada tabla expuesta a través de la API.

# Declaración de roles y sus permisos

Se implentó un ACL centralizado que se configurará en /config/acl.php y requiere ajustar permisos de lectura y escritura sobre el directorio app/security. 

Los siguientes métodos proveen la funcionalidad de declaración:

addRole(string $role_name, $role_id = null)
addRoles(Array $roles)
addInherit(string $role_name, $to_role = null
addResourcePermissions()
addSpecialPermissions(Array $sp_permissions, $to_role = null)
setAsGuest()
setAsRegistered(string $name)

Nota:

Los métodos setAsGuest() y setAsRegistered() se utilizan para definir qué rol tendrá la funcionalidad de "guest" y la de usuario registrado respectivamente. En el caso de setAsGuest() es opcional si el nombre del rol se dejara como "guest".

La estrucuración en la declaración de roles y permisos es muy flexible.

Ej:

	$acl = new Acl();

	$acl->addRole('guest', -1)
	->addResourcePermissions('products', ['read'])

	->addRole('vendedor', 1)
	->addInherit('guest')
	->addResourcePermissions('products', ['write'])
	->addResourcePermissions('foo', ['create', 'list'])

	->addRole('admin', 100)
	->addInherit('guest')
	->addSpecialPermissions(['read_all', 'write_all'])

	->addRole('superadmin', 500)
	->addInherit('admin')
	->addSpecialPermissions(['lock', 'fill_all']);


Y equivale a:

	$acl->addRoles([
		'guest' => -1,
		'vendedor' => 1,
		'admin' => 100,
		'superadmin' => 500
	])	

	->addResourcePermissions('products', ['read'], 'guest')	

	->addInherit('guest', 'vendedor')
	->addResourcePermissions('products', ['write'])	
	->addResourcePermissions('foo', ['create', 'list'])	

	->addInherit('guest', 'admin')
	->addSpecialPermissions(['read_all', 'write_all'])


	->addInherit('admin', 'superadmin')
	->addSpecialPermissions(['lock', 'fill_all']);
	

Cabe notar que los addInherit() deben ir *siempre* antes de los permisos que se quieran agregar al rol heredado. 

El rol de 'guest' debe estar definido con ese nombre o con otro. En caso de que se decida cambiar el nombre del rol guest de 'guest' a otro se debe llamar al método estático setGuest() con el nombre alternativo:

	Acl::setGuest('unregistered');

Además de setear el nombre alternativo es su responsabilidad crear el rol correspondiente con el método addRole()

El Acl genera una representación interna similar a:

	array(4) {
	["guest"]=>
	array(3) {
		["role_id"]=>
		int(-1)
		["sp_permissions"]=>
		array(0) {
		}
		["tb_permissions"]=>
		array(1) {
		["products"]=>
		array(1) {
			[0]=>
			string(4) "read"
		}
		}
	}
	["vendedor"]=>
	array(3) {
		["role_id"]=>
			int(1)
		["sp_permissions"]=>
			array(0) {
			}
		["tb_permissions"]=>
			array(2) {
			["products"]=>
			array(2) {
				[0]=>
				string(4) "read"
				[1]=>
				string(5) "write"
			}
			["foo"]=>
			array(2) {
				[0]=>
				string(6) "create"
				[1]=>
				string(4) "list"
			}
		}
	}
	["admin"]=>
	array(3) {
		["role_id"]=>
		int(100)
		["sp_permissions"]=>
		array(2) {
		[0]=>
		string(8) "read_all"
		[1]=>
		string(9) "write_all"
		}
		["tb_permissions"]=>
		array(1) {
		["products"]=>
		array(1) {
			[0]=>
			string(4) "read"
		}
		}
	}
	["superadmin"]=>
	array(3) {
		["role_id"]=>
		int(500)
		["sp_permissions"]=>
		array(2) {
		[0]=>
		string(8) "read_all"
		[1]=>
		string(9) "write_all"
		}
		["tb_permissions"]=>
		array(2) {
		["products"]=>
		array(1) {
			[0]=>
			string(4) "read"
		}
		["permissions"]=>
		array(2) {
			[0]=>
			string(4) "read"
			[1]=>
			string(5) "write"
		}
		}
	}
	}

Existen dos tipos de permisos que se pueden asignar a los roles:  "resource permissions" y "special permissions".

Los "resource permissions" se aplican sobre las tablas especificadas mientras que los "special permissions" son de caracter más general y definen la posibilidad de realizar ciertas acciones administrativas típicas de un "admin".

Además sobre "resource permissions" existen ciertos permisos "especiales" -no confundir con "special permissions"- que habilitan a leer registros que no le pertenecen al tenedor del rol:  

    show_all	- lee los registros propios y ajenos sobre ese recurso
    list_all	- lista los registros propios y ajenos sobre ese recurso
    read_all	- lista y lee los registros propios y ajenos sobre ese recurso

Estos permisos típicamente se deberían dar a un "guest" para que pueda por ejemplo leer todas las entradas de un blog o las publicaciones de un sitio de ventas. Si por el contrario a un "guest" se le diera un permiso "read" -en vez de "read_all"- entonces podría darse el caso contradictorio de que un "guest" pueda ver las publicaciones de un vendedor y ese mismo vendedor solo pueda ver las suyas propias y no las de otros vendedores.

Por lo anterior se aconseja no dar un permiso "read" a un "guest" sino en todo caso un "read_all" y hacer que directa o interectamente todos los roles deriven de "guest". 

Estos permisos especiales sobre "resource permissions" pueden tener otros usos interesantes como permitirle a un supervisor ver todos los registros de los usuarios y publicaciones de una tienda:

    ->addRole('supervisor', 502)  
    ->addInherit('registered')
    ->addResourcePermissions('users', ['read_all'])  // <--
    ->addResourcePermissions('products', ['read_all'])  // <--


### Permisos

Los permisos sobre los endpoints son en general del tipo CRUD + permiso para listar los recursos: ['show', 'list', 'create', 'update',  'delete']


### Rol de Admin

En lugar de definir de forma monolítica los alcances de un "admin" éste se puede construir a partir de combinaciones de los siguientes permisos especiales asignables a cualquier rol

Ejemplos:

- "lock" - bloquear /besbloquear un registro 
- "lock" - modificar un registro bloqueado
- "lock" - borrar un registro bloqueado. Requiere también de "write_all_trashcan"
- "lock" - borrar definitivamente un registro bloqueado
- "lock" - restaurar (undelete) un registro bloqueado
- "read_all" - acceder a registros de otros usuarios (no incluye los protegidos en folders)
- "read_all" - listar registros de otros usuarios (no incluye los protegidos en folders pero si colecciones)
- "read_all_folders" - acceder a registros en folders que no se nos han compartido 
- "read_all_folders" - listar registros en folders que no se nos han compartido
- "read_all_trashcan" - acceder a  registros de otros en papelera
- "read_all_trashcan" - listar registros de otros en papelera
- "write_all" - modificar / borrar registros de otros usuarios (sin alterar su ownership)
- "write_all_folders" - modificar / borrar registros de otros usuarios en folders (sin alterar su ownership)
- "write_all_trashcan" - borrar definitivamente / restaurar registros de otros usuarios
- "write_all_collections" - escribir los registros de las colecciones de otros usuarios. 
- "transfer" - tranferir un registro o sea cambiar la propiedad (ownership) de un registro (campo belongs_to)
- "fill_all" - modificar la fecha de creación 
- "fill_all" - llenar cualquier campo incluso los no-fillables
- "grant" - conceder roles y permisos

Como colorario es posible tener muchos roles con caracteristicas de un admin o superadmin.


### Permisos a nivel de usuario

Los roles son permisos que se asignan masivamente (por igual) a todos los usuarios que poseen ese rol. Los roles se puden "sumar" obteniendo la suma de los permisos de cada rol.

Si se desea que un usuario particular tenga permisos distintos para una entidad particular que sean distintos de los del rol al que pertenece se pueden especificar "permisos indivuduales" creando un registro para ese usuario y esa tabla referida en la tabla "permissions". Solo puede haber una entrada en "permissions" para cada par (usuario, tabla).

Los cambios en los permisos a nivel de usuario al igual que los roles solo se aplican cuando el usuario "inicia sessión" o sea.. cuando obtiene los tokens y también cuando los tokens son renovados.

Hay distintas tablas y por tanto distintos endpoints para manejar distintos aspectos de los permisos:

    tabla permisions: 
        - show, list, create, update, delete 
        - Son permisos dados por un Admin sobre las tablas para usuarios específicos.

    tabla folder_permissions:
        - read, write
        - Son dados por los usuarios a ciertos usuarios sobre cierto folder de cierta tabla/

    folder_other_permissions:
        - read, write
        - Son dados por los usuarios a otros usuarios (sin especificar su id)
        - Puede especificarse el otorgamiento de permisos a usuarios no-registrados (guest)


# Como agregar / cambiar permisos a nivel de usuario 

Los permisos que "decoran" al o los roles que pueda poseer un usuario se pueden ser para un recurso (tabla) en particular ("resource permissions") o "especiales" (típicamente de roles tipo-admin)

Los permisos sobre recursos se pueden agregar o cambiar desde el endpoint

	/api/{version}/user_tb_permissions

Al listar se vería algo como:

	"data": {
        "user_tb_permissions": [
            {
                "id": 1,
                "tb": "my_table1",
                "can_list_all": null,
                "can_show_all": null,
                "can_list": 1,
                "can_show": null,
                "can_create": null,
                "can_update": null,
                "can_delete": null,
                "user_id": 119,
                "created_by": 119,
                "created_at": "2021-11-19 17:49:40",
                "updated_by": null,
                "updated_at": null
            },
			{
				"id": 5,
                // ...
			},
			// ..
        ]
    },

Para definir permisos sobre una tabla sería como en el siguiente ejemplo.  

Ej:

	{
		"tb": "table_xyz",
		"user_id": 119,
		"can_list": true
	}

Cabe destacar que siempre habrá un solo registro por tabla y que los permisos no se agregan individualmente sino todos los que se deseen setear a la vez y si se repitiera el proceso se sobre-escribiría lo que antes había.

Ej:

Si ahora se hiciera un POST nuevamente sobre /api/{version}/user_tb_permissions	

	{
		"tb": "table_xyz",
		"user_id": 119,
		"can_update": true,
		"can_show": true
	}

El resultado sería que para el "user_id" = 119 y la tabla "table_xyz" se tendrán solamente los permisos reciéntemente definidos para esa tabla y usuario.


Para conocer todos los campos (con distintos tipos de permisos) que se pueden enviar:

	GET /api/{version}/user_tb_permissions?_rules=1


Los permisos "especiales" se trabajan sobre el endpoint

	/api/{version}/user_sp_permissions

Básicamente debe enviar:

	user_id
	sp_permission_id

Ej:

	POST /api/v1/user_sp_permissions

	{
		"user_id": 119,
		"sp_permission_id": 8
	}

Donde para conocer el "sp_permission_id" puede consultar el endpoint:

	/api/v1/sp_permissions


# Posible FrontEnd para los roles y permisos

A un Administrador se le odría presentarse la información sobre roles y permisos así:

Para un usuario:

	roles

		superadmin

	Special permissions

		read_all				[del]
		write_all				[del]	
		read_all_collections	[del]
		write_all_collections	[del]
		read_all_trashcan		[del]
		write_all_trashcan		[del]
		transfer				[del]
		lock					[del]
		impersonate				[del]
		
	[add]
		
	<-- los permisos especiales tienen como base los de su rol o roles y pueden ser decorados via tabla `user_sp_permissions`. Esto significa que lo que "se ve" no es la tabla `user_sp_permissions` sino el resultado de aplicar los permisos combinados de distintos roles y a eso los permisos presentes en la tabla `user_sp_permissions` si los hubiere.	

Para otro usuario:

	roles

		accounting
		supervisor

	Special permissions

		impersonate				[del]
		read_all				[del]	
		
	[add]	

	tb: users					[del]	

	[X]	list_all
	[X]	show_all
	[ ]	list
	[ ]	show
	[ ]	create
	[ ]	update
	[ ]	delete

	tb: sells					[del]

	[X]	list_all
	[X]	show_all
	[ ]	list
	[ ]	show
	[ ]	create
	[ ]	update
	[ ]	delete

	<-- estos permisos sobre-escriben los permisos propios de su rol o roles del usuario y tienen prioridad por sobre los permisos especiales.


# Scopes

En OAuth se habla de "scopes" como simil a permisos en un sentido más abstracto pero se puede hacer corresponder a los permisos individuales de la siguiente forma:
	
	["tb_permissions"]=> {
		["products"]=> [
			"read",
			"write"
		],
		["foo"]=> [
			"read"
		]
	}

equivale a 

	products.read
	products.write
	foo.read


SimpleRest *no* sigue el estándar de scopes de OAuth donde:

    - Los permisos se presentan de forma simple con la notación recurso.operación

    - La granulidad de los permisos suele expresarse para operaciones genéricas como "read", "write" y pueden definirse "alias" para ciertas operaciones como "emails.send" para "emails.create"

    - El desarrollador no "ve" -puede listar- permisos especiales (lo que no significa que no existan) 

https://www.freecodecamp.org/news/best-practices-for-building-api-keys-97c26eabfea9/


# Métodos para indagar sobre permisos y roles

El Acl provee un conjunto de métodos básicos para conocer el rol o los permisos del usuario y puede extender a partir de "paquetes" (service providers).

getEveryPosibleRole()                   Devuelve todos los roles registrados en el ACL.
roleExists($rol)                        Existe el rol?
getRolePermissions($rol)                Devuelve todos los permisos para un determinado rol.
getAncestry($rol)                       Roles de los ancestros de un usuario.
isHigherRole($rol1, $rol2)              Tiene el rol$1 mayor nivel de acceso que $rol2? (2)

isGuest()                               Es un visitante no registrado?
isRegistered()                          Es un usuario que ha entregado credenciales?    
getRoles()                              Rol o roles de usuario.

hasRole($rol)                           El usuario posee ese rol? (no considera herencia)
hasAnyRole([$rol1, ...])                El usuario posee alguno de esos roles? (no considera herencia)   
hasRoleOrHigher($rol)                   Se tiene el rol o uno "superior" (2)
hasAnyRoleOrHigher([$rol1, ...])        Se tiene un rol o uno "superior" (2)

getTbPermissions($table = null)			Retorna permisos sobre recursos (tablas) (1)
getSpPermissions($table = null)			Retorna permisos "especiales" (1)
getFreshTbPermissions($table = null)	Retorna permisos sobre recursos (tablas)
getFreshSpPermissions()					Retorna permisos "especiales"
hasResourcePermission($perm, $tabla)    El usuario tiene permisos explícitos sobre esa tabla?
hasSpecialPermission($permiso)          El usuario tiene ese permiso especial?


Notas:

getTbPermissions() y getSpPermissions() no ofrecen resultados necesariamente actualizados (a diferencia de acceder a los endpoints correspondientes). Si el usuario entregó credenciales via Web Tokens, estos permisos muy probablemente serán derivados del payload del web token.

Para el caso del paquete boctulus\grained_acl se implementan adicionalmente getFreshTbPermissions() y getFreshSpPermissions() que garantizan resultados "frescos" porque acceden directamente a la base de datos.


Actualmente isHigherRole() y hasRoleOrHigher() están implementados en base a el árbol genealógico de roles y no compara permisos lo cual ofrece uh resultado que puede no ser exacto y solo lo será si existe una sola rama sin derivaciones en el árbol genealógico entre los roles a comparar.

Sin embargo, hasAnyRoleOrHigher() ofrece obtener el resultado más preciso a pesar de que no compara permisos sino roles ya que permite comparar no con un rol sino con varios y por ende considerar derivaciones en el árbol genealógico.

Ej:

+
|
----- guest
		|
		|
	registered
		|  |
		|  |
		|  usuario
		|        |
	supervisor   |
	    |        usuario_plus
		|              |
	 superadmin     moderador


Supongamos que en un escenario en particular (ResourceController o API) necesito un rol >= {supervisor o usuario} entonces podría usar hasAnyRoleOrHigher() para chequear esta condición:

	$pass = acl()->hasAnyRoleOrHigher(['supervisor', 'usuario_plus']);

Sin embargo podría querer saber si el usuario tiene los mínimos permisos que otorga un rol, entonces hasAnyRoleOrHigher() no ofrecerá exactamente lo que se necesita.

Entonces se *implementará* hasRolePermissionsOrHigher() y esta función podrá considerar derivaciones en el árbol genealógico.

La función Acl::hasRolePermissionsOrHigher() *deberá* tener en consideración todos los tipos de permisos, ya sea sobre recursos (tablas) y los considerados permisos "especiales". También deberá considerar los permisos que "decoran" los de los roles para un usuario en particular (!)


# Implementación de "paquetes" para el Acl

Es importante resaltar que dado que la clase Acl se serializa por motivos de performance la mayor parte de las propiedades y métodos no pueden ser estáticos ya que propiedades estáticas no pueden ser serializadas y al des-serializar no estarán disponibles llevando a muchos dolores de cabeza. Igualmente por concistencia se desaconseja el uso de métodos estáticos.

Al implementar un service provider para el ACL se debe cumplir de mínima con la interfaz IAcl.


# Controladores tipo "resource"

Una API se crea típicamente extendiendo la clase ApiController y esta clase a su vez extiende de otra llamada ResourceController que es la que tiene acceso a los autenticación via web tokens y por ende tiene disponible también los métodos para indagar permisos y roles.

Es imporante notar que dado que el *AuthController* o sea el componente responsable de verificar que el usuario haya entregado credenciales (autenticación) y sean correctas (autorización) está versionado entonces es necesario explicitar la versión de api a fin de que encuentre la clase.

Ej:

    class DumbAuthController extends ResourceController
    {
        function __construct()
        {
            global $api_version;
            $api_version = 'v1';

            parent::__construct();

            if (!acl()->hasAnyRole(['supervisor', 'admin'])){
                response()->error('Unauthorized!!!', 401);
            }
        }

        // ...

    }


### Folders

Sobre cada recurso se pueden crear espacios virtuales separados llamados "folders" a los cuales se les pueden establecer permisos para que otros usuarios los visualicen. 

Los folders no tienen nada que ver con el sistema de archivos sino que representan un conjunto de registros de una entidad particular sobre los que se pueden establecer permisos de forma unificada. 

Cada folder existe como un registro distinto en la tabla "folders" y se asocia con una determinada entidad (productos, usuarios, etc) y con un campo en esa entidad conteniendo un valor específico. Para cada endpoint se define el nombre del campo que se asocia al folder, ejemplo:


	class Products extends MyApiController
	{ 
	    protected $folder_field = 'workspace';

	    function __construct()
	    {       
	        parent::__construct();
	    }	        
	} 

El campo $folder_field almacena el nombre del campo que en el ejemplo es "workspace".

Para acceder a un folder se especifica el id del folder y otros usuarios pueden entonces listar o visualizar recursos que se le hayan compartido.

	GET /api/v1/v1/products?folder=1

Por supuesto pueden aplicarse otros filtros:

	GET /api/v1/products?folder=1&cost=200

Y puede visualizarse un registro en particular (ej: 124) para el que no tendríamos permiso si no especificamos el folder:

	GET /api/v1/products/124?folder=1		

<-- si el folder se nos ha "compartido" por medio de permisos y no se especifica entonces el registro no se hallará devolviendo 404 (Not Found).

Un usuario con rol de administrador en principio obtendrá todos los registros para un endpoint incluidos los que pertenecen a folders privados de otros usuarios:

	GET /api/v1/products

<-- obtiene todos los registros indiscriminadamente

Sin embargo también puede filtrar a un folder en particular:

	GET /api/v1/products?folder=57

Los permisos para los folders se conceden creando entradas en la tabla folder_permissions y es importante notar que debe darse explícitamente permiso al owner (así como a los otros usuarios) para que éste ver registros dentro de ese folder.

Obviamente cada usuario puede listar, editar o borrar sus folders usando el endpoint /api/v1/folders

Igualmente cada usuario puede hacer CRUD sobre los permisos de "grupo" y para "otros" a través de sus respectivos endpoints /api/v1/FolderPermissions y /api/v1/FolderOtherPermissions respectivamente de modo de permitir a otros miembros acceso de lectura y/o escritura de sus registros.

Para crear un registro en un folder del que se ha concedido permiso de escritura se incluye como campo el id del "folder". Ej:

	POST /api/v1/products

	{
		"name": "Supreme jugo",
	    "description": "de manzanas exprimidas",
	    "size": "1L",
	    "cost": "250",
	    "folder": "8"
	}

O bien se especifica en el "campo clave" que hace identifica al folder, en nuestro caso llamado "workspace" con el valor que corresponda para el folder:

	{
		"name": "Supreme jugo",
	    "description": "de manzanas exprimidas",
	    "size": "1L",
	    "cost": "250",
	    "workspace": "lista10"
	}

En el primer caso, si se especifica un folder pero no tenemos acceso recibiremos un mensaje de error como:

	{
	    "error": "You have not permission for the folder 8"
	}

En el segundo caso donde especificamos "workspace": "lista10" en vez de "folder": "8", si el folder no existe no habrá advertencia alguna pues solo estamos creando un registro con esa combinación de campos y distintos usuarios pueden tener folders con el mismo nombre así que no hay problema.

Es importante entender que cuando creamos un registro dentro de un folder que no nos pertenece (porque se nos da permiso de escritura), el registro tampoco será de nuestra propiedad aunque podremos leerlo y escribirlo siempre que tengamos los permisos para ello.

Igualmente para modificar un registro de otro usuario que nos ha compartido su folder especificamos el id del folder:

	PUT /api/v1/products/136

	{
	    "name": "Vodka venezolano",
	    "description": "de Vzla",
	    "size": "1L",
	    "cost": "15",
	    "folder": "1"
	}

Mismo para borrar un registro perteneciente a un folder es necesario estar "dentro" haciendo referencia al folder en cuestión:

	DELETE /api/v1/products/136

	{
    	"folder": "1"
	}


Nota: el acceso a los folders se chequea en base de datos cada vez que se hace un request especificando que el recurso se halla en un folder. No es necesario esperar a que se renueven los tokens para tener acceso a un folder al cual se nos ha concedido permisos. <-- podría cambiarse para incrementar la performance !!!

Similarmente a lo que sucede con Model, la clase ApiController también aporta event hooks en particular para los folders los siguientes:


    public function onGettingFolderBeforeCheck($id, $folder){ } 
    public function onGettingFolderAfterCheck($id, $folder){ }
    public function onGotFolder($id, $total, $folder){ }

    public function onDeletingFolderBeforeCheck($id, $folder){ }
    public function onDeletingFolderAfterCheck($id, $folder){ }
    public function onDeletedFolder($id, $affected, $folder)

    public function onPostingFolderBeforeCheck($id, $data, $folder){ }
    public function onPostingFolderAfterCheck($id, $data, $folder){ }
    public function onPostFolder($id, $data, $folder){ }

    public function onPuttingFolderBeforeCheck($id, $data, $folder){ }
    public function onPuttingFolderAfterCheck($id, $data, $folder){ }
    public function onPutFolder($id, $data, $folder, $affected){ }
       

Desde cualquiera de esos métodos es obviamente posible acceder a métodos y propiedades de visibilidad por lo menos protected de la clase Model y en particular a folder y id (del registro). Ej:

	function onGettingFolderBeforeCheck($id, $folder) {
        echo "Reading folder {$folder} with id={$id}";
    }

Un uso práctico de estos hooks sería con onGettingFolderBeforeCheck() implementar la funcionalidad de conceder acceso a un folder siguiendo un enlace que como parámetro puede tener un token. Si el token es válido se concede el acceso al usuario que sigue el enlace insertando el permiso correspondiente en la tabla folder_permissions.

Ej: <pseudocódigo>

	function onGettingFolderBeforeCheck() {

        if ($this->isGuest()){
            // Informar que debe estar "logueado"
            return;
        }

        if ($this->isAdmin()){
            return;
        }

        $token = \simplerest\libs\Factory::request()->getQuery('token');
    
        // decodificar token y si es válido proseguir
        
        $uid = $this->auth['uid'];

        // insertar en la tabla folder_permissions el permiso para el usuario con id $uid`
        // y el folder  $folder
    }


### Soft delete y la papelera

En cada endpoint se puede definir si se habilita el "soft" delete mediante la propiedad $soft_delete en la api. Ejemplo:

class Products extends MyApiController
{ 
	// solo hard delete
    protected $soft_delete = false;

    // ...


La única forma de visualizar registros borrados de forma "suave" así como recuperarlos o borrarlos definitivamente es mediante la papelera con la ventaja de que ésta tiene sus propios permisos.


### La Papelera

Cuando un registro es marcado como borrado aparece en trash_can, la papelera de reciclaje, que brinda la posibilidad de gestionar todas las operaciones sobre elementos eliminados.

Para ver elementos en la papelera

	GET /api/v1/trash_can?entity=products
	GET /api/v1/trash_can/157?entity=products


Para hacer un "undelete" de un recurso se hace un PATCH o PUT sobre el trash_can

	PATCH /api/v1/trash_can/157	

	{
		"entity": "Products",
		"trashed": false
	}

* por concistencia, se admite que 'entity' sea especificado en headers, en la query de la url o bien en el body en cualquier caso.

Para eliminar *permanentemente* un recurso se realiza un DELETE sobre el elemento en la papelera:

	DELETE /api/v1/trash_can/157

	{
    	"entity": "Products"
	}

La papelera acepta los mismos filtros y los resultados se pueden ordenar igual que con cualquier entidad:

	GET GET /api/v1/trash_can?entity=Products&orderBy[deleted_at]=DESC


### Colecciones

Para realizar acciones masivas se recomienda crear colecciones. Por ejemplo si quisiera afectar 3 registros:

	POST /api/v1/collections

	{
		"entity": "products",
		"refs": [198,199,200]
	}

Luego si por ejemplo quiero realizar una edición masiva de un campo "enabled" poniéndolo en 1 en toda la colección 

	PATCH /api/v1/collections/2

	{
		"cost": "99"
	}

Para borrar masivamente

	DELETE /api/v1/collections/9

Cabe destacar que las operaciones PATCH y DELETE se efectuan sobre los registros contenidos en la colección de sus respectiva entidad o dicho de otro modo un DELETE sobre una colección no borra solo el registro de la colección sino los registros asociados + el registro de la colección.

Por lo anterior en un PATCH sobre una colección no es posible modificar "refs" ni el "id" de la colección via endpoint.

Son seguras las colecciones?

  - NO debería poder crear una colección de registros que no me pertenecen sino soy "admin" o tengo los permisos correspondientes ? -> no importa porque la verificación se hace al mommento de intentar afectar los registros de la colección.
  - No debería evitarse poder crear colecciones sobre registros inexistentes ? -> no importa porque al momento de hacer el PATCH o el DELETE sobre la colección solo se afectarán los registros existentes.   
  - No deberían poder crearse dos colecciones iguales (mismos registros, misma tabla) -> no importa porque tanto PATCH como DELETE son idempotentes.
  - El permiso write_all no se queda corto si las colecciones se llegaran a crear sobre roles, user_roles, sp_permissions, tb_permissions, folders, folder_permissions, other_folder_permissions, etc ? SI! y por eso se restringe y no se dejan crear colecciones sobre esas tablas.


Filtrar colecciones

	GET /api/v1/collections?entity=documents


### Convención de nombres 

Recomendamos separar las palabras con guión bajo (_) en los nombres de las entidades. Ejemplo:

/api/v1/super_cool_table
/api/v1/trash_can?entity=super_cool_table
etc.

En vez de usar:

/api/v1/SuperCoolTable
/api/v1/TrashCan?entity=SuperCoolTable
etc


### Registros bloqueados

El admin puede colocar un "lock" sobre registros impidiendo que:

- Puedan ser modificados por el propietario. Le arrojará un código 403. 
- No puedan ser borrados. Le arrojará un código 403. 
- No puedan ser vistos en la papelera por el propietario. Le arrojará un codigo 403. 
- No puedan ser recuperados por el propietario. Le arrojará un código 403. 
- No puedan ser borrados permanentemente por el propietario cuando se hayan en la papelera. 

Cuando un registro es borrado por el Admin éste es bloqueado para el usuario propietario evitando así que pueda modificarlo, recuperarlo o borrarlo permanentemente.

Implementación:

Una entidad correspondiente a un endpoint si contiene un campo 'is_locked' de tipo "bool" (TINYINT para Mysql) entonces queda habilitada para el mecanismo de "bloqueo".


### Seguridad 

Es muy importante tener buen criterio al momento de entregar permisos ya que es potencialmente posible lograr escalarlos manipulando las tablas de permisos, etc.


# APIs Restful

Por cada entidad (normalmente una tabla en la DB) existe un único endpoint de la forma /api/{version}/nombre_entidad sobre el que se puede hacer un get, post, put, patch y delete donde v1 es la versión de la API pero podría ser otra.

Adicionalmente para los usuarios existe un endpoint adicional /api/{version}/me que permite obtener información útil y realizar operaciones que en determinadas circunstancias no es posible sobre una url como /api/v1/users/:id

Los endpoints se sirven mediante clases que extienden a ApiController, un tipo de ResourceController.

Un usuario (sin ser Admin pero con los permisos correctos) podría crear otros usuarios y éstos le pertencerán así que podrá visualizarlos o modificarlos a su gusto pero como consecuencia de la implementan del ACL, el campo belongs_to apuntará al "creador" y como consecuencia el propio usuario podría no tener permisos suficientes para mpdificar sus propios datos personales. Este problema se soluciona al utilizar el endpoint /api/v1/me

Otro endpoint adicional es /api/v1/trash_can que corresponde a una papelera de registros y se explica en la sección correspondiente. 


# Funcionalidad out-the-box de la API

## GET <READ>

    GET /api/v1/products
    GET /api/v1/products/83

### Search    

    GET /api/v1/products?name=Vodka
    GET /api/v1/products?name=Vodka&size=1L

IN / NOT IN

    GET /api/v1/products?name=Vodka,Wisky,Tekila
    GET /api/v1/products?name[in]=Vodka,Wisky,Tekila
    GET /api/v1/products?name[notIn]=CocaCola,7up

### String comparisons   

    contains 
    notContains 
    startsWith  
    notStartsWith
    endsWith   
    notEndsWith
    
Example

    GET /api/v1/products?name[contains]=jugo 

### Other comparators

    =    eq
    !=   neq
    >    gt
    <    lt
    >=   gteq
    <=   lteq

Example:  
    
    GET /api/v1/products?cost[gteq]=25&cost[lteq]=100

### BETWEEN

    GET /api/v1/products?orderBy[cost]=ASC&cost[between]=200,300
    GET /api/v1/products?created_at[between]=2019-10-15 00:00:00,2019-09-01 23:59:59

### List of fields to include

    GET /api/v1/products?fields=id,name,cost
    GET /api/v1/products/83?fields=id,name,cost
    GET /api/v1/products?fields=id,cost&name=Vodka

### Exclude fields

    GET /api/v1/users?exclude=firstname,lastname

### Select null or not null values

    GET /api/v1/products?description=NULL
    GET /api/v1/products?description[neq]=NULL

# Pagination

### ORDER BY

    GET /api/v1/products?orderBy[cost]=DESC
    GET /api/v1/products?orderBy[cost]=DESC&order[name]=ASC
    GET /api/v1/products?orderBy[cost]=ASC&order[id]=DESC

### LIMIT

    GET /api/v1/products?limit=10
    GET /api/v1/products?offset=40&limit=10
    GET /api/v1/products?limit=10&order[name]=ASC&order[cost]=DESC&size=2L

Pagination can be done with page and pageSize

    GET /api/v1/products?page=3
    GET /api/v1/products?pageSize=20&page=2

Response is an array of rows that include a paginator with navigation information:

{
    "data": [
        {
            "id": "126",
            "name": "Uvas fermentadas",
            "description": "Espectacular",
            ...
        },
        {
            "id": "131",
            "name": "Vodka",
            "description": "de Estados Unidos!",
            ...
        },
        ...
    ],
    "error": "",
    "error_detail": "",
    "paginator": {
        "pages": 7,
        "nextUrl": "http://simplerest.lan/api/v1/products?pageSize=10&page=2"
    }
}
    
# Aggregate Functions – Average, Count, Sum, Max and Min

Examples:

	GET /api/v1/products?props=min(cost)
	GET /api/v1/products?size=1L&props=avg(cost)

Response is something like:

{
    "data": {
        "AVG(cost)": "191.0714"
    },
    "error": "",
    "error_detail": ""
}

Note that if the field on which you want to calculate is not specified, it is not performed and no error is throw. In the case of count() function if you don't want to specify a field you must pass * as a parameter:

	GET /api/v1/products?props=count(*) as cant
	

Or with an alias

	GET /api/v1/products?size=1L&props=avg(cost) as media

# Grouping

	GET /api/v1/products?props=count(*) as cant&groupBy=size&fields=size

Example of Response:

{
    "data": [
        {
            "size": "",
            "cant": "21"
        },
        {
            "size": "0.5L",
            "cant": "2"
        },
        ...
    ],
    "error": "",
    "error_detail": ""
}

Note: when groupBy is used, you should specify the fields to be selected. 

With having

	GET /api/v1/products?groupBy=size&fields=size&props=avg(cost)&having=avg(cost)>=150

Having with alias 

	GET /api/v1/products?groupBy=size&fields=size&props=avg(cost) as average&having=average>=150

### Pretty print 

    GET /api/v1/products?pretty

By default pretty print can be enabled or disabled in config/config.php    


## POST <CREATE>

    POST /api/v1/products

    {
        "name": "Vodka",
        "description": "from Bielorussia",
        "size": "2L",
        "cost": "200"
    }

## DELETE

    DELETE /api/v1/products/100

A record can be effectly deleted in one shot from database or if soft-delete is enabled then be marked as deleted in which case it will be seen as deleted as well.

When a record is softly deleted then it can be seen at trash_can where is posible to delete it permanently or to be recovered.


## PUT  <UPDATE>

    PUT /api/v1/products/84

    {
        "name": "Vodka",
        "description": "from Russia",
        "size": "2L",
        "cost": "200"
    }


## PATCH <PARTIAL UPDATE>

    PUT /api/v1/products/84

    {
        "description": "from Mongolia",
        "cost": "230"
    }

# El endpoint /me

The simple way to perform CRUD operations on the current user is using /api/v1/me endpoint.

    GET /api/v1/me

    {
        "data": {
            "id": "4",
            "username": "pbozzolo",
            "email": "pbozzolo@gmail.com",
            "confirmed_email": "1",
            "firstname": "Paulinoxxxy",
            "lastname": "Bozzoxxxy",
            "deleted_at": null,
            "belongs_to": "0"
        },
        "error": "",
        "error_detail": ""
    }

Si se hace un DELETE sobre /me el usuario sufre un borrado (lógico) pero si se quiere des-activar la cuenta puede usarse PATCH:

Desactivar cuenta

	PATCH /api/v1/me

	{
		"is_active": 0
	}

Ahora al intentar renovar el token o loguearse, se informará que la cuenta está "pendiente de activación".


### Las respuestas de la API

Una respuesta exitosa a un GET presenta un campo 'data' en la respuesta:

{
    "data": {
        "id": "185",
        "name": "ABC",
        "description": "",
        "size": "",
        "cost": "0",
        "created_at": "2019-11-03 23:55:18",
        "updated_at": null,
        "deleted_at": null,
        "is_locked": "0",
        "workspace": null,
        "belongs_to": "132"
    },
    "error": "",
    "error_detail": ""
}

En cambio una respuesta que contiene un error, puede o no poseer cuerpo pudiendo ser solo el código de estaus http o bien incluir también un cuerpo con los campos "error" y "error_detail"

{
    "error": "Not found",
    "error_detail": "Register for id=1850 doesn't exist"
}

### created_by=me, update_by=me o belongs_to=me

Puede darse el caso de que un usuario sea el owner de ciertos registros pero que no hayan sido creados por él sino por otro usuario con permisos (por ejemplo un Admin).

Es posible filtrar facilmente los registros creados, actualizados o pertenecientes al usuario que hace el request colocando 'me' en lugar del id del propio usuario. 

Ejemplos:

GET /api/v1/products?created_by=me
GET /api/v1/products?created_by[neq]=me
GET /api/v1/products?belongs_to[neq]=me
GET /api/v1/products?belongs_to=90,me,1  
GET /api/v1/products?belongs_to[notIn]=90,me,1
...
GET /api/v1/userRoles?belongs_to=me
...


# Method override

Si en el servidor estuvieran desactivados PUT, PATCH o DELETE aún es posible utilizarlos haciendo un "method override".

If your REST client does not support certain requests, you can use the X-HTTP-Method-Override header:

PUT = POST + X-HTTP-Method-Override: PUT
PATCH = POST + X-HTTP-Method-Override: PUT
DELETE = GET + X-HTTP-Method-Override: DELETE

Alternatively, you can also override the HTTP method by using the _method query string parameter.

GET /api/v1/products/126?_method=patch
GET /api/v1/products/126?_method=put
GET /api/v1/products/126?_method=delete


#  Funciones agregativas

Es posible calcular directamente en la base de datos las funciones min(), max(), avg() y sum() sobre el campo especificado.

Ejemplos:

GET /api/v1/products?props=count(*)
GET /api/v1/products?props=count(description)
GET /api/v1/products?props=sum(cost)
GET /api/v1/products?size=2L&props=avg(cost)
GET /api/v1/products?size=2L&props=avg(cost) as prom
GET /api/v1/products?size=2L&props=sum(cost) as suma
etc.


# Archivos

Se pueden subir archivos al servidor:

POST /api/v1/files 

<-- como "form-data". Admite múltiples archivos en el mismo request.

Resultando en

{
    "data": {
        "uploaded": [
            {
                "filename": "65394374_10158090117128840_7189038881361100800_o.jpg",
                "id": "240",
                "link": "/download/get/240"
            },
            {
                "filename": "78372400_3426368247403784_5430079366526664704_n.jpg",
                "id": "241",
                "link": "/download/get/241"
            }
        ],
        "failures": []
    },
    "status_code": 201,
    "error": "",
    "error_detail": ""
}

Los archivos se pueden filtrar por múltiples criterios, por ejemplo: extensión

GET /api/v1/files?file_ext=jpg

{
    "data": [
        {
            "id": "240",
            "filename": "65394374_10158090117128840_7189038881361100800_o.jpg",
            "file_ext": "jpg",
            "filename_as_stored": "90-5f5bb828cb06c3.52751786.jpg",
            "belongs_to": "90",
            "guest_access": "0",
            "is_locked": "0",
            "created_at": "2020-09-11 14:47:20",
            "deleted_at": null
        },
        {
            "id": "241",
            "filename": "78372400_3426368247403784_5430079366526664704_n.jpg",
            "file_ext": "jpg",
            "filename_as_stored": "90-5f5bb828e85fe4.62412332.jpg",
            "belongs_to": "90",
            "guest_access": "0",
            "is_locked": "0",
            "created_at": "2020-09-11 14:47:21",
            "deleted_at": null
        }
    ],
    "status_code": 200,
    "error": "",
    "error_detail": "",
    "paginator": {
        "total": 2,
        "count": 2,
        "currentPage": 1,
        "totalPages": 1,
        "pageSize": 10,
        "nextUrl": "null"
    }
}

Borrar un archivo 

	DELETE /api/v1/files/{uuid}


# Modelos y esquemas (schemas)

Modelos y schemas se mantienen separado en distintos archivos. El comando 'make' crea modelos y schemas mientras que el comando 'migrate' impacta en la DB reflejando cambios en los schema.

 
   								   Api Rest   
	  	  [make]                      |
	DB ------------> Schema           |
							<------ Model (Query Model) <---- ORM
	 	  migration		
	   <------------           


make migration --table=books
make schema books
make model books

	
# Make 

Para generar modelos, controladores y apis se utiliza el comando make de la siguiente forma: 

	php com make schema SuperAwesome [-f | --force]
    php com make schema super_awesome  [-f | --force] [ --from:db_connection ]

    php com make model SuperAwesomeModel  [-f | --force]
    php com make model SuperAwesome [-f | --force]
    php com make model super_awesome  [-f | --force] [ --from:db_connection ]

    php com make controller SuperAwesome  [-f | --force]

    php com make api SuperAwesome  [-f | --force]
    php com make api super_awesome  [-f | --force]

    php com make any SuperAwesome  [-s | --schema ] 
                            [-m | --model] 
                            [-c | --controller ] 
                            [-a | --api ] 
                            [-f | --force]

	php com make constants

	php com make pivot_scan


Notas:

- Al crear todos los esquemas con la opción "all" implícitamente se correrá el comando que crea el esquema para las tablas puente Pivots.php 

- La creación de "constantes" está relacionada con los mensajes de error del sistema y su Internacionalización.


# Ayuda 

El comando "make" tiene una ayuda que es invocada cuando no se pasan parámetros:

	$ php com make


Ejemplos:
    
    php com make any baz -s -m -a -f

Lo anterior es equivalente a:

	php com make any baz -samf

Solo existen (hasta ahora) los atajos -sam y -samf pero Ud. puede hacer las combinaciones que quiera con "any"

	php com make any baz -s -m -a -f
	php com make any baz -s -m
	php com make any baz -m -s
	php com make any baz -a -f
	php com make any baz -a -s
	...

# Especificar la ruta de un controlador 

Para controladores es posible especificar una ruta interior a apps\controllers

Ej:

	php index.php make controller sub1\a\this

El comando anterior creará ThisController dentro de pps\controller\sub1\a\

# Especificar la conexión de base de datos para un Modelo

Para generar schemas o models de una DB que no es la default se debe especificar la conexión. Ej:

	php com make schema cotizaciones --from:db3
	php com make model cotizaciones --from:db3

# No sobre-escribir archivos

Es posible ignorar archivos para evitar sean sobre-escritos colocando el nombre del controlador, api resful controller, modelo o esquema en el siguiente archivo en /apps:

	.make_ignore

Ejemplo:

	models\UsersModel.php
	models\FilesModel.php
	\schemas\FooSchema.php
	# models\CollectionsModel.php
	models\ProductsModel.php
	controllers\UsersController.php
	controllers\sub1\a\OpsController.php
	ProductsController.php

Puede observarse que:

	- Se pueden especificar rutas relativas a /app
	- Se pueden especificar solo los nombres de los archivos -sin ruta-
	- Se pueden anular los ignore comentando la línea con una #almohadilla 
	

Nota: no se recomienda ignorar los schemas ya que si bien se puede hacer un "unignore" con la opción --unignore puede ser muy complicado de descubrir la fuente del error.

Ej:

	Fatal error: Uncaught Error: Class '\simplerest\\schemas\main\FilesSchema' not found
 

# Migrations

Los archivos de migraciones son creados con el comando "make migrate" o "migrations make":

	$ php com migrations make create_cables
o
	$ php com make migration create_cables

Es posible especificar el directorio donde se quiere crear la migración con la opción --dir=

	$ php com make migration create_cables --dir=my_folder

Ej:

	$ php com make migration create_cables --dir=my_folder/sub

Notar que en sistemas UNIX / Linux, la "\" escapa caracteres así que si se quisiera usar la el directory separator de Windows (/) tendría que entre-comillarse:

	$ php com make migration create_cables --dir='my_folder\sub'


Es opcional especificar el "name" como primer parámetro en "make migration" o "migrations make" si se especifica la tabla o la clase.

Es válido:

	php com make migration books [ otros parámetros ]
	php com make migration --dir=test --name=books
	php com make migration --class_name=Books
	php com make migration --table=books
	php com make migration --class_name=BooksRenameColumn --table=books
	etc.

# Directorios

Es posible crear migraciones en directorios y sub-sub-directorios.

Ej:

	php com make migration  --dir=test/sub/sub2 --name=books


# Estructura de los archivos de migraciones

Los archivos creados por "make migration" implementan la interface IMigration y en si poseen dos métodos que pueden considerarse "hooks": up y down

	public function up()
    {   
		// ...
	}

	public function down()
    {   
		// ...
	}

Lo que se coloque en up() es corrido durante la migración mientras que el código en down() es ejecutado al hace un "rollback".

Es importante notar que la migración se ejecutará sobre la conexión de base de datos activa la cual se puede setear desde la misma migración ya sea en el constructor o bien en los métodos up() y down()

	public function up()
    {   
        DB::getConection('some_conn_id');

		// ..
	}

Puede que exista un escenario donde se prefiera no hacer el seteo de la conexión dentro de la migración. 

Al momento de crear la migración (con "make migration") hay parámetros que se pueden pasar:

--to=   (conexión a la db)
--table= 
--class_name=
etc

Si se especifica --to={some_conn_id}  entonces se agregará automáticamente el seteo a la conexión en el método up()

public function up()
{   
	DB::getConnection({some_conn_id});

	// ..
}


# Schema Builder 

Básicamente hay dos grandes funcionalidades que residen en la clase Schema: crear tablas y alterarlas.

	Schema::create() 		realiza un CREATE TABLE
	Schema::change()		realiza un ALTER TABLE

Además Schema::alter() es un alias de Schema::change() por lo que pueden usarse indistintamente,


Ej:

Un "CREATE TABLE" dentro de una migración:

	function up()
	{
		sc = (new Schema('facturas'))

        ->setEngine('InnoDB')
        ->setCharset('utf8')
        ->setCollation('utf8_general_ci')

        ->integer('id')->auto()->unsigned()->pri()
        ->int('edad')->unsigned()
        ->varchar('firstname')
        ->varchar('lastname')->nullable()->charset('utf8')->collation('utf8_unicode_ci')
        ->varchar('username')->unique()
        ->varchar('password', 128)
        ->char('password_char')->nullable()
        ->varbinary('texto_vb', 300)

        // BLOB and TEXT columns cannot have DEFAULT values.
        ->text('texto')
        ->tinytext('texto_tiny')
        ->mediumtext('texto_md')
        ->longtext('texto_long')
        ->blob('codigo')
        ->tinyblob('blob_tiny')
        ->mediumblob('blob_md')
        ->longblob('blob_long')
        ->binary('bb', 255)
        ->json('json_str')

        
        ->int('karma')->default(100)
        ->int('code')->zeroFill()
        ->bigint('big_num')
        ->bigint('ubig')->unsigned()
        ->mediumint('medium')
        ->smallint('small')
        ->tinyint('tiny')
        ->decimal('saldo')
        ->float('flotante')
        ->double('doble_p')
        ->real('num_real')

        ->bit('some_bits', 3)->index()
        ->boolean('is_active')->default(1)
        ->boolean('paused')->default(true)

        ->set('flavors', ['strawberry', 'vanilla'])
        ->enum('role', ['admin', 'normal'])

        ->time('hora')
        ->year('birth_year')
        ->date('fecha')
        ->datetime('vencimiento')->nullable()->after('num_real') /* no está funcionando el AFTER */
        ->timestamp('ts')->currentTimestamp()->comment('some comment') // solo un first

        ->softDeletes() // agrega DATETIME deleted_at 
        ->datetimes()  // agrega DATETIME(s) no-nullables created_at y deleted_at

        ->varchar('correo')->unique()

        ->int('user_id')->index()
        ->foreign('user_id')->references('id')->on('users')->onDelete('cascade')
        ->foreign('user_id')->references('id')->on('users')->constraint('fk_uid')->onDelete('cascade')->onUpdate('restrict')
    
        $res = $sc->create();	
	}
	

De Laravel se hereda la sintaxis 

	->foreign()
	->references()
	->on()
	->constraint()
	->onDelete()
	->onUpdate()

Sin embargo a muchos les puede resultar confusa así que se han creado alias y de hecho se recomienda la siguiente sintaxis:

	->fromField()
	->toField()
	->onTable() 
	->constraint()
	->onDelete()
	->onUpdate()
o
	->fromField()
	->toField()
	->toTable() 
	->constraint()
	->onDelete()
	->onUpdate()

El uso de constraint() es opcional como así también onDelete() y onUpdate()

Es posible debuguear el SCHEMA a ser creado:

	d($sc->getSchema(), 'SCHEMA');
    d($sc->dd(true), 'SQL');

El método Schema::getSchema() devuelve la representación interna.

Ej:

Un "ALTER TABLE" dentro de una migración:
	
	function up(){
		$sc = new Schema('tbl_producto');
	
		$res = $sc
		->foreign('unm_intIdUnidadMedida')
		->references('unm_intId')
		->on('tbl_unidadmedida')
		->onDelete('cascade')
		->onUpdate('restrict')
		->change();
	}


# Debugging de Schema

Si se deseara "debuguear" y conocer el SQL resultante se puede usar el método dd() sobre la instancia del Schema
	
Ej:

	$sc = new Schema('boletas');

	$sc->field('f1')->primary();
	$sc->field('f2')->primary();
	$sc->alter();

	/*
		Debugging
	*/

	d($sc->getSchema(), 'SCHEMA');
	d($sc->dd(true), 'SQL');

Es posible *evitar* que se ejecute la migración llamando previamente a dontExec() 

Ej:

	$sc = new Schema('boletas');

	$sc->field('f1')->primary();
	$sc->field('f2')->primary();
	$sc->dontExec();  // <--- before alter() or create()
	$sc->alter();

	/*
		Debugging
	*/

	d($sc->getSchema(), 'SCHEMA');
	d($sc->dd(true), 'SQL');


# El comodín field()

Hay casos donde no tiene mucho sentido dar la definición si el objetivo es borrar ya sea el campo o un atributo de éste y en tal caso es más conveniente siemplemente hacer referencia al campo con field()

Ej:

	$sc = new Schema('boletas');
	$sc->varchar('lastname')->dropNullable();
	$sc->alter();


En vez de lo anterior, lo mejor sería hacer:

	$sc = new Schema('boletas');
	$sc->field('lastname')->dropNullable();
	$sc->alter();

Un ejemplo más completo de los casos útiles para field() sería:

	$sc = new Schema('bar');
	$sc->field('c1')->unsigned()->primary()->auto();
	$sc->field('c2')->primary();
	$sc->field('c3')->nullable();
	$sc->field('c4')->dropNullable();
	$sc->field('c5')->zeroFill();
	$sc->field('c6')->binaryAttr();
	$sc->field('c7')->dropAttr();
	$sc->alter();

En ningún caso era necesario definir el campo para alterarlo.


# Transacciones dentro de migraciones

Cada migración debe ejecutarse en su totalidad pues debe poder revertirse con lo cual no puede quedar en un estado "intermedio" o parcial de operaciones.

Por tanto, si se va a efectuar más de una operación sobre la base de datos, deben usarse transacciones.

Ej:

	DB::transaction(function(){
		$table = ('tbl_estado');
		$nom = 'est';

		$sc = (new Schema($table))

		->setEngine('InnoDB')
		->setCharset('utf8')
		->setCollation('utf8_general_ci')

		->integer($nom.'_intId')->auto()->pri()
		->varchar($nom.'_varNombre', 100)->comment('hashed')
		->varchar($nom.'_varIcono', 150)->comment('hashed')
		->varchar($nom.'_varColor', 150)->comment('hashed')
		->datetime($nom.'_dtimFechaCreacion')->default('current_timestamp')
		->datetime($nom.'_dtimFechaActualizacion')->default('current_timestamp');

		$res = $sc->create();

		table($table)
		->insert([
			array('est_varNombre'=>'Activo', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),             
			array('est_varNombre'=>'Inactivo', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),              
			array('est_varNombre'=>'Rechazado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                 
			array('est_varNombre'=>'Pendiente', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                 
			array('est_varNombre'=>'Terminado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                 
			array('est_varNombre'=>'En Proceso', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                  
			array('est_varNombre'=>'Anulado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                   
			array('est_varNombre'=>'Revision', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA'),                   
			array('est_varNombre'=>'Aprobado', 'est_varIcono'=> 'NA', 'est_varColor'=> 'NA')
		]); 
	});


# Ejecutar sentencias SQL en "raw" 

Ej:

	DB::statement("ALTER TABLE tbl_bodega ADD CONSTRAINT FK_bod_idActualizador FOREIGN KEY (usu_intIdActualizador)  REFERENCES tbl_usuario (usu_intId);");


# CREATE TABLE IF NOT EXISTS

Al momento de llamar al método Schema::create() es posible pasar un boolean que indica si la tabla debe crearse solo si existe y también existe el alias Schema::createIfNotExists()  


# Ejecutar migraciones

Para ejecutar las migraciones pendiente es con "migrations migrate"

	$ php com migrations migrate

	Migrating '2020_10_28_161483_create_cables.php'
	Migrated  '2020_10_28_161483_create_cables.php' --ok
	Migrating '2020_10_28_161757_create_cable_categories.php'
	Migrated  '2020_10_28_161757_create_cable_categories.php' --ok

Es posible especificar el archivo concreto y/o directorio para un "migrations migrate" y un "migrations rollback"

Ej:
	php com migrations migrate --dir=test --file=2021_12_06_35047920_boletas.php --to:my_db_conn

o

	php com migrations migrate --file=test/2021_12_06_35047920_boletas.php --to:my_db_conn


Los parámetros --dir= y --file= se pueden usar separados, juntos o puede haber casos donde no sean necesarios (ej: sino hay directorio o se quiere ejecutar todo el directorio completo). 


# Ejecutar migraciones por pasos

Es posible ejecutar migraciones, una a una o solo unas pocas por ejemplo para debuguearlas con --step=

Ej:

	$ php com migrations migrate --dir=compania --to=db_153 -step=1

# Saltar migraciones

Puede haber un caso excepcional en que necesitemos saltearnos una migración o varias y para ello contamos con --skip=

Ej:

	$ php com migrations migrate --dir=compania --to=db_153 --skip=1

En principio, --step= y --skip= serían combinables.


# Simular migraciones

Las migraciones se pueden "simular" agregando el parámetro --simulate

Ej:

	$ php com migrations migrate --file=users/0000_00_00_00000001_users.php --simulate


# Volver para atrás 

Para volver para atrás migraciones es con el comando "migrations rollback" pero debe existir el método down() y éste debe habere sido escrito de forma tal que revierta el cambio en la base de datos (es responsabilidad del usuario por ahora)

	$ php com migrations rollback [--step==N | --all]

	Rolling back '2020_10_28_161483_create_cables.php'
	Rolled back  '2020_10_28_161483_create_cables.php' --ok
	Rolling back '2020_10_28_161757_create_cable_categories.php'
	Rolled back  '2020_10_28_161757_create_cable_categories.php' --ok

<-- por defecto solo regresa una migración hacia atrás

Por defecto se ejecutan todas las migraciones pendientes (registradas en la tabla `migrations`) en órden cronológico (que en realidad es órden alfabético para los nombres de los archivos). 


# Especificar archivo de migración 

Es posible dar el archivo concreto de migración a ejecutar:

	$ php com migrations migrate --file=2021_09_13_27908784_user_roles.php

En el dado caso solo se ejecutará esa transacción.

Si en --file se incluye una ruta se ejecutará desde esa ruta (absoluta o relativa). Ej:

	$ php com migrations migrate --file=users/0000_00_00_00000001_users.php


# Especificar el directorio de las migraciones

Se puede brindar el directorio (de momento relativo a la carpeta migraciones) desde el cual se correrán todas las migraciones con el parámetro --dir=

Ej:

	php com migrations migrate --dir=compania_new --to=db_flor


Es posible combinar --dir= con --file=

Ej:

	php com migrations migrate --dir=compania --file=2021_09_28_29110773_0001_tbl_estado_maestro.php --to=db_189 


# Reintentar o forzar migraciones

Si por alguna razón la migración hubiera sido anotada en la tabla "migrations", esta no volverá a correr pero es posible "re-intentar" que la corra con la opción --retry o --force

Ej:

	php com migrations migrate --dir=compania --file=2021_09_28_29110773_0001_tbl_estado_maestro.php --to=db_189 --retry


# Especificar hacia que base de datos iran las migraciones

En el archivo de migración suele incluirse una referencia la conexion a DB a usar pero es posible omitir especificarla y luego correr la migración sobre la base de datos que se requiera pasando el nombre de la conexión a la base de datos con el parámetro --to=

Ej:
	php com migrations migrate --file=compania/2021_09_25_28831244_0001_tbl_estado_maestro.php --to=db_flor |less


# Hacer migraciones "inline"

Se extendió el comando "make migration" para que simplificar el agregado o remoción de campos:

make migration foo --dropColumn=algun_campo
make migration foo --renameColumn=viejo_nombre,nuevo_nombre
make migration foo --renameTable=viejo_nombre,nuevo_nombre
make migration foo --nullable=campo
make migration foo --dropNullable=campo
make migration foo --primary=campo
make migration foo --dropPrimary=campo
make migration foo --unsigned=campo
make migration foo --zeroFill=campo
make migration foo --binaryAttr=campo
make migration foo --dropAttributes=campo
make migration foo --addUnique=campo
make migration foo --dropUnique=campo
make migration foo --addSpatial=campo
make migration foo --dropSpatial=campo
make migration foo --dropForeign=campo
make migration foo --addIndex=campo
make migration foo --dropIndex=campo
make migration foo --trucateTable=campo
make migration foo --comment=campo

En principio no se daría soporte a --addColumn= desde la propia línea de comandos porque la definción de un campo puede incluir varios atributos y sería algo complejo hacerlo inline.


Para construcción de claves foráneas:
        
	--fromField | --fk= | --foreign= 
	--toField= | --references=  | --reference=
	--toTable= | --onTable | --on=
	--onDelete={cascade|restrict|setNull|noAction|setDefault} 
	--onUpdate={cascade|restrict|setNull|noAction|setDefault}
	--constraint=


En si, --fromField=, --fk= y --foreign= son alias como sucede en los demás casos.

Ej:

	make migration foo --fromField=user_id --toField=id --toTable=users --onDelete=cascade --onUpdate=setNull


Además,...

make migration foo --include-defaults (*)
make migration all --include-defaults
make migration all --include-defaults --exclude=belongs_to

* El parámetro --include-defaults crearía o agregaría los campos manejados automáticamente por el framework a excepción de los que se listen bajo --exclude=

Los campos agregados con --include-default serían los definidos en MyModel que por defecto son:

created_at
created_by
...
...
..,


Otra opción es implementar .defaults.php en migrations como constante con --include-defaults algo como:

	///foreign --- references Tabla tbl_estado
    ->foreign('est_intIdEstado')
    ->references('est_intId')
    ->on('tbl_estado')    
    ///foreign --- references Tabla tbl_usuario usu_intIdCreador
    ->foreign('usu_intIdCreador')
    ->references('usu_intId')
    ->on('tbl_usuario')
   ///foreign --- references Tabla tbl_usuario usu_intIdActualizador
   ->foreign('usu_intIdActualizador')
   ->references('usu_intId')
   ->on('tbl_usuario');


Adicional podría estar la opción --include-model-defaults que crearia / agregaría todos los campos presentes en MyModel.php 

Se planea extender las migraciones inline a la creación de tablas con la siguiente sintaxis:

	--field={nombre},clave:valor,clave:valor,....

Ej:

	--field=id,primary,auto,attr:unsigned
	--field=lastname,varchar:60,collation:latin1_general_ci
	etc

# Debugging de migraciones inline

La idea de las migraciones inline es evitar tener que buscar el archivo de migraciones, abrirlo y modificarlo pero sería cuestión de confiar en la migración generada.

Ej:

	php com make migration --table=bar --dir=some_dir --dropColumn=abc --renameColumn=xxx,zzz --nullable=ppp --dropNullable=kkk

Es posible sin embargo, debuguear el archivo generado de migración con los siguientes parámetros:

	--cat					muestra por pantalla (en la terminal) el archivo generado 
	--no-save | --dont		no escribe el archivo

Se habilita la creación de "migraciones inline" para simplificar la creación de migraciones en principio de ALTER TABLEs.

Ej:

	php com make migration --dir=test --table=bar --addPrimary=id 

genera:

	<?php

	use simplerest\core\interfaces\IMigration;
	use simplerest\libs\Factory;
	use simplerest\libs\Schema;
	use simplerest\core\Model;
	use simplerest\libs\DB;

	class Bar implements IMigration
	{
		/**
		* Run migration.
		*
		* @return void
		*/
		public function up()
		{
			$sc = new Schema('bar');
			$sc->field('id')->primary();
			$sc->alter();			
		}
	}

Nuevos parámetros disponibles -generalmente combinables- son:

	--dropColumn=
	--renameColumn=	
	--nullable=
	--dropNullable=
	--primary=
	--dropPrimary=
	--auto=
	--dropAuto
	--unsigned=
	--zeroFill=
	--binary=
	--dropAttr=
	--addUnique=
	--dropUnique=
	--dropSpatial=
	--addIndex=
	--dropIndex=
	--dropForeign=
	--renameTable=
	--truncate	
	--cat
	--no-save

Ej:

	php com make migration --name=nombre_tabla --pri=campo9,campo10 --auto=campo9 --dropColumn=campo1 --renameColumn=campo2,campo2b --removeColumn=campo3 --addUnique=campo2,campo3,campo5 --removeUnique=campo8 --renameTable=nuevo_nombre_tabla --nullable=campo4 --nullable=campo7 --dropNullable=campo8 -unsigned=campo5 --zeroFill=campo5 --nullable=campo15 --dropNullable=campo20,campo21 --dropColumn=campo18,campo30 --cat --no-save

"genera":

	<?php

	use simplerest\core\interfaces\IMigration;
	use simplerest\libs\Factory;
	use simplerest\libs\Schema;
	use simplerest\core\Model;
	use simplerest\libs\DB;

	class NombreTabla implements IMigration
	{
		/**
		* Run migration.
		*
		* @return void
		*/
		public function up()
		{
			$sc->renameTableTo('nuevo_nombre_tabla');
			$sc->dropColumn('campo1');
			$sc->dropColumn('campo3');
			$sc->dropColumn('campo18');
			$sc->dropColumn('campo30');
			$sc->renameColumn('campo2', 'campo2b');
			$sc->field('campo4')->nullable();
			$sc->field('campo7')->nullable();
			$sc->field('campo15')->nullable();
			$sc->field('campo8')->dropNullable();
			$sc->field('campo20')->dropNullable();
			$sc->field('campo21')->dropNullable();
			$sc->field('campo9')->primary();
			$sc->field('campo10')->primary();
			$sc->field('campo9')->addAuto();
			$sc->field('campo5')->zeroFill();
			$sc->unique('campo2','campo3','campo5');
			$sc->dropUnique('campo8');
			$sc->alter();			
		}
	}

Es posible especificar varios campos separados por coma en algunos casos.

Ej:
	--dropNullable=campo20
	--dropNullable=campo21

Equivale a:

	--dropNullable=campo20,campo21

Sin embargo se ha restringido esta opción para no generar confusiones ya que:

	--dropUnique=xxx,yyy,zzz

*no* sería borrar la clave única formada por xxx, yyy, zzz sino por esas tres "constaints" y por ese motivo *no* está disponible ni para --dropIndex= ni --dropUnique= entre otros. 

Actualmente las migraciones "inline" alcanza a los ALTER TABLE. Se planea eventualmente habilitar la creación de tablas via migraciones inline en un futuro.


# Crear migraciones programáticamente

Es posible crear migraciones de forma "programática" instanciando la clase MakeController o MakeControllerBase haciendo uso de la opción  --from_script=  para especificar el cuerpo del script.

La única restricción en caso de querer usarse "make migration" con la opción --from_script= es que el script no puede contener comillas dobles. 

Ej:

		$mgr = new MakeControllerBase();

        $script = "
        ALTER TABLE tbl_preferencias 
            ADD CONSTRAINT FK_tpf_IdEstado FOREIGN KEY (est_intIdEstado)
                REFERENCES tbl_estado(est_intId);";

        $name   = "tbl_preferencias-maestro";

        $folder = "company";

        $mgr->migration("$name", "--dir=$folder", "--from_script=\"$script\"")


También puede ser necesario forzar el nombre de la clase de php dentro del archivo de migración para lo cual se dispone de la opción --class_name=

Ej:

	mgr = new MakeControllerBase();
	// ...

	$mgr->migration("$name", "--dir=$folder", "--from_script=\"$script\"", "--class_name={$row['scr_varNombre']}")


Otra opción para crear un archivo de migración programáticamente sería leyendo el "molde" de una migración que se encuentra en /core/templates/Migration.php y haciendo un reemplazo de substring tal y como lo hace el comando make en MakeControllerBase:

	Strings::replace('### UP', $up_rep, $file);


En teoría sería posible,.....

	/*
		Creo la DB
	*/

	DB::getDefaultConnection();

	$db_name = $data['dba_varNombre'];
	
	$ok = Model::statement("CREATE DATABASE $db_name;");
	

	/*
		Creo las tablas
	*/

	$mgr = new MigrationsController();

	$folder = 'compania'; 
	$tenant = $db_name;

	$mgr->migrate("--dir=$folder", "--to=$tenant");

	/*
		Creo schemas y modelos
	*/

	$mk = new MakeControllerBase();
	$mk->any("all", "-s", "-m", "-f", "--from:$tenant");


# Ayuda 

El comando "migrations" tiene una ayuda que es invocada cuando no se pasan parámetros:

	$ php com migrations


# Multitenant

El framework tiene implementación de multitenencia a dos niveles: tablas y bases de datos. 

El método DB::getConnection() permite especificar opcionalmente el identificador de la conexión a base de datos a la que nos queremos conectar y la clase Model acepta una conexión así que es posible hacer lo siguiente:

Ej:

	$conn = DB::getConnection('db2');

	$m = (new Model())
		->setConn($conn)
		->table('cables');
		
	dd($m->get());

Ej:

	DB::getConnection('db2');

	$m = (new Model(true))
		->table('cables');
		
	dd($m->get());

o

	DB::getConnection('db2');

	$m = (new CablesModel())
	->connect();

	dd($m->get());

<-- require de la clase CablesModel y del schema CablesSchema

o 

	DB::getConnection('db2');

	$m = DB::table('cables');
	dd($m->get());

Ej. con migraciones:

	DB::getConnection('db2');

	$sc = new Schema('cables');

	$sc
	->int('id')->unsigned()->auto()->pri()
	->varchar('nombre', 40)
	->float('calibre')

	->create();

Para generar el archivo de migración anterior (las primeras dos líneas) se puede usar --to combinado con --table:

	php com make migration creacion_tabla_cables_bla_bla --to=db2 --table=cables


Nota:

Es importante notar que al hacer uso de config() se accede a una versión en caché del archivo config.php y éste helper es usado internamente por SimpleRest por lo cual lo siguiente *no* funcionará:

	config()['db_connection_default'] = 'db2';
	DB::getDefaultConnection();

De hecho si se hiciera un dd() o var_dump() de config() antes y después de intentar el cambio se verá que nada ha cambiado.

/*
	Incorrecto
*/

	config()['db_connection_default'] = 'db2';
	DB::getDefaultConnection();

	// no se verá reflejado cambio alguno
	dd(DB::getCurrentConnectionId());  

/*
	Correcto
*/

	DB::setConnection('db2');
	dd(DB::getCurrentConnectionId());


# fresh

Con "fresh" podemos hacer un "borrón y cuenta nueva" para migraciones sobre una base de datos en particular:

	php com migrations fresh --from=db_b --force

Cabe notar que comienza haciendo un DROP TABLE sobre cada tabla en la base de datos (esté o no en la tabla de migraciones) por lo cual este comando usado de este modo debe usarse con precaución.

También es posible hacer un "fresh" sobre una migración en particular:

	php com migrations fresh --file=2021_09_14_27910581_files.php --to:main --force

equivale a hacer:

	php com migrations rollback --file=2021_09_14_27910581_files.php --to:main
	php com migrations migrate --file=2021_09_14_27910581_files.php

También es posible hacer un "fresh" sobre migraciones en un directorio. 

Ej:

	php com migrations fresh --file=2021_09_14_27910581_files.php --to:main --force

En principio --file y --dir son combinables de igual forma que con "migrate"


# redo

El comando "migrations fresh" cuando se combina con --file y/o --dir produce el mismo efecto que "migrations redo".

Ej:

	php com migrations redo  --file=2021_09_14_27910581_files.php --to:main
y
	php com migrations fresh --file=2021_09_14_27910581_files.php --to:main

son equivalentes


# Tenancy a nivel de API Rest

Permitir elegir la DB (en realidad la conexión a dicha DB) desde los endpoints para sistemas donde cada cliente tenga su propia base de datos.

El tenant-id permitir que se pueda especificar no solo desde la url y del header sino dentro del payload del access_token 

  ?tenantid=<id>
o
  X-TENANT-ID (header)

Las bases de datos admitidas para un usuario en particular para el caso de autenticación via tokens JWT estaá incluida en el payload como "db_access"

  {
    "sub": "1234567890",
    "name": "<user-name>",
    "iat": 1516239022,
    "userid": "<user-id>",
    "db_access": [
		"<db-connection1>",
		"<db-connection1>",
		..
	]
  }

Cuando un usuario se loguea obtiene las conexiones a las DB(s) que ese usuario puede utilizar como un arreglo llamado "db_access" y estas son devueltas en la respuesta para que esa información pueda incluirse via parámetro ?tenantid=  en cada request para acceder a esas DB(s)

El arreglo "db_access" se arma via hook en el AuthController que es extendido por MyAuthController y es donde se define el método getDbAccess aunque también podría definirse en un Trait.  Ver trait DbAccess

	function getDbAccess($user_id) : Array {}

Un ejemplo de este método sería:

	function getDbAccess($user_id) : Array {
        // casting o validación por seguridad
        $user_id = (int) $user_id;

        $dbs = Model::query("SELECT dba_varNombre FROM `tbl_usuarios_x_base_datos` as uxb
        INNER JOIN tbl_usuario_empresa as u ON u.use_intId = uxb.usu_intIdUsuario 
        INNER JOIN tbl_base_datos as db ON db.dba_intId = bas_intIdBasedatos
        WHERE uxb.`usu_intIdUsuario` = $user_id",  \PDO::FETCH_NUM);

        return array_column($dbs, 0);
    }

https://stackoverflow.com/questions/13761336/rest-api-with-multi-tenant-database-separated-by-client/13764490#13764490
https://medium.com/@vivekmadurai/multi-tenancy-in-rest-api-a570d728620c
https://dzone.com/articles/multi-tenancy-in-the-api-world-made-easy


Ventajas del multi-tenant implementado con múltiples DB(s) ->

  - Ofrecen seguridad extrema (al sistema) si cada usuario solo puede operar sobre una DB en particular. 
  
  Para que tenga sentido habría que crear un usuario del motor de DB (mysql, etc) para manejar cada DB con permisos restringidos a esa DB.

  - Si las DB están distribuidas en distintos servidores (accesibles via API por ejemplo) se puede distrubuir la carga de un servidor creando nuevos usuarios (ej: vendedores) en otro servidor cuando ese esté saturado.


Además del multitenant via DB se pueden tener varios usuarios compartiendo tablas y el sistema es capaz de garantizar el aislamiento de los recursos (registros) de cada usuario gracias al uso del ACL.

Para que la separación de recursos por usuario dentro del ámbito de las tablas de una misma base de datos sea posible es necesario que esté definido el campo 'belongs_to' o equivalente via la propiedad $belongsTo en el modelo de la tabla correspondiente y esté presente en la tabla como tal.  

El campo 'belongs_to' es de manejo automático del framework y se saca provecho definiendo permisos como "read" y "read_all" para las tablas que lo implementan.

Ver sección de configuración de "tentant groups"


# Sub-recursos en las APIs

Se implementa parcialmente el concepto de HATEOAS permitiendo definir relaciones con otras entidades (que deben tener su correlato en llaves foráneas) en endpoints.

Por ejemplo si se quisiera que se hiciera un "JOIN" entre productos y sus categorías:

	class Products extends MyApiController
	{ 
		static protected $soft_delete = true;

		static protected $connect_to = [
			'product_categories'
		];

		function __construct()
		{       
			parent::__construct();
		}        
	} 

Al especifica el parámetro "_related=1", la salida será algo como:

	{
		"data": {
			"products": {
				"id": 100,
				"name": "Vodka",
				"description": null,
				"size": "2 1/4 L",
				"cost": 201,
				"created_at": "2019-07-04 00:00:00",
				"created_by": null,
				"updated_at": "2019-11-24 22:46:44",
				"updated_by": null,
				"deleted_at": null,
				"deleted_by": null,
				"is_active": 1,
				"is_locked": 1,
				"workspace": "",
				"belongs_to": 90,
				"category": 3
			},
			"product_categories": [
				{
					"id_catego": 3,
					"name_catego": "miscelaneos"
				}
			]
		},
		"status_code": 200,
		"error": "",
		"error_detail": ""
	}


Además es posible "filtrar" cuales de todas las relaciones especificadas en el ApiController correspondiente en la propiedad $connect_to se quiere traer con include=

Ejemplos:

	http://simplerest.lan/api/v1/products?tenantid=az&include=product_categories
	http://simplerest.lan/api/v1/products/145?tenantid=az&_related=true&include=users

Si se especifica el parámetro "include" se asume que se quiere traer las relaciones como si "_related=1"


Es posible formatear el JSON de la respuesta con opciones dentro del config.php 

	'include_enity_name' => true,
	'nest_sub_resources' => false,


Notar que Ud. no debe suprimir el campo con el que se arme la relación entre las tablas. Ej:

	http://simplerest.lan/api/v1/products?tenantid=az&fields=id,name,cost,category&_related=true


    "data": {
        "products": [
            {
                "id": 100,
                "name": "Vodka",
                "cost": 201,
                "category": 3,
                "product_categories": {
                    "id_catego": 3,
                    "name_catego": "miscelaneos"
                }
            },
            {
                "id": 197,
                "name": "Guanabanas",
                "cost": 51,
                "category": 2,
                "product_categories": {
                    "id_catego": 2,
                    "name_catego": "frutas"
                }
            },

Pero si Ud. suprimiera "category" fallará:

	http://simplerest.lan/api/v1/products?tenantid=az&fields=id,name,cost&_related=true

<-- con "fields" especifico campos pero omito category"

Nota: Es importante notar que la propiedad $connect_to es parte de la API y no del Modelo y es obligatorio pasar el parámetro "_related=1" (con guión bajo delante) para habilitar los sub-recursos tanto para el listar como para el ver un recurso individual


# Select de campos con HATEOAS

Siempre es posible aplicar filtros y seleccionar que campos se van a mostrar pero el "id" del recurso principal no puede omitirse si se desea traer sub-recursos ya que con él se arman las relaciones.

Ej:

	/api/v1/products?tenantid=az&fields=id,cost

<-- válido

Pero,...

	/api/v1/products?tenantid=az&fields=cost

<-- no traerá subrecursos relacionados


# Creación de recursos con sub-recursos

POST

{
    "data": {
        "products": {
            "name": "Juguito Fruticon",
            "description": "XXXXXXXXX",
            "size": "1L",
            "cost": 351
        },
        "product_categories": [
            {
                "id_catego": 1
            },
            {
                "id_catego": 3
            }
        ]
    }
}


POST

{
    "data": {
        "products": {
            "name": "Juguito Fruticon",
            "description": "XXXXXXXXX",
            "size": "1L",
            "cost": 351
        },
        "product_categories": [
            {
                "id_catego": 1
            },
            {
                "name_catego": "saludable"
            },
            {
                "name_catego": "en_promo"
            }
        ]
    }
}

<-- si existe el registro relacionado que lo relacione y sino que lo cree y lo relacione.

Para no meter todo dentro "data" la forma sería anidar recursos:

{
    "products": {
        "name": "Juguito Fruticon",
        "description": "XXXXXXXXX",
        "size": "1L",
        "cost": 351,

        "product_categories": [
            {
                "id_catego": 1
            },
            {
                "id_catego": 3
            }
        ]
    }    
}

E inclusive podría no incluirse el nombre de la entidad principal quedando simplificado a:

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "product_categories": [
        {
            "id_catego": 1
        },
        {
            "id_catego": 3
        }
    ]
}    

<-- forma elegida y actualmente la única soportada.

Por supuesto podría haber más relaciones, por ejemplo con un usuario:

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "users": {
        "id": 1
    },

    "product_categories": [
        {
            "id_catego": 1           	 <-- solo tiene sentido pasar el ID si es una relación de muchos a muchos
        },
        {
            "id_catego": 3
        },
		{
			"name_catego": "saludable"  <-- puede ser una relación de 1 a muchos o muchos a muchos
		},
		{
			"name_catego": "en_promo"
		}
	]
}   

La relación *debería* poder hacerse no solo por el nombre de la tabla relacionada sino por el campo que es FK, lo cual tiene la ventaja de poder manejar más de una relación entre dos tablas:

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "belongs_to": {							<---    FK
        "id": 1
    },

    "category": [							<---	FK
        {
            "id_catego": 1
        },
        {
            "id_catego": 3
        },
		{
			"name_catego": "saludable"
		},
		{
			"name_catego": "en_promo"
		}
	]
}   

Aclarando dudas,......

Si existe una única relación entre una tabla y otra "users" via la FK "belongs_to" entonces:

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "users": {
        "id": 2
    }
}    

Es equivalente a ....	

{
    "name": "Juguito Fruticon",
    "description": "XXXXXXXXX",
    "size": "1L",
    "cost": 351,

    "belongs_to": 2
}    


# Relación de muchos a muchos (M:N)

Si se desea que el framework maneje de forma automática la relación con una tabla, ésta debe agregarse al array $connect_to en la API, sea ésta una tabla directamente relacionada o bien esté del otro lado de una "tabla puente" (referida aquí de forma indistinta como "pivot").

Supongamos que "tbl_categoria_persona" es una tabla relacionada a través de "tbl_categoria_persona_persona", entonces:

Ej:

	class TblPersona extends MyApiController
	{ 
		static protected $soft_delete = true;
		static protected $connect_to = [
			"tbl_estado",
			//  ...
			"tbl_categoria_persona" 
		];	
	} 

Y se puede enviar un JSON como:

	{
		"per_varIdentificacion" : "1152472014",
		"per_varDV" : "0",
		"per_varRazonSocial" : "xyz",
		// ..

		"tbl_categoria_persona": [
			{
				"cap_intId": "10",
				"tbl_categoria_persona_persona.nota": "Esto es una nota"
			},
			{
				"cap_intId": "14"
			} 
		]
	}

Como puede apreciarse es posible enviar campos propios de la tabla puente si están debidamente cualificados con notación tabla.camp

Veamos otro caso:

Supongamos que existe una relación N:M entre "products" y "tags". Pues bien podría enviarse el ID de cada tag dentro de products:

	{
		"name": "Juguito Fruticon!!",
		"description": "XXXXXXXXX",
		"size": "1L",
		"cost": 351,

		"tags": [
			{ 
				"id_tag": 1
			},
			{ 
				"id_tag": 4
			}
		]
	}    
  
También es posible aunque algo menos performante enviar los campos de los de la tabla relacionada así:

	{
		"name": "Juguito Fruticon!!",
		"description": "XXXXXXXXX",
		"size": "1L",
		"cost": 351,

		"tags": [
			{ 
				"texto": "saludable"
			},
			{ 
				"texto": "en promoción"
			}
		]
	}   

La única condición para esta última forma es que el conjunto de valores que enviemos determine unívocamente un registro porque sino no se sabría a cual enlazar desde la tabla puente. Caso contrario vería un mensaje de error como el siguiente:

	{
		"status": 400,
		"error": {
			"type": null,
			"code": null,
			"message": "There are more than one rows in tags matching with sent data",
			"detail": null
		}
	}


Notas:  

1) No es necesario agregar la tabla puente al array $connect_to en ningún caso.

2) Si crearan una tabla puente deberán correr el comando:

	php com make pivot_scan --from:una_db_del_tenant

o....

	php com make schema all --from:una_db_del_tenan -f


# Endpoints para tablas puente

También es posible generar endpoints para tablas puente e incluir las relaciones hacia las tablas inmediatamente relacionadas con $connect_to en la api. 


# Schema y las reglas de validación via endpoint

Pasando los parámetros _schema=true o _rules=true en cualquier endpoint se obtienen el schema completo y las reglas de validación en particular respectivamente.

Ej: 

	http://simplerest.lan/api/v1/products?tenantid=az&_rules=1

Rta:

	{
		"rules": {
			"id": {
				"type": "int"
			},
			"name": {
				"type": "str",
				"max": 50,
				"required": true
			},
			"description": {
				"type": "str",
				"max": 240
			},
			"size": {
				"type": "str",
				"max": 30,
				"required": true
			},
			"cost": {
				"type": "int",
				"required": true
			},
			"created_at": {
				"type": "datetime"
			},
			"created_by": {
				"type": "int"
			},
			"updated_at": {
				"type": "datetime"
			},
			"updated_by": {
				"type": "int"
			},
			"deleted_at": {
				"type": "datetime"
			},
			"deleted_by": {
				"type": "int"
			},
			"is_active": {
				"type": "bool"
			},
			"is_locked": {
				"type": "bool"
			},
			"workspace": {
				"type": "str",
				"max": 40
			},
			"belongs_to": {
				"type": "int"
			},
			"category": {
				"type": "int"
			}
		}
	}


# UUIDs

El framework reconoce a un campo como tipo "uuid" cuando el nombre es justamente "uuid" o "guid" de tipo compatible con un string y tiene el atributo de PRIMARY KEY. 

Cuando las condiciones mencionadas se cumple, se incluye de forma automática el trait para manejo de Uuids y el framework se encarga de gestionar esta funcionalidad.


# Librerías

	Se pueden crear cuantas librerías se requiera. Ëstas deben ser clases y usar namespaces correctamente por lo cual se sugiere crearlas via comando make:

		php com make lib mi_libreria

	o ...

		php com make lib folder/mi_libreria

	y si fuera necesario forzar la creación del archivo use -f o --foce

		php com make lib folder/mi_libreria -f


# Helpers

	Un helper es un conjunto de funciones por fuera del ámbito de una clase y su propósito es hacer más fácil la utilización de funcionalidades de uso recurrente.

	Para crear un helper:

		php com make helper mi_helper

	o ...

		php com make helper folder/mi_helper

	Los helpers tienen su "autoload" por lo cual cualquier archivo helper será cargado automáticamente y por lo mismo no debe abusarse de esta característica para no degradar la performance.

	El autoload de helpers está disponible en controladores, modelos y vistas pero no el config.php ni el index.php 


# Service Providers

El framework provee una forma de "plugins" o "paquetes" inspirada en la de Laravel. Los paquetes pueden alojarse en cualquier parte pero en /packages hay un paquete de demostración.

El primer paso es crear la ruta donde alojaremos el paquete y por convención (inspirada en Laravel) será dentro de /packages. Cada paquete tiene un nombre conformado por dos partes: [VENDOR or CREATOR] / [PACKAGE NAME]

Luego debemos inicializar Composer dentro del directorio creado lo que generará el archivo composer.json

	composer init

Los paquetes deben registrarse en config.php agregándose a $providers[] 

	/*
		Service Providers
	*/

	'providers' => [
		devdojo\calculator\CalculatorServiceProvider::class,
		// ...
    ],


Además debe registrarse en Composer (composer.json a nivel de root) agregando el bloque:

	"autoload": {
		"classmap": [
			"database"
		],
		"psr-4": {
			"App\\": "app/",
			"Devdojo\\Calculator\\": "packages/devdojo/calculator/src"
		}
	},

y correr el comando

	composer dump-autoload
	

Actualmente el soporte solo cubre la rutas con funciones anónimas y controladores. Falta agregar soporte para migraciones, traducciones, vistas, etc.

Los paquetes funcionan *solamente* con rutas y *no* con el FrontController.

Un Service Provider debe extender la clase ServiceProvider y de mínima implementar el método boot() al inicio de la aplicación.

	/**
     * Bootstrap the application services.
     *
     * @return void
     */
    public function boot()
    {
        
    }

    /**
     * Register the application services.
     *
     * @return void
     */
    public function register()
    {
       
    }     


Leer 
https://devdojo.com/devdojo/how-to-create-a-laravel-package


# Como servir vistas en el FrontEnd

Si bien SimpleRest es un framework RAD orientado a crear APIs, implementa la arquitectura Modelo-Vista-Controlador (MVC) y por ende es capaz de servie vistas.

Las vistas son servidas desde los controladores así que como priemr paso necesita es tener un controlador o crearlo:

	php com make controller mi_controlador

Luego dentro debe tener un método que servirá la vista llamando a $this->view('nombre-vista')

	function mi_metodo_de_controlador(){
		// ...

		$this->view('mi_archivo_vista.php');
	}
	
La vista puede requerir de datos y éstos son proporcionados por el controlador como un array con el nombre de las variables y sus valores. Ej:

	$this->view('mi_archivo_vista.php', [
		'nombre' => 'Pablo',
		'apellido' => 'Bozzolo'
	]);

O bien se puede utilizar el helper view()

	view('mi_archivo_vista.php', [
		'nombre' => 'Pablo',
		'apellido' => 'Bozzolo'
	]);

Y ya dentro de la vista, se crearan las variables $nombre y $apellido así:

<!-- Vista mi_archivo_vista.php -->
<?php

	var_dump($nombre); // Pablo
	var_dump($apellido);  // Bozzolo
?>

Por supuesto que pueden pasarse arrays. Ej:

	view('agenda.php', [
			'citas' => [
				[ 'name' => 'Visitar al cliente X', 'datetime' => '21-Set 15:00:00' ],
				[ 'name' => 'Completar proyecto Z', 'date' => '23-Set 00:00:00' ]
			],
	]);

Por defecto la variable $title en la vista deriva del nombre del controlador (ej: para el HomeController será "Home") pero se puede pasar el "title" a la vista:

	view('agenda.php', [
			'citas' => [
				[ 'name' => 'Visitar al cliente X', 'datetime' => '21-Set 15:00:00' ],
				[ 'name' => 'Completar proyecto Z', 'date' => '23-Set 00:00:00' ]
			],
			'title' => 'Agenda de citas'
	]);

Lógicamente el template debe manejar la varible $title para que se vea reflejado en el navegador:

	<head>
		<title><?= $title ?? ''; ?></title>
	</head>

Las vistas pueden contener HTML, PHP, CSS y JavaScript. Para los assets se cuenta con el helper assets()

Ej:

	<?= assets('img/logo.png') ?>" style="height: 100px;" />

Los assets se encuentran dentro de la carpeta public/assets y dentro la estructura es libre o sea puede organizarse de muchas formas:

	a)

	public/assets/
					css
					images
					js

	b)

	public/assets/
					módulo/
							css
							images
							js

# Templates

Por defecto se carga el template "app_layout.php" pero se pueden usar cuantos templates se desee y éste es especificado como tercer parámetro del método view()


# Vistas parciales

Se pueden incluir "secciones" por medio del helper section() y éstas pueden mostrarse de forma condicional:

Ej:

	<!DOCTYPE html>
	<html lang="es">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<title><?= $title ?? ''; ?></title>

		<base href="<?php echo $base_url; ?>">

		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">   
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	</head>
	<body>
		<?php
			if (!isset($hidenav) || !$hidenav){
				section('navbar.php'); 
			}            
		?>
		
		<div class="container">
			<main>
			<?php echo $content; ?>
			</main>
		</div>
	</body>
	</html>


En el template y en las vistas está disponible la variable $ctrl que alamcena el nombre del controlador actual tal y como aparece en la url. Ej: /home o /home/algo vale "home"


# Pasaje de variables hacia sub-vistas

Las variables pueden pasar del controlador a las vistas y el mismo truco puede usarse para pasar nuevamente variables desde por ejemplo el layout a una "section" así o de una vista a una subvista (section) o de una section a otra (sub-section)

	<?php
		section('navbar.php', [
			'my_var' => $my_var
		]);
    ?>


# Hookear la clase View

La clase View es extendida convenientemente como MyView a fin de poder agregar funcionalidad sin tener que tocar la clase View directamente que es parte del Core y sería sobreescrita al actualizar SimpleRest.

Ej:

	class MyView extends View 
	{
		function __construct(string $view_path, array $vars_to_be_passed  = null, string $layout = 'app_layout.php')
		{
			/*
				Agregado
			*/
			
			$vars_to_be_passed['my_var'] = 'Hello World!';

			parent::__construct($view_path, $vars_to_be_passed, $layout);
		}
	}


# Internacionalización

Para las traducciones se utiliza i18n y estas se alojan en el directorio app\locale y las mismas deben ser compiladas. Para Windows existe un .bat de ejemplo que realiza el proceso: compile_i18n.bat

La función de traducción es _() y esta se ha utilizado en la clase Validator y está pendiente de ser utilizada para el resto de clases provistas por SimpleRest.

El cambio de lenguaje lo maneja automáticamente SimpleRest ya sea via el parámetro GET "lang" (tiene prioridad o bien mediante el header "Accept-Language". Internamente se utliza la función helper setLang()

Los países están codificados en dos dígitos según la ISO-3166.

Ej:  

	/api/v1/mi_tabla?tenantid=db_xyz&lang=es_CO

También es posible hacer referencia solo al lenguaje y no al país:

Ej:  
	/api/v1/mi_tabla?tenantid=db_xyz&lang=es
 

Los textos a ser traducidos se encuentran config/messages.php y son compilados a config/msg_const.php mediante el comando:

	php com make constants


# NGINX web server

Agregar en el bloque lo siguiente:

	location /{
		rewrite ^([^.]*[^/])$ $1/ permanent;
		try_files $uri $uri/ /index.php?q=$uri&$args;
	}


# Consumo de APIs

El framework provee la función Url::consumeApi() para el consumo de APIs. 

    consumeApi(string $url, 
                string $http_verb, 
                $body = null, 
                ?Array $headers = null, 
                ?Array $options = null, 
                $decode = true)


En caso de éxito responde con algo como:

    Array
    (
        [data] => Array
            (
                [userId] => 1
                [title] => Some title
                [body] => Other long description
                [id] => 101
            )

        [http_code] => 201
        [error] => 
    )

En caso de fallo (http status code 3xx o 4xx o 5xx) algo como:

    Array
    (
        [data] => Array
            (
                [error] => Un error cualquiera
            )

        [http_code] => 400
        [error] => 
    )


Ej:

# Leer un recurso

	use simplerest\libs\Url;

	// ...

	$res = Url::consumeApi('https://jsonplaceholder.typicode.com/albums', 'GET');
	dd($res);

Y bien podría haber una lógica de control de errores:

	if ($res['http_code'] != 200){
        // notificar error
		return;
	} else {
        $data   = $res['data'];
        
        //...   
    }

Por defecto se hace un "decode" de la respuesta o sea se la trata como un JSON pero se puede des-activar ese comportamiento de dos formas:

1) Pasando un Accept de tipo 'text/plain' o ...

	$res = Url::consumeApi('http://xxxxxxxxxxxxx', 'GET', null, [
		'Accept' => 'text/plain'
	]);

2) Pasando como 6to parámetro false 

	$res = Url::consumeApi('http://xxxxxxxxxxxxx', 'GET', null, null, null, false);
  

# Crear un recurso

	$data = '{
		"userId": 1,
		"title": "Some title",
		"body": "Some long description"
  	}';

	$res = Url::consumeApi('https://jsonplaceholder.typicode.com/posts', 'POST', $data);
	dd($res);  

Ej:

# Body como array

	$data = [
            "userId" => 1,
            "title" => "Some title",
            "body" => "Other long description"
	];

	$res = Url::consumeApi('https://jsonplaceholder.typicode.com/posts', 'POST', $data);
	dd($res);  

Ej: 

# Enviar un archivo

	$xml_file = file_get_contents(ETC_PATH . 'ad00148980970002000000067.xml');

	$response = Url::consumeApi('http://localhost/pruebas/get_xml.php', 'POST', $xml_file, [
		"Content-type" => "text/xml"
	]);

donde get_xml.php puede ser algo como:

	<?php

	try {
		$postData = file_get_contents('php://input');
		$data = @file_put_contents("file.xml", $postData);

		if ($data == false){
			throw new Exception("Error trying to write file", 1);
		}

		echo json_encode(['data' => $data ]);
	} catch (\Exception $e) {
		echo json_encode(['error' => $e->getMessage()]);
	}


Todos los verbos http (GET, POST, PUT, PATCH,...) son soportados


# Autorización 

Web tokens pueden ser enviados a la función consumeApi() via el array de headers.

Ej:

    $response = Url::consumeApi('http://xxxxxxxxx:8080/api/some_resource', 'GET', null, [
        "Authorization" => "Bearer xxxxxxxxxxxxxxxxxxxxxxxxxx"
    ]);


# Encodeo base 64

Lo imporante es no solo encodear sino pasar el Content-type correcto.

Ej:

    $encoded = base64_encode($file);

    $response = Url::consumeApi('http://xxxxxxxxx:8080/api/some_resource', 'POST', $encoded, [
        "Content-type"  => "text/plain"
    ]);


### Componentes del core del framework

# Base de datos

Se consideran componentes del core de SimpleRest cualquier archivo dentro de /app/core y también las librerías y helpers que vienen con el framework ya que muy probablemente son dependencias del mismo.

Específicamente respecto de lo que es manejo de base de datos se pueden enumerar 4 clases y el helper db.php 

Model (.php)		Query Builder
Paginator (.php)	Paginador
DB (.php)			Administración de conexiones
Schema (.php)		Escritura y lectura sobre RDBMS 
db (.php) 			Helpers para bases de datos

Relación:

db -----> DB <------> Model --> Paginator

Schema es usado por las clases MakeControllerBase (comandos "make") y MigrationsController (migraciones).
No hay dependencias entre Schema y Model porque la segunda solo crea comandos pero no los ejecuta.

Actualmente Model soporta MySQL / MariaDB / SQLite y Postgres pero Schema es más limitada y se planea extender su funcionalidad para cubrir más RDBMS mediante traits. 


# Http

Relacionado con el tema de peticiones http podemos enumerar las siguientes clases y helpers:

Response 			Manejo de respuestas http		
Request				Procesamiento de peticiones http
FrontController		Front controller
Route				Enrutador
Url					Librería
ApiController 		Creación de APIs Restful

Hay más clases relacionadas pero se mencionaron las principales.


# Validaciones

Validator
ValidationRules


# Archivos

Files				Utilidades para el manejo de archivos
FileUploader	Manejador de uploads


# Seguridad

Acl
FoldersAclExtension


# Debugging

Debug				


# Manejo de errores

ExceptionHandler 	Trait 


# Manejo de cadenas

Strings 			Librería


# Envio de correos

Mails				Librería


### Strings

La clase Strings provee una batería de métodos para manejo conveniente de cadena de caracteres.

	tabulate(string $str, int $tabs, ?int $first = null, ?int $last = null)
	diff(string $s1, string $s2)
	rTrim(string $needle, string $haystack)
	trimFromLastOcurrence(string $substr, string $str)
	match(string $str, $pattern, $result_position = null)
	matchOrFail(string $str, string $pattern, string $error_msg = null)
	slice(string &$str, string $pattern, callable $output_fn = NULL)
	sliceAll(string &$str, string $pattern)
	matchParam(string $str, $param_name, ?string $arg_expr = '[a-z0-9A-Z_-]+')
	camelToSnake(string $name)
	snakeToCamel(string $name)
	endsWith(string $substr, string $text, bool $case_sensitive = true)
	contains(string $substr, string $text, bool $case_sensitive = true)
	containsAny(Array $substr, $text, $case_sensitive = true)
	containsWord(string $word, string $text, bool $case_sensitive = true)
	containsWords(Array $words, string $text, bool $case_sensitive = true)
	containsAnyWord(Array $words, string $text, bool $case_sensitive = true)
	equal($s1, $s2, $case_sensitive = true)
	replace($search, $replace, &$subject, $count = NULL, $case_sensitive = true)
	replaceNth(string $search, string $replace, string $subject, int $occurrence)
	removeMultipleSpaces($str)
	stringTochars($s)
	replaceFirst($from, $to, $subject)   ---revisar
	replaceLast($search, $replace, $subject) --revisar
	middle(string $str, int $ini, ?int $end = null) : string
	left(string $str, $to_pos)
	right(string $str, $from_pos)
	getClassName(string $file_str, bool $fully_qualified = true)
	getClassNameByFileName(string $filename, bool $fully_qualified = true)
	filter(Array $reg, Array $conditions)
	removeUnnecessarySlashes(string $path): string
	removeTrailingSlash(string $path): string
	addTrailingSlash(string $path): string


Strings::match() verifica si el string cumple con el patrón o alguno de los patrones proporcionados.

Ej:

	$o = '--name=xYz';
	d(Strings::match($o, '/^--name[=|:]([a-z][a-z0-9A-Z_]+)$/'));

Ej:

Se pueden evaluar varios patrones y ver si alguno cumple.

	$o = '--nama=xYz';
	d(Strings::match($o, [
		'/^--name[=|:]([a-z][a-z0-9A-Z_]+)$/',
		'/^--namae[=|:]([a-z][a-z0-9A-Z_]+)$/',
		'/^--nombre[=|:]([a-z][a-z0-9A-Z_]+)$/'
	]));


Strings::matchParam() parsea parámetros del tipo --nombre_param={valor}

Ej:

Un parámetro $o tiene el patrón --renameTable={algo} ?

	$_renameTable  = Strings::matchParam($o, 'renameTable');

Ej:

El parámetro $o tiene un parámetro --pri= o --primary= donde el argumento puede ser cualquier cosa (.*) ?

	$_primary  = Strings::matchParam($o, ['pri', 'primary'], '.*');

Ej:

El parámetro *no* lleva argumento y puede ser --dropPrimary o --delPrimary 

	$_dropPrimary  = Strings::matchParam($o, ['dropPrimary', 'delPrimary'], null);


### Variable dumping 

Para imprimir en pantalla o en la terminal de forma sencilla cualquier tipo de dato el framework provee las clases VarDump, StdOud y el helper dd()

El helper dd() y d() son solo atajos para VarDump::dd()

	dd($val, $msg = null, bool $additional_carriage_return = false)
	d($val, $msg = null);

Mientras que dd() por defecto no agrega retornos de carro adicionales, d() si lo hace.

Ej:

	dd([4,5, 7], "My Array");
	dd('hola!', null);
	dd(677.55, null);
	dd(true, 'My bool');

Salida:

	--[ My Array ]-- 
	Array
	(
		[0] => 4
		[1] => 5
		[2] => 7
	)

	hola!

	677.55
	--[ My bool ]-- 
	true


La clase StdOut está pensanda para simplificar el uso de la clase Debug en aplicaciones de consola (aunque su uso no es exclusivo) y permite "encender" o "apagar" la salida fácilmente sin necesidad de retener el buffer.

	static function hideResponse()
	static function showResponse()
	static function pprint($v, bool $additional_carriage_return = false))


### Perfilador del código

Para el perfilado de tiempos de ejecución SimpleRest provee la librería Time.

Lo primero es elegir el intervalo de medición (NANO, MICRO o MILI segundos). Se puede especificar cuántas intereaciones de van a realizar y suprimir la salida estándar con Time::noOutput().

Ej:

	Time::setUnit('MILI');
	Time::noOutput();

	$conn = DB::getConnection();

	$t = Time::exec(function() use ($conn){         
		$sql = "INSERT INTO `baz2` (`name`, `cost`) VALUES ('hhh', '789')";
		$conn->exec($sql);
	}, 1);  
	
	dd("Time: $t ms");  


### La clase Files: utilidades de archivos

La librería Files tiene gran cantidad de funcionalidades como de borrado y copiado recursivo de archivos y directorios. Backups, etc.

replace(string $filename, $search, $replace) 						similar a str_replace() pero sobre archivos
pregReplace(string $filename, $search, $replace)					similar a preg_replace() pero sobre archivos
isAbsolutePath(string $path)										devuelve si la ruta es absoluta
getAbsolutePath()													retorna rota absoluta a ROOT_PATH
recursiveGlob($pattern, $flags = 0)									similar a glob() pero recursivo
getDir(string $path)												extrae el directorio de un path.
setBackupDirectory(string $path)									setea un path para hacer backups
cp(string $ori, string $dst, $simulate = false, $overwrite = true)	copia de archivos individuales con opción de backup
copy(string $ori, string $dst, ?Array $files = null, $except = [])	copia recursiva de archivos con opción de backup (*)
delete(string $file)												borra un archivo individual
deleteOrFail(string $file)											borra un archivo individual y sino existe, lanza excepción
globDelete($dir, ?string $glob_pattern = '*.*', $recursive = false)	borra archivos aplicando un patrón glob. No toca los directorios.
delTree(string $dir, bool $include_self = false)					borra archivos y directorios recursivamante pero puede conservar el padre.
logger($data, $file = 'log.txt')									hace un log de la data enviada. Exporta con json_encode()
dump($object, $filename = 'dump.txt', $append = false)				similar a logger() pero exporta con var_export
mkDir($dir, int $permissions = 0777, $recursive = true)				make directory recusivo
mkDirOrFail($dir, int $permissions = 0777, $recursive = true)		crea directorio o si falla genera excepción.

Nota:

Files::copy() permite especificar patrones glob tanto para incluir como excluir archivos pero en estos casos hacen referencia a ROOT_PATH y son recursivos (todas las ocurrencias).

Algunos ejemplos:

Ej:

Copiar un archivo

Files::cp('updates/2021-12-12-0.5.0-alpha/files/app/controllers/ShopiController.php',
'app/controllers/ShopiController.php');


Ej:

Copiar un archivo a una ruta sin especificar el nombre en el destino

Files::cp('updates/2021-12-12-0.5.0-alpha/files/app/controllers/ShopiController.php',
'app/controllers');

Ej:

Crear un archivo y hacer un backup en caso de existir en el destino

Files::setBackupDirectory(ROOT_PATH . 'backup'); 
Files::cp('updates/2021-12-12-0.5.0-alpha/files/app/controllers/ShopiController.php',
'app/controllers/ShopiController.php');

Ej:

Copiar recursivamente archivos de una ruta a otra 

$ori = '/home/www/simplerest';
$dst = '/home/feli/Desktop/UPDATE';

Files::copy($ori, $dst, [
	'docs'
	'/home/www/simplerest/docs/dev/TODO Supra.txt'
]);

Se puede especificando la ruta absoluta a un archivo como ClientInterface.php en el ejemplo.

Ej:

$ori = '/home/www/simplerest';
$dst = '/home/feli/Desktop/UPDATE';

Files::copy($ori, $dst, [
	'docs',
	'/home/www/simplerest/vendor/psr/http-client/src/ClientInterface.php'
]);

Ej:

Copiar recursivamente archivos de una ruta a otra a excepción de ciertos archvos o directorios.

$ori = '/home/www/simplerest';
$dst = '/home/feli/Desktop/UPDATE';

Files::copy($ori, $dst, [
	'docs'
], 
[
	'docs/dev',
	'/home/www/simplerest/docs/dev/TODO Supra.txt',
	'docs/INSTALACION.txt'
]);

Ej:

Especificando patrones de glob copiar recursivamente archivos y directorios de una ruta a otra a excepción de ciertos archivos.

$ori = '/home/www/simplerest';
$dst = '/home/feli/Desktop/UPDATE';

$str_files = <<<'FILES'
	config/constants.php
	app/core
	app/controllers/UpdateController.php     
	public/app.php
	glob:*.txt
FILES;

$files = explode(PHP_EOL, $str_files);

$except =  [
	'db_dynamic_load.php',
	'PrepareUpdateController.php',
	'docs/dev',
	'glob:*.zip'
];

Files::copy($ori, $dst, $files, $except);


### Actualizaciones del framework

El escenario es que el framework evoluciona, se crean nuevas librerías, funciones cambian de nombre, etc. 

# Creación del update

	- Se crea un nuevo paquete de actualización nombrado con la fecha-hora corriente. 

	- Se introduce una descripción general del paquete que se irá actualizando.

	- A medida que se introducen cambios como el renombrado de una función o archivo o un cambio de ubicación se escribe una nueva "tarea" que en si indica qué cambios hacer. En si es como una migración pero sobre código en vez de sobre la base de datos. 

	Cada tarea lleva una descripción.

	Cabe notar que cambio es una nueva tarea. Éstas se ejecutarán de forma secuencial de forma cronológica.

	- Se copian los archivos nuevos en una ubicación especial.

	- Todo el paquete (archivos + tareas + descripción) es comprimido con el nombre del paquete.

	- El paquete ya comprimido es subido a un repositorio. 

	El repositorio es accesible via endpoint habilitando operaciones para el usuario final como:

		- listar
		- descargar

# Update

El usuario mediante comandos podrá verificar cuántos updates tiene pendientes enviando las credenciales al endpoint correspondiente:

	GET {url_repository}/api/v1/files?folder={folder_dado}&created_at[gt]={last_updated}&orderBy=created_at

<-- chequear el funcionamiento de Files !!!

Se recomienda:

- Usar "api keys" como método de autenticación sobre el endpoint /api/v1/updates  